============================== PROJECT STRUCTURE ==============================
SwiftDevBot-Lite/
    ├── .git/ [EXCLUDED_DIR]
    ├── .venv/ [EXCLUDED_DIR]
    ├── alembic_migrations/
    │       ├── versions/
    │       │       ├── .gitkeep
    │       │       └── d10040ec2cb7_initial_migration_for_core_tables.py
    │       ├── env.py
    │       └── script.py.mako
    ├── cli_commands/
    │       ├── __init__.py
    │       ├── backup_cmd.py
    │       ├── bot_cmd.py
    │       ├── cli_utils.py
    │       ├── control_cmd.py
    │       ├── db_cmd.py
    │       ├── module_cmd.py
    │       ├── setup_cmd.py
    │       ├── system_cmd.py
    │       └── user_cmd.py
    ├── core/
    │       ├── admin/
    │       │       ├── entry/
    │       │       │       ├── __init__.py
    │       │       │       └── handlers_entry.py
    │       │       ├── logs_viewer/
    │       │       │       ├── __init__.py
    │       │       │       ├── handlers_logs.py
    │       │       │       ├── handlers_modules.py
    │       │       │       └── keyboards_modules.py
    │       │       ├── modules_mgmt/
    │       │       │       ├── __init__.py
    │       │       │       ├── handlers_modules.py
    │       │       │       └── keyboards_modules.py
    │       │       ├── roles/
    │       │       │       ├── __init__.py
    │       │       │       ├── handlers_crud_fsm.py
    │       │       │       ├── handlers_details.py
    │       │       │       ├── handlers_list.py
    │       │       │       ├── handlers_role_perms.py
    │       │       │       └── keyboards_roles.py
    │       │       ├── sys_info/
    │       │       │       ├── __init__.py
    │       │       │       ├── handlers_sys_info.py
    │       │       │       └── keyboards_sys_info.py
    │       │       ├── users/
    │       │       │       ├── __init__.py
    │       │       │       ├── handlers_details.py
    │       │       │       ├── handlers_direct_perms.py
    │       │       │       ├── handlers_list.py
    │       │       │       ├── handlers_roles_assign.py
    │       │       │       └── keyboards_users.py
    │       │       ├── __init__.py
    │       │       ├── filters_admin.py
    │       │       ├── handlers_log_viewer.py
    │       │       ├── handlers_module_management.py
    │       │       └── keyboards_admin_common.py
    │       ├── cache/
    │       │       ├── __init__.py
    │       │       └── manager.py
    │       ├── database/
    │       │       ├── __init__.py
    │       │       ├── base.py
    │       │       ├── core_models.py
    │       │       ├── db_utils.py
    │       │       └── manager.py
    │       ├── events/
    │       │       ├── __init__.py
    │       │       └── dispatcher.py
    │       ├── http_client/
    │       │       ├── __init__.py
    │       │       └── manager.py
    │       ├── i18n/
    │       │       ├── __init__.py
    │       │       ├── middleware.py
    │       │       └── translator.py
    │       ├── rbac/
    │       │       ├── __init__.py
    │       │       └── service.py
    │       ├── schemas/
    │       │       └── module_manifest.py
    │       ├── sys_modules/
    │       │       └── __init__.py
    │       ├── ui/
    │       │       ├── __init__.py
    │       │       ├── callback_data_factories.py
    │       │       ├── handlers_core_ui.py
    │       │       ├── keyboards_core.py
    │       │       ├── navigation_core.py
    │       │       └── registry_ui.py
    │       ├── users/
    │       │       ├── __init__.py
    │       │       ├── middleware.py
    │       │       └── service.py
    │       ├── __init__.py
    │       ├── app_settings.py
    │       ├── bot_entrypoint.py
    │       ├── logging_manager.py
    │       ├── module_loader.py
    │       └── services_provider.py
    ├── locales/
    ├── modules/
    │       ├── example_module/
    │       │       ├── __init__.py
    │       │       ├── callback_data_factories_example.py
    │       │       ├── handlers_example.py
    │       │       ├── keyboards_example.py
    │       │       ├── manifest.yaml
    │       │       ├── models.py
    │       │       ├── module_settings.yaml
    │       │       └── permissions.py
    │       ├── .gitkeep
    │       ├── __init__.py
    │       └── Create_modules.md
    ├── project_data/
    │       ├── Cache_data/
    │       │       └── .gitkeep
    │       ├── Config/
    │       │       └── modules_settings/
    │       │               └── example_module.yaml
    │       ├── core_backups/
    │       │       └── .gitkeep
    │       ├── Database_files/
    │       │       ├── .gitkeep
    │       │       └── sdb_clean_test.db [EXCLUDED_FILE]
    │       ├── Logs/
    │       │       ├── 2025/
    │       │       │       └── 08-August/
    │       │       │               └── 01/
    │       │       │                       └── 05_sdb.log [EXCLUDED_FILE]
    │       │       └── .gitkeep
    │       ├── module_backups/
    │       │       └── .gitkeep
    │       └── .gitignore
    ├── scripts/
    │       ├── clean_cache.py
    │       ├── commands.txt
    │       ├── create_project_structure.py
    │       ├── replace_uk_to_ua.py
    │       ├── reset_alembic.py
    │       ├── snapshot_generator.py
    │       └── test_db_support.py
    ├── .env
    ├── .env.example
    ├── .gitignore
    ├── alembic.ini
    ├── babel.cfg
    ├── config.yaml
    ├── project_snapshot.txt [EXCLUDED_FILE]
    ├── requirements.txt
    ├── run_bot.py
    ├── sdb
    └── sdb.py

======================================================================

------------------------------ FILE: config.yaml ------------------------------
# Шаблон конфигурации SwiftDevBot (config.yaml)
# Этот файл используется как шаблон для команды 'sdb config init'.
# Рабочая конфигурация пользователя находится в project_data/Config/core_settings.yaml

db:
  type: "sqlite"  # Тип базы данных: "sqlite", "postgresql", "mysql"
  # Путь к файлу SQLite, ОТНОСИТЕЛЬНО директории данных проекта (core.project_data_path)
  # sqlite_path: "Database_files/swiftdevbot.db" 
  # pg_dsn: "postgresql+asyncpg://user:pass@host:port/dbname" # DSN для PostgreSQL
  # mysql_dsn: "mysql+aiomysql://user:pass@host:port/dbname" # DSN для MySQL
  echo_sql: false # Логировать SQL-запросы SQLAlchemy (уровень DEBUG)

cache:
  # type: "memory" # Тип кэша: "memory", "redis"
  # redis_url: "redis://localhost:6379/0" # URL для Redis

telegram:
  # token: "ВАШ_ТЕЛЕГРАМ_ТОКЕН" # !!! РЕКОМЕНДУЕТСЯ УКАЗЫВАТЬ BOT_TOKEN В .env ФАЙЛЕ !!!
  polling_timeout: 30 # Таймаут для long polling (секунды)

module_repo:
  index_url: "https://raw.githubusercontent.com/soverxos/SwiftDevBot-Modules/main/modules_index.json" # URL к индексу модулей

core:
  # Путь к директории данных проекта. Может быть абсолютным или относительным к корню проекта.
  project_data_path: "./project_data" 
  super_admins: [] # Список Telegram ID супер-администраторов, например: [123456789, 9876543210]
  
  # Путь к файлу со списком активных модулей, ОТНОСИТЕЛЬНО директории данных проекта
  enabled_modules_config_path: "Config/enabled_modules.json" 
  
  # Настройки логирования
  log_level: "INFO" # Уровень: TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL
  log_to_file: true # Писать ли логи в файл
  # Базовая директория для структурированных логов (относительно project_data_path).
  # Файлы будут создаваться в подпапках YYYY/MM-MonthName/DD/HH_sdb.log
  log_structured_dir: "Logs" 
  # Ротация для каждого часового файла лога по размеру.
  log_rotation_size: "100 MB" 
  # Как долго хранить структурированные логи (например, "30 days", "3 months").
  # Реализуется отдельной задачей очистки внутри бота.
  log_retention_period_structured: "3 months" 

  sdb_version: "0.1.0" # Версия ядра (можно не указывать здесь, если берется из дефолта модели)
  setup_bot_commands_on_startup: true # Устанавливать ли команды бота при старте

  i18n:
    # Путь к директории с файлами переводов (относительно корня проекта)
    locales_dir: "locales" 
    domain: "bot"
    default_locale: "en"
    available_locales: ["en", "ua"]


======================================================================

------------------------------ FILE: .gitignore ------------------------------
# === Swift / Xcode ===
.build/
DerivedData/
*.xcworkspace
*.xcodeproj/
*.xcuserdata/
*.swiftpm/
Package.resolved
TEST/

# Swift Playgrounds
timeline.xctimeline
playground.xcworkspace

# === Python ===
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class
*.so

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
project_data/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Virtual environments
.venv/
venv/
ENV/
env/ # Оставим один 'env/'
env.bak/
venv.bak/

# pipenv/poetry/pyproject artifacts
Pipfile.lock
poetry.lock
pyproject.toml.lock

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# === General ===
# macOS
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
Desktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msix
*.msm
*.msp
*.lnk

# Linux
*~

# Logs and temp
*.log
*.tmp
*.swp
*.swo
*.bak
*.backup
# *~ # Уже есть выше

# VSCode / JetBrains IDEs
.vscode/
.idea/
# *.swp # Уже есть выше
# *.swo # Уже есть выше

# === Database ===
*.db
*.sqlite
*.sqlite3

# === Environment ===
.env
.env.local
.env.*.local


======================================================================

------------------------------ FILE: requirements.txt ------------------------------
# requirements.txt
# Core Aiogram and Bot functionality
aiogram # Рекомендую последнюю стабильную версию 3.x, например, 3.7.0 или новее
python-dotenv

# Configuration
pydantic # Используем Pydantic v2
pydantic-settings
pydantic-extra-types # Для DSN и других доп. типов
PyYAML>=6.0

# Database (SQLAlchemy & Alembic)
SQLAlchemy[asyncio] # [asyncio] для поддержки асинхронных драйверов
alembic

# Async Database Drivers (выбери или оставь все, если планируешь тестировать все)
aiosqlite                 # Для SQLite
psycopg[binary]    # Для PostgreSQL (бинарная версия, чтобы избежать проблем с компиляцией)
# asyncpg>=0.27.0           # Альтернативный драйвер для PostgreSQL, если предпочтешь его psycopg
aiomysql           # Для MySQL

# Logging
loguru
parsedatetime
apscheduler

# CLI
typer[all] # [all] включает rich и другие полезности

# HTTP Client
aiohttp

# Version comparison (используется в ModuleLoader)
packaging

# Cache (опционально, но рекомендуется для MemoryCache с TTLCache)
cachetools
rich # Для красивого отображения в CLI

# System Information (для админ-панели)
psutil


======================================================================

------------------------------ FILE: sdb.py ------------------------------
# sdb.py

import asyncio
import sys
import os
import subprocess
import time
from pathlib import Path

current_script_path = Path(__file__).resolve()
project_root = current_script_path.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

try:
    import typer
    from rich.console import Console
    from rich.panel import Panel
    from loguru import logger as global_logger 
except ImportError as e:
    print(f"Критическая ошибка: Необходимые библиотеки (Typer, Rich, Loguru) не установлены. {e}", file=sys.stderr)
    print(f"Пожалуйста, установите зависимости из requirements.txt или requirements-dev.txt:", file=sys.stderr)
    print(f"  pip install -r requirements.txt", file=sys.stderr)
    sys.exit(1)

sdb_console = Console()

try:
    from cli_commands.setup_cmd import config_app
    from cli_commands.db_cmd import db_app
    from cli_commands.module_cmd import module_app
    from cli_commands.user_cmd import user_app
    from cli_commands.backup_cmd import backup_app
    from cli_commands.system_cmd import system_app
    from cli_commands.control_cmd import control_app, PID_FILENAME 
    from cli_commands.bot_cmd import bot_app 
    from core.bot_entrypoint import run_sdb_bot 
except ImportError as e:
    sdb_console.print(f"[bold red]Критическая ошибка:[/]\n Не удалось импортировать компоненты SDB CLI или ядра: {e}")
    sdb_console.print("Убедитесь, что все файлы ядра и CLI на месте и PYTHONPATH настроен корректно.")
    sdb_console.print_exception(show_locals=False)
    sys.exit(1)
except Exception as e:
    sdb_console.print(f"[bold red]Критическая ошибка при инициализации SDB CLI (во время импортов):[/]\n {e}")
    sdb_console.print_exception(show_locals=True)
    sys.exit(1)

cli_main_app = typer.Typer(
    name="sdb",
    help="🚀 [bold cyan]SwiftDevBot CLI[/] - Утилита для управления вашим SDB!",
    rich_markup_mode="rich",
    add_completion=False,
    no_args_is_help=True,
    context_settings={"help_option_names": ["-h", "--help"]}
)

cli_main_app.add_typer(config_app, name="config", help="🔧 Управление конфигурацией SDB (init, info).")
cli_main_app.add_typer(db_app, name="db", help="🗄️ Управление базой данных и миграциями Alembic.")
cli_main_app.add_typer(module_app, name="module", help="🧩 Управление модулями SDB (плагинами).")
cli_main_app.add_typer(user_app, name="user", help="👤 Управление пользователями и ролями (RBAC).")
cli_main_app.add_typer(backup_app, name="backup", help="💾 Создание и управление бэкапами данных и БД.")
cli_main_app.add_typer(system_app, name="system", help="🛠️ Системные команды (обновление ядра, откат и др.).")
cli_main_app.add_typer(control_app, name="control", help="🚦 Управление процессом бота (stop, status, restart).") 
cli_main_app.add_typer(bot_app, name="bot", help="🤖 Управление Telegram-ботом SDB (команды, статус).") 

@cli_main_app.command(name="start", help="🚀 Запустить основной процесс Telegram бота SDB.")
def start_bot_command(
    debug: bool = typer.Option(
        False, "--debug", "-d", 
        help="Запустить бота в режиме отладки (увеличит уровень логирования до DEBUG)."
    ),
    background: bool = typer.Option(
        False, "--background", "-b",
        help="Запустить бота в фоновом режиме (демонизировать)."
    )
):
    from core.app_settings import settings 
    pid_file_path = settings.core.project_data_path / PID_FILENAME

    if pid_file_path.exists():
        try:
            with open(pid_file_path, "r") as f:
                pid = int(f.read().strip())
            if sys.platform != "win32":
                os.kill(pid, 0) 
                sdb_console.print(f"[yellow]SDB бот уже запущен (PID: {pid}). Используйте './sdb control stop' для остановки.[/yellow]")
                raise typer.Exit(code=1)
            else: 
                 sdb_console.print(f"[yellow]PID-файл существует (PID: {pid}). Если бот запущен, остановите его перед новым запуском.[/yellow]")
        except (OSError, ValueError): 
            sdb_console.print(f"[yellow]Обнаружен устаревший PID-файл ({pid_file_path}). Удаление...[/yellow]")
            pid_file_path.unlink(missing_ok=True)
        except Exception as e_pid_check:
             sdb_console.print(f"[red]Ошибка при проверке PID-файла: {e_pid_check}[/red]")

    if debug:
        sdb_console.print(Panel(f"[bold yellow]Запрос на запуск бота в режиме DEBUG.[/]", 
                                title="SDB Start (Debug Mode Requested)", expand=False, border_style="yellow"))
        os.environ["SDB_LAUNCH_DEBUG_MODE"] = "true"
        # SDB_CLI_DEBUG_MODE_FOR_LOGGING теперь не нужен здесь, 
        # т.к. app_settings.py уже настроил консольный лог.
        # Если очень нужно перенастроить консольный лог *именно для этого вызова sdb start*,
        # то можно сделать reload app_settings с установкой SDB_CLI_DEBUG_MODE_FOR_LOGGING.
        # Но проще положиться на то, что SDB_LAUNCH_DEBUG_MODE будет использован в bot_entrypoint.
    else:
        os.environ["SDB_LAUNCH_DEBUG_MODE"] = "false"
        # os.environ["SDB_CLI_DEBUG_MODE_FOR_LOGGING"] = "false" # Уже не так важно здесь

    if background:
        if sys.platform == "win32":
            sdb_console.print("[bold red]Фоновый режим (-b/--background) пока не поддерживается на Windows через эту команду.[/bold red]")
            sdb_console.print("Пожалуйста, запустите бота без флага -b или используйте другие средства для демонизации.")
            raise typer.Exit(code=1)

        sdb_console.print(Panel("[bold blue]Запуск SDB бота в фоновом режиме...[/]", 
                                title="SDB Start (Background)", expand=False, border_style="blue"))
        
        run_bot_script_path = project_root / "run_bot.py"
        
        env_for_subprocess = os.environ.copy()
        env_for_subprocess["SDB_SHOULD_WRITE_PID"] = "true"
        
        try:
            process = subprocess.Popen(
                [sys.executable, str(run_bot_script_path)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True, 
                env=env_for_subprocess
            )
            sdb_console.print(f"Процесс бота запущен в фоне (системный PID: {process.pid}).")
            sdb_console.print(f"Ожидание создания PID-файла '{PID_FILENAME}' (до 10 секунд)...")
            
            pid_file_created_successfully = False
            for i in range(10): 
                time.sleep(1)
                if pid_file_path.exists():
                    try:
                        actual_pid_from_file_str = pid_file_path.read_text().strip()
                        if actual_pid_from_file_str.isdigit():
                            actual_pid_from_file = int(actual_pid_from_file_str)
                            sdb_console.print(f"[green]PID-файл {pid_file_path} создан. PID бота: {actual_pid_from_file}.[/green]")
                            sdb_console.print("Для просмотра статуса используйте: [cyan]./sdb control status[/cyan]")
                            sdb_console.print("Для остановки используйте: [cyan]./sdb control stop[/cyan]")
                            pid_file_created_successfully = True
                            break
                        else:
                            sdb_console.print(f"[yellow]PID-файл создан, но содержит некорректное значение: '{actual_pid_from_file_str}'. Попытка {i+1}/10.[/yellow]")
                    except ValueError:
                        sdb_console.print(f"[yellow]PID-файл создан, но содержит нечисловое значение. Попытка {i+1}/10.[/yellow]")
                    except Exception as e_read_pid:
                         sdb_console.print(f"[yellow]Ошибка чтения PID из файла ({e_read_pid}). Попытка {i+1}/10.[/yellow]")

            if not pid_file_created_successfully:
                sdb_console.print(f"[yellow]Предупреждение: PID-файл не был корректно создан/прочитан в течение 10 секунд.[/yellow]")
                sdb_console.print(f"  Возможно, бот не запустился корректно в фоне или не смог записать PID. Проверьте логи бота.")
                sdb_console.print(f"  Системный PID запущенного процесса: {process.pid}. Попробуйте проверить его статус вручную.")

        except Exception as e_popen:
            sdb_console.print(f"[bold red]Ошибка при запуске бота в фоновом режиме: {e_popen}[/bold red]")
            sdb_console.print_exception(show_locals=True)
            raise typer.Exit(code=1)
    else:
        if not debug: 
             sdb_console.print(Panel("[bold green]Запуск Telegram бота SDB...[/]", 
                                title="SDB Start", expand=False, border_style="green"))
        try:
            os.environ["SDB_SHOULD_WRITE_PID"] = "false" 
            
            bot_coroutine = run_sdb_bot() 
            exit_code = asyncio.run(bot_coroutine)
            
            if exit_code != 0:
                sdb_console.print(f"[bold red]Бот завершил работу с кодом ошибки: {exit_code}[/]")
                sys.exit(exit_code)
            else:
                if not (os.environ.get("SDB_SHOULD_WRITE_PID", "false").lower() == "true"):
                    sdb_console.print("[bold green]Бот успешно завершил свою работу (штатное завершение).[/]")
                
        except KeyboardInterrupt:
            sdb_console.print("\n[bold orange_red1]🤖 Бот остановлен пользователем (Ctrl+C). Выход.[/]")
            sys.exit(0) 
        except Exception as e:
            sdb_console.print(Panel(f"[bold red]КРИТИЧЕСКАЯ ОШИБКА при запуске или работе бота:[/]\n{e}", 
                                    title="SDB Runtime Error", border_style="red", expand=True))
            global_logger.opt(exception=e).critical("Необработанное исключение в sdb.py start_bot_command")
            sdb_console.print_exception(show_locals=True) 
            sys.exit(1)

if __name__ == "__main__":
    try:
        if sys.platform != "win32":
            if not os.access(__file__, os.X_OK):
                current_mode = os.stat(__file__).st_mode
                os.chmod(__file__, current_mode | 0o111) 
                sdb_console.print("[dim green]Установлены права на исполнение для sdb.py[/dim]")
    except Exception as e_chmod:
        sdb_console.print(f"[dim yellow]Предупреждение: не удалось установить права на исполнение для sdb.py: {e_chmod}[/dim]")

    cli_main_app()


======================================================================

------------------------------ FILE: .env.example ------------------------------
# .env.example
# Пример файла переменных окружения для SwiftDevBot.
# Скопируйте этот файл в .env и заполните своими значениями.
# Строки, начинающиеся с #, являются комментариями.

# --- Telegram Bot ---
# ОБЯЗАТЕЛЬНО: Токен вашего Telegram бота. Получить у @BotFather.
BOT_TOKEN="ВАШ_ТЕЛЕГРАМ_БОТ_ТОКЕН"

# Таймаут для long polling (секунды). По умолчанию: 30 (из AppSettings)
# SDB_TELEGRAM_POLLING_TIMEOUT=30


# --- База Данных ---
# Тип используемой базы данных: "sqlite", "postgresql", "mysql"
# По умолчанию: "sqlite" (из AppSettings)
SDB_DB_TYPE="sqlite"

# Для SQLite:
# Относительный путь к файлу SQLite (от корня проекта или project_data_path).
# По умолчанию: "project_data/Database_files/swiftdevbot.db" (из AppSettings)
# SDB_DB_SQLITE_PATH="project_data/Database_files/sdb_prod.db"

# Для PostgreSQL:
# DSN (Data Source Name) для подключения к PostgreSQL.
# Формат: postgresql+<драйвер>://<user>:<password>@<host>:<port>/<dbname>
# Драйверы: asyncpg, psycopg (для psycopg SQLAlchemy 2.0 может требовать psycopg[binary])
# Пример: SDB_DB_PG_DSN="postgresql+psycopg://sdb_user:sdb_pass@localhost:5432/sdb_pg_database"
# SDB_DB_PG_DSN=""

# Для MySQL:
# DSN для подключения к MySQL.
# Формат: mysql+<драйвер>://<user>:<password>@<host>:<port>/<dbname>
# Драйверы: aiomysql, asyncmy
# Пример: SDB_DB_MYSQL_DSN="mysql+aiomysql://sdb_user:sdb_pass@localhost:3306/sdb_mysql_database?charset=utf8mb4"
# SDB_DB_MYSQL_DSN=""

# Логировать SQL-запросы SQLAlchemy (уровень DEBUG). true/false
# По умолчанию: false (из AppSettings)
# SDB_DB_ECHO_SQL="false"


# --- Кэш ---
# Тип кэша: "memory", "redis"
# По умолчанию: "memory" (из AppSettings)
SDB_CACHE_TYPE="memory"

# Для Redis:
# URL для подключения к Redis.
# Формат: redis://[:<password>@]<host>:<port>/<db_number>
# По умолчанию: "redis://localhost:6379/0" (из AppSettings)
# SDB_CACHE_REDIS_URL="redis://localhost:6379/0"


# --- Настройки Ядра (Core) ---
# Путь к директории данных проекта (логи, БД, конфиги модулей).
# По умолчанию: "./project_data" (относительно корня проекта, из AppSettings)
# SDB_CORE_PROJECT_DATA_PATH="./my_sdb_data"

# Список Telegram ID супер-администраторов через запятую.
# Пример: SDB_CORE_SUPER_ADMINS="12345678,98765432"
# По умолчанию: пустой список (из AppSettings)
SDB_CORE_SUPER_ADMINS=""

# Путь к файлу со списком активных модулей (относительно директории данных проекта).
# По умолчанию: "Config/enabled_modules.json" (из AppSettings)
# SDB_CORE_ENABLED_MODULES_CONFIG_PATH="Config/active_plugins.json"

# --- Настройки Логирования Ядра ---
# Уровень логирования: TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL
# По умолчанию: "INFO" (из AppSettings)
SDB_CORE_LOG_LEVEL="INFO"

# Писать ли логи в файл. true/false
# По умолчанию: true (из AppSettings)
# SDB_CORE_LOG_TO_FILE="true"

# Базовая директория для структурированных логов (относительно project_data_path).
# Файлы будут создаваться в подпапках YYYY/MM-MonthName/DD/HH_sdb.log
# По умолчанию: "Logs" (из AppSettings)
# SDB_CORE_LOG_STRUCTURED_DIR="MyBotLogs"

# Ротация для каждого часового файла лога по размеру.
# По умолчанию: "100 MB" (из AppSettings)
# SDB_CORE_LOG_ROTATION_SIZE="50 MB"

# Как долго хранить структурированные логи (например, "30 days", "3 months").
# Реализуется отдельной задачей очистки внутри бота.
# По умолчанию: "3 months" (из AppSettings)
# SDB_CORE_LOG_RETENTION_PERIOD_STRUCTURED="1 month"

# Версия ядра SDB (если нужно переопределить для тестов, обычно не меняется здесь).
# По умолчанию: "0.1.0" (из AppSettings)
# SDB_CORE_SDB_VERSION="0.1.1-beta"


# --- Настройки "Магазина" Модулей ---
# URL к JSON-индексу официальных модулей SDB.
# По умолчанию: "https://raw.githubusercontent.com/soverxos/SwiftDevBot-Modules/main/modules_index.json" (из AppSettings)
# SDB_MODULE_REPO_INDEX_URL="https://my.private.repo/modules_index.json"


# --- Настройки Интернационализации (i18n) Ядра ---
# Путь к директории с файлами переводов (относительно корня проекта).
# По умолчанию: "locales" (из AppSettings)
# SDB_I18N_LOCALES_DIR="translations"

# Имя домена для gettext (обычно имя .po/.mo файлов).
# По умолчанию: "bot" (из AppSettings)
# SDB_I18N_DOMAIN="sdb_core"

# Язык по умолчанию.
# По умолчанию: "en" (из AppSettings)
# SDB_I18N_DEFAULT_LOCALE="en"

# Список доступных языков через запятую (например, "en,ua,de").
# По умолчанию: "en,ua" (из AppSettings)
# SDB_I18N_AVAILABLE_LOCALES="en,ua,ru"


======================================================================

------------------------------ FILE: alembic.ini ------------------------------
# alembic.ini
# Конфигурационный файл Alembic для проекта SwiftDevBot (SDB)

[alembic]
# Путь к директории со скриптами миграций (env.py, versions/)
# Указывается относительно расположения этого .ini файла.
script_location = alembic_migrations

# Шаблон для именования файлов ревизий.
# %%(rev)s - ID ревизии, %%(slug)s - часть сообщения (message) ревизии.
file_template = %%(rev)s_%%(slug)s

# URL для подключения к базе данных.
# ВАЖНО: Этот URL будет переопределен в alembic_migrations/env.py
# на основе актуальных настроек из core.app_settings.settings.
# Поэтому здесь можно оставить его пустым или закомментированным.
# sqlalchemy.url = driver://user:pass@localhost/dbname
#sqlalchemy.url = sqlite:///./default_sdb_for_alembic_init.db # Пример, если нужен для `alembic init`

# --- Опции, важные для динамической работы с SDB ---

# Говорит Alembic всегда выполнять env.py для определения информации о ревизии.
# Это необходимо, так как env.py динамически загружает модели и URL БД.
revision_environment = true

# Управляет созданием .pyc файлов без исходных .py для миграций.
# Обычно False. Установка в True может быть полезна в специфических случаях,
# но для SDB не должна быть критичной. Оставляем как ты настроил.
sourceless = true 

# Кодировка для файлов миграций, если отличается от системной.
# По умолчанию UTF-8 обычно подходит.
# file_encoding = utf-8

# --- Остальные опции можно оставить по умолчанию ---

# Разделитель для version_locations (не используется нами, так как script_location один)
# version_path_separator = os # (комментируем, так как не нужно)

# Если используется несколько баз данных (не наш случай для одного Alembic окружения)
# [alembic:engine_myapp]
# sqlalchemy.url = ...

# Настройки логирования для Alembic.
# Могут конфликтовать или дополнять настройки Loguru, если SDB их использует.
# Обычно стандартных настроек здесь достаточно для вывода информации от Alembic.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
# Уровень логирования для SQLAlchemy (например, WARN, INFO, DEBUG для SQL-запросов)
level = WARN 
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
# Уровень логирования для самого Alembic
level = INFO 
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


======================================================================

------------------------------ FILE: .env ------------------------------
# .env.example
# Пример файла переменных окружения для SwiftDevBot.
# Скопируйте этот файл в .env и заполните своими значениями.
# Строки, начинающиеся с #, являются комментариями.

# --- Telegram Bot ---
# ОБЯЗАТЕЛЬНО: Токен вашего Telegram бота. Получить у @BotFather.
BOT_TOKEN=7811011757:AAEKl00KS3g7_gSqiuSAPZZF0IkS5v1P50w
SDB_TELEGRAM_POLLING_TIMEOUT=30


# --- База Данных ---
# Тип используемой базы данных: "sqlite", "postgresql", "mysql"
# По умолчанию: "sqlite" (из AppSettings)

 SDB_DB_TYPE="sqlite"
 SDB_DB_SQLITE_PATH="Database_files/sdb_clean_test.db" 

# Для SQLite:
# SDB_DB_TYPE="sqlite"
# Относительный путь к файлу SQLite (от корня проекта или project_data_path).
# По умолчанию: "Database_files/swiftdevbot.db" (из AppSettings)
# SDB_DB_SQLITE_PATH="Database_files/sdb_prod.db"

# Для PostgreSQL:
# SDB_DB_TYPE="postgresql"
# DSN (Data Source Name) для подключения к PostgreSQL.
# Формат: postgresql+<драйвер>://<user>:<password>@<host>:<port>/<dbname>
# Драйверы: asyncpg, psycopg (для psycopg SQLAlchemy 2.0 может требовать psycopg[binary])
# Пример: SDB_DB_PG_DSN="postgresql+psycopg://sdb_user:sdb_pass@localhost:5432/sdb_pg_database"
# SDB_DB_PG_DSN="postgresql+psycopg://soverx:Sova3568@192.168.31.3:2345/sdb_database"

# Для MySQL:
# SDB_DB_TYPE="mysql"
# DSN для подключения к MySQL.
# Формат: mysql+<драйвер>://<user>:<password>@<host>:<port>/<dbname>
# Драйверы: aiomysql, asyncmy
# Пример: SDB_DB_MYSQL_DSN="mysql+aiomysql://sdb_user:sdb_pass@localhost:3306/sdb_mysql_database?charset=utf8mb4"
# SDB_DB_MYSQL_DSN="mysql+aiomysql://root:Sova3568@192.168.31.3:33066/sdb_mysql_db?charset=utf8mb4"

# Логировать SQL-запросы SQLAlchemy (уровень DEBUG). true/false
# По умолчанию: false (из AppSettings)
# SDB_DB_ECHO_SQL="false"


# --- Кэш ---
# Тип кэша: "memory", "redis"
# По умолчанию: "memory" (из AppSettings)
SDB_CACHE_TYPE="memory"

# Для Redis:
# SDB_CACHE_TYPE="redis"
# URL для подключения к Redis.
# Формат: redis://[:<password>@]<host>:<port>/<db_number>
# По умолчанию: "redis://localhost:6379/0" (из AppSettings)
# SDB_CACHE_REDIS_URL="redis://192.168.31.3:6379/0"


# --- Настройки Ядра (Core) ---
# Путь к директории данных проекта (логи, БД, конфиги модулей).
# По умолчанию: "./project_data" (относительно корня проекта, из AppSettings)
# SDB_CORE_PROJECT_DATA_PATH="./my_sdb_data"

# Список Telegram ID супер-администраторов через запятую.
# Пример: SDB_CORE_SUPER_ADMINS="12345678,98765432"
# По умолчанию: пустой список (из AppSettings)
SDB_CORE_SUPER_ADMINS="7847397229"

# Путь к файлу со списком активных модулей (относительно директории данных проекта).
# По умолчанию: "Config/enabled_modules.json" (из AppSettings)
# SDB_CORE_ENABLED_MODULES_CONFIG_PATH="Config/active_plugins.json"

# --- Настройки Логирования Ядра ---
# Уровень логирования: TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL
# По умолчанию: "INFO" (из AppSettings)
SDB_CORE_LOG_LEVEL="INFO"

# Писать ли логи в файл. true/false
# По умолчанию: true (из AppSettings)
# SDB_CORE_LOG_TO_FILE="true"

# Шаблон пути к лог-файлам (относительно директории данных проекта).
# {time} - специальный заполнитель для Loguru.
# По умолчанию: "Logs/sdb_{time:YYYY-MM-DD_HH-mm-ss_SSSSSS}.log" (из AppSettings)
# SDB_CORE_LOG_FILE_PATH_TEMPLATE="MyLogs/bot_{time}.log"

# Ротация логов (размер или интервал). Примеры: "500 MB", "1 week", "00:00" (ежедневно в полночь).
# По умолчанию: "10 MB" (из AppSettings)
# SDB_CORE_LOG_ROTATION="100 MB"

# Хранение логов (как долго или сколько файлов). Примеры: "1 month", "10 files".
# По умолчанию: "7 days" (из AppSettings)
# SDB_CORE_LOG_RETENTION="30 days"

# Версия ядра SDB (если нужно переопределить для тестов, обычно не меняется здесь).
# По умолчанию: "0.1.0" (из AppSettings)
# SDB_CORE_SDB_VERSION="0.1.1-beta"


# --- Настройки "Магазина" Модулей ---
# URL к JSON-индексу официальных модулей SDB.
# По умолчанию: "https://raw.githubusercontent.com/soverxos/SwiftDevBot-Modules/main/modules_index.json" (из AppSettings)
# SDB_MODULE_REPO_INDEX_URL="https://my.private.repo/modules_index.json"


# --- Настройки Интернационализации (i18n) Ядра ---
# Путь к директории с файлами переводов (относительно корня проекта).
# По умолчанию: "locales" (из AppSettings)
# SDB_I18N_LOCALES_DIR="translations"

# Имя домена для gettext (обычно имя .po/.mo файлов).
# По умолчанию: "bot" (из AppSettings)
# SDB_I18N_DOMAIN="sdb_core"

# Язык по умолчанию.
# По умолчанию: "en" (из AppSettings)
# SDB_I18N_DEFAULT_LOCALE="en"

# Список доступных языков через запятую (например, "en,uk,de").
# По умолчанию: "en,uk" (из AppSettings)
# SDB_I18N_AVAILABLE_LOCALES="en,uk,ru"


======================================================================

------------------------------ FILE: run_bot.py ------------------------------
# run_bot.py
# Этот файл является основной точкой входа для запуска Telegram-бота SwiftDevBot.

import asyncio
import sys
from pathlib import Path
import os

# --- Настройка sys.path для корректного импорта 'core' и других пакетов проекта ---
current_script_dir = Path(__file__).resolve().parent
if str(current_script_dir) not in sys.path:
    sys.path.insert(0, str(current_script_dir))

# Импортируем основную функцию запуска бота из ядра
try:
    from core.bot_entrypoint import run_sdb_bot 
except ImportError as e:
    print(f"КРИТИЧЕСКАЯ ОШИБКА: Не удалось импортировать компоненты из 'core.bot_entrypoint'.", file=sys.stderr)
    print(f"Ошибка: {e}", file=sys.stderr)
    print("Убедитесь, что структура проекта верна и все зависимости ядра установлены.", file=sys.stderr)
    print(f"Текущий sys.path: {sys.path}", file=sys.stderr)
    sys.exit(2)

if __name__ == "__main__":
    exit_code: int = 1 

    try:
        exit_code = asyncio.run(run_sdb_bot())
        
        if exit_code == 0:
            if os.environ.get("SDB_SHOULD_WRITE_PID", "false").lower() != "true":
                print("Бот SwiftDevBot штатно завершил свою работу.")
        else:
            if os.environ.get("SDB_SHOULD_WRITE_PID", "false").lower() != "true":
                print(f"Бот SwiftDevBot завершил работу с кодом ошибки: {exit_code}", file=sys.stderr)

    except KeyboardInterrupt:
        if os.environ.get("SDB_SHOULD_WRITE_PID", "false").lower() != "true":
            print("\n🤖 Бот остановлен пользователем (Ctrl+C). Выход...", file=sys.stderr)
        exit_code = 0 
    except ImportError as e_runtime_import:
        print(f"ОШИБКА ИМПОРТА ВО ВРЕМЯ ВЫПОЛНЕНИЯ: {e_runtime_import}", file=sys.stderr)
        print("Возможно, отсутствуют зависимости для одного из активных модулей.", file=sys.stderr)
        exit_code = 3
    except Exception as e_global:
        print(f"КРИТИЧЕСКАЯ НЕОБРАБОТАННАЯ ОШИБКА НА ВЕРХНЕМ УРОВНЕ: {type(e_global).__name__}: {e_global}", file=sys.stderr)
        print("Смотрите логи для получения полного трейсбека ошибки.", file=sys.stderr)
        exit_code = 1
    finally:
        pass

    sys.exit(exit_code)


======================================================================

------------------------------ FILE: sdb ------------------------------
#!/usr/bin/env python3

import asyncio
import sys
import os
import subprocess
import time
from pathlib import Path

current_script_path = Path(__file__).resolve()
project_root = current_script_path.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

try:
    import typer
    from rich.console import Console
    from rich.panel import Panel
    from loguru import logger as global_logger 
except ImportError as e:
    print(f"Критическая ошибка: Необходимые библиотеки (Typer, Rich, Loguru) не установлены. {e}", file=sys.stderr)
    print(f"Пожалуйста, установите зависимости из requirements.txt или requirements-dev.txt:", file=sys.stderr)
    print(f"  pip install -r requirements.txt", file=sys.stderr)
    sys.exit(1)

sdb_console = Console()

try:
    from cli_commands.setup_cmd import config_app
    from cli_commands.db_cmd import db_app
    from cli_commands.module_cmd import module_app
    from cli_commands.user_cmd import user_app
    from cli_commands.backup_cmd import backup_app
    from cli_commands.system_cmd import system_app
    from cli_commands.control_cmd import control_app, PID_FILENAME 
    from cli_commands.bot_cmd import bot_app 
    from core.bot_entrypoint import run_sdb_bot 
except ImportError as e:
    sdb_console.print(f"[bold red]Критическая ошибка:[/]\n Не удалось импортировать компоненты SDB CLI или ядра: {e}")
    sdb_console.print("Убедитесь, что все файлы ядра и CLI на месте и PYTHONPATH настроен корректно.")
    sdb_console.print_exception(show_locals=False)
    sys.exit(1)
except Exception as e:
    sdb_console.print(f"[bold red]Критическая ошибка при инициализации SDB CLI (во время импортов):[/]\n {e}")
    sdb_console.print_exception(show_locals=True)
    sys.exit(1)

cli_main_app = typer.Typer(
    name="sdb",
    help="🚀 [bold cyan]SwiftDevBot CLI[/] - Утилита для управления вашим SDB!",
    rich_markup_mode="rich",
    add_completion=False,
    no_args_is_help=True,
    context_settings={"help_option_names": ["-h", "--help"]}
)

cli_main_app.add_typer(config_app, name="config", help="🔧 Управление конфигурацией SDB (init, info).")
cli_main_app.add_typer(db_app, name="db", help="🗄️ Управление базой данных и миграциями Alembic.")
cli_main_app.add_typer(module_app, name="module", help="🧩 Управление модулями SDB (плагинами).")
cli_main_app.add_typer(user_app, name="user", help="👤 Управление пользователями и ролями (RBAC).")
cli_main_app.add_typer(backup_app, name="backup", help="💾 Создание и управление бэкапами данных и БД.")
cli_main_app.add_typer(system_app, name="system", help="🛠️ Системные команды (обновление ядра, откат и др.).")
cli_main_app.add_typer(control_app, name="control", help="🚦 Управление процессом бота (stop, status, restart).") 
cli_main_app.add_typer(bot_app, name="bot", help="🤖 Управление Telegram-ботом SDB (команды, статус).") 

@cli_main_app.command(name="start", help="🚀 Запустить основной процесс Telegram бота SDB.")
def start_bot_command(
    debug: bool = typer.Option(
        False, "--debug", "-d", 
        help="Запустить бота в режиме отладки (увеличит уровень логирования до DEBUG)."
    ),
    background: bool = typer.Option(
        False, "--background", "-b",
        help="Запустить бота в фоновом режиме (демонизировать)."
    )
):
    from core.app_settings import settings 
    pid_file_path = settings.core.project_data_path / PID_FILENAME

    if pid_file_path.exists():
        try:
            with open(pid_file_path, "r") as f:
                pid = int(f.read().strip())
            if sys.platform != "win32":
                os.kill(pid, 0) 
                sdb_console.print(f"[yellow]SDB бот уже запущен (PID: {pid}). Используйте './sdb control stop' для остановки.[/yellow]")
                raise typer.Exit(code=1)
            else: 
                 sdb_console.print(f"[yellow]PID-файл существует (PID: {pid}). Если бот запущен, остановите его перед новым запуском.[/yellow]")
        except (OSError, ValueError): 
            sdb_console.print(f"[yellow]Обнаружен устаревший PID-файл ({pid_file_path}). Удаление...[/yellow]")
            pid_file_path.unlink(missing_ok=True)
        except Exception as e_pid_check:
             sdb_console.print(f"[red]Ошибка при проверке PID-файла: {e_pid_check}[/red]")

    if debug:
        sdb_console.print(Panel(f"[bold yellow]Запрос на запуск бота в режиме DEBUG.[/]", 
                                title="SDB Start (Debug Mode Requested)", expand=False, border_style="yellow"))
        os.environ["SDB_LAUNCH_DEBUG_MODE"] = "true"
        # SDB_CLI_DEBUG_MODE_FOR_LOGGING теперь не нужен здесь, 
        # т.к. app_settings.py уже настроил консольный лог.
        # Если очень нужно перенастроить консольный лог *именно для этого вызова sdb start*,
        # то можно сделать reload app_settings с установкой SDB_CLI_DEBUG_MODE_FOR_LOGGING.
        # Но проще положиться на то, что SDB_LAUNCH_DEBUG_MODE будет использован в bot_entrypoint.
    else:
        os.environ["SDB_LAUNCH_DEBUG_MODE"] = "false"
        # os.environ["SDB_CLI_DEBUG_MODE_FOR_LOGGING"] = "false" # Уже не так важно здесь

    if background:
        if sys.platform == "win32":
            sdb_console.print("[bold red]Фоновый режим (-b/--background) пока не поддерживается на Windows через эту команду.[/bold red]")
            sdb_console.print("Пожалуйста, запустите бота без флага -b или используйте другие средства для демонизации.")
            raise typer.Exit(code=1)

        sdb_console.print(Panel("[bold blue]Запуск SDB бота в фоновом режиме...[/]", 
                                title="SDB Start (Background)", expand=False, border_style="blue"))
        
        run_bot_script_path = project_root / "run_bot.py"
        
        env_for_subprocess = os.environ.copy()
        env_for_subprocess["SDB_SHOULD_WRITE_PID"] = "true"
        
        try:
            process = subprocess.Popen(
                [sys.executable, str(run_bot_script_path)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True, 
                env=env_for_subprocess
            )
            sdb_console.print(f"Процесс бота запущен в фоне (системный PID: {process.pid}).")
            sdb_console.print(f"Ожидание создания PID-файла '{PID_FILENAME}' (до 10 секунд)...")
            
            pid_file_created_successfully = False
            for i in range(10): 
                time.sleep(1)
                if pid_file_path.exists():
                    try:
                        actual_pid_from_file_str = pid_file_path.read_text().strip()
                        if actual_pid_from_file_str.isdigit():
                            actual_pid_from_file = int(actual_pid_from_file_str)
                            sdb_console.print(f"[green]PID-файл {pid_file_path} создан. PID бота: {actual_pid_from_file}.[/green]")
                            sdb_console.print("Для просмотра статуса используйте: [cyan]./sdb control status[/cyan]")
                            sdb_console.print("Для остановки используйте: [cyan]./sdb control stop[/cyan]")
                            pid_file_created_successfully = True
                            break
                        else:
                            sdb_console.print(f"[yellow]PID-файл создан, но содержит некорректное значение: '{actual_pid_from_file_str}'. Попытка {i+1}/10.[/yellow]")
                    except ValueError:
                        sdb_console.print(f"[yellow]PID-файл создан, но содержит нечисловое значение. Попытка {i+1}/10.[/yellow]")
                    except Exception as e_read_pid:
                         sdb_console.print(f"[yellow]Ошибка чтения PID из файла ({e_read_pid}). Попытка {i+1}/10.[/yellow]")

            if not pid_file_created_successfully:
                sdb_console.print(f"[yellow]Предупреждение: PID-файл не был корректно создан/прочитан в течение 10 секунд.[/yellow]")
                sdb_console.print(f"  Возможно, бот не запустился корректно в фоне или не смог записать PID. Проверьте логи бота.")
                sdb_console.print(f"  Системный PID запущенного процесса: {process.pid}. Попробуйте проверить его статус вручную.")

        except Exception as e_popen:
            sdb_console.print(f"[bold red]Ошибка при запуске бота в фоновом режиме: {e_popen}[/bold red]")
            sdb_console.print_exception(show_locals=True)
            raise typer.Exit(code=1)
    else:
        if not debug: 
             sdb_console.print(Panel("[bold green]Запуск Telegram бота SDB...[/]", 
                                title="SDB Start", expand=False, border_style="green"))
        try:
            os.environ["SDB_SHOULD_WRITE_PID"] = "false" 
            
            bot_coroutine = run_sdb_bot() 
            exit_code = asyncio.run(bot_coroutine)
            
            if exit_code != 0:
                sdb_console.print(f"[bold red]Бот завершил работу с кодом ошибки: {exit_code}[/]")
                sys.exit(exit_code)
            else:
                if not (os.environ.get("SDB_SHOULD_WRITE_PID", "false").lower() == "true"):
                    sdb_console.print("[bold green]Бот успешно завершил свою работу (штатное завершение).[/]")
                
        except KeyboardInterrupt:
            sdb_console.print("\n[bold orange_red1]🤖 Бот остановлен пользователем (Ctrl+C). Выход.[/]")
            sys.exit(0) 
        except Exception as e:
            sdb_console.print(Panel(f"[bold red]КРИТИЧЕСКАЯ ОШИБКА при запуске или работе бота:[/]\n{e}", 
                                    title="SDB Runtime Error", border_style="red", expand=True))
            global_logger.opt(exception=e).critical("Необработанное исключение в sdb.py start_bot_command")
            sdb_console.print_exception(show_locals=True) 
            sys.exit(1)

if __name__ == "__main__":
    try:
        if sys.platform != "win32":
            if not os.access(__file__, os.X_OK):
                current_mode = os.stat(__file__).st_mode
                os.chmod(__file__, current_mode | 0o111) 
                sdb_console.print("[dim green]Установлены права на исполнение для sdb.py[/dim]")
    except Exception as e_chmod:
        sdb_console.print(f"[dim yellow]Предупреждение: не удалось установить права на исполнение для sdb.py: {e_chmod}[/dim]")

    cli_main_app()


======================================================================

------------------------------ FILE: babel.cfg ------------------------------
# Mapping from filename patterns to extractor callables
[python: **.py]
[python: core/**.py]
[python: modules/**.py]
[python: cli_commands/**.py]

# Extraction method mapping
[extractors]
# Для Python файлов используем стандартный экстрактор Babel
python = babel.messages.extract:extract_python


======================================================================

------------------------------ FILE: modules/.gitkeep ------------------------------



======================================================================

------------------------------ FILE: modules/Create_modules.md ------------------------------

**Структура папки универсального модуля (например, `modules/my_universal_module/`)**

```
my_universal_module/
├── __init__.py                   # ОБЯЗАТЕЛЬНО: Точка входа модуля
├── manifest.yaml                 # ОБЯЗАТЕЛЬНО: Описание модуля
├── handlers.py                   # РЕКОМЕНДУЕТСЯ: Основные хэндлеры сообщений и колбэков
├── keyboards.py                  # РЕКОМЕНДУЕТСЯ: Функции для генерации клавиатур
├── callback_data.py              # РЕКОМЕНДУЕТСЯ: Фабрики CallbackData для модуля
├── permissions.py                # РЕКОМЕНДУЕТСЯ: Определение констант разрешений модуля
├── states.py                     # ОПЦИОНАЛЬНО: Состояния FSM, если модуль их использует
├── models.py                     # ОПЦИОНАЛЬНО: Модели SQLAlchemy, если модуль работает с БД
├── module_settings_defaults.yaml # ОПЦИОНАЛЬНО: Файл с настройками по умолчанию для модуля
└── services.py                   # ОПЦИОНАЛЬНО: Вспомогательные сервисы или логика модуля
```

---

**Содержимое файлов с комментариями:**

**1. `modules/my_universal_module/manifest.yaml` (ОБЯЗАТЕЛЬНО)**

```yaml
# ОБЯЗАТЕЛЬНО: Уникальное имя модуля в snake_case. Должно совпадать с именем папки.
name: "my_universal_module" 

# ОБЯЗАТЕЛЬНО: Отображаемое имя модуля для пользователя.
display_name: "Мой Универсальный Модуль"

# ОБЯЗАТЕЛЬНО: Версия модуля в формате SemVer (например, "0.1.0", "1.0.0-beta.1").
version: "0.1.0"

# РЕКОМЕНДУЕТСЯ: Краткое описание функциональности модуля.
description: "Этот модуль демонстрирует универсальную структуру и лучшие практики для создания модулей SwiftDevBot."

# РЕКОМЕНДУЕТСЯ: Имя или ник автора/команды разработчиков.
author: "Ваше Имя / Название Команды"

# ОПЦИОНАЛЬНО: Список Python-зависимостей, которые требуются этому модулю.
# Эти зависимости должны быть установлены в окружение отдельно.
# Формат: как в requirements.txt (например, "requests>=2.20.0", "beautifulsoup4")
python_requirements:
  # - "some_package==1.2.3"

# ОПЦИОНАЛЬНО: Список других модулей SDB, от которых зависит этот модуль.
# Ядро проверит их наличие и активность перед загрузкой этого модуля.
# Указываются 'name' модулей-зависимостей.
sdb_module_dependencies:
  # - "another_sdb_module_name"

# ОПЦИОНАЛЬНО: Список полных путей к классам моделей SQLAlchemy, определенных в этом модуле.
# Используется CLI командой 'sdb module clean-tables' для удаления таблиц модуля.
# Пример: "modules.my_universal_module.models.MyTableModel"
model_definitions:
  # - "modules.my_universal_module.models.MyFirstTable"
  # - "modules.my_universal_module.models.MySecondTable"

# ОПЦИОНАЛЬНО: Список команд, которые предоставляет модуль.
# Будут добавлены в общее меню команд бота (если admin_only=false).
commands:
  - command: "universal_hello" # Сама команда (без "/")
    description: "Сказать привет от универсального модуля" # Описание для /help
    icon: "👋" # Опциональная иконка
    category: "Универсальные" # Опциональная категория
    admin_only: false # Требует ли команда прав администратора (для показа в /help)
                      # Фактическая проверка прав должна быть в хэндлере!
  # - command: "universal_admin_action"
  #   description: "Выполнить административное действие модуля"
  #   icon: "🛠️"
  #   category: "Универсальные (Админ)"
  #   admin_only: true # Не будет показана в /help обычным пользователям

# ОПЦИОНАЛЬНО: Разрешения, которые объявляет и использует этот модуль.
# Имена должны быть в формате "module_name.permission_key".
# Описание используется в админ-панели при назначении прав ролям.
permissions:
  - name: "my_universal_module.access" # Базовое право на доступ/использование модуля
    description: "Доступ к основным функциям Универсального Модуля."
  - name: "my_universal_module.view_sensitive_data"
    description: "Просмотр чувствительных данных в Универсальном Модуле."
  - name: "my_universal_module.perform_special_action"
    description: "Выполнение специального действия в Универсальном Модуле."
  # - name: "my_universal_module.admin_manage"
  #   description: "[АДМИН] Полное управление Универсальным Модулем."

# ОПЦИОНАЛЬНО: Настройки модуля, которые администратор может изменять.
# Ключ словаря (здесь 'greeting_message') будет именем настройки.
settings:
  greeting_message:
    type: "string" # Типы: string, int, float, bool, choice, multichoice, text
    label: "Приветственное сообщение" # Отображаемое имя настройки
    description: "Сообщение, которое модуль будет использовать для приветствия." # Описание
    default: "Привет от Универсального Модуля!" # Значение по умолчанию
    required: false # Обязательна ли настройка (если true, default должен быть указан)
  # enable_feature_x:
  #   type: "bool"
  #   label: "Включить Функцию X"
  #   default: true
  # item_limit:
  #   type: "int"
  #   label: "Лимит элементов"
  #   default: 10
  #   min_value: 1
  #   max_value: 100
  # theme_color:
  #   type: "choice"
  #   label: "Цветовая схема"
  #   default: "blue"
  #   options:
  #     - value: "blue"
  #       display_name: "Синяя"
  #     - value: "green"
  #       display_name: "Зеленая"
  #     - "red" # Можно и так, если display_name не нужен
  # admin_email:
  #   type: "string"
  #   label: "Email администратора модуля"
  #   regex_validator: "^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$" # Пример валидации email
  #   required: true # default здесь не нужен, если required и ожидается ввод от админа

# ОПЦИОНАЛЬНО: Информация о фоновых задачах, если модуль их использует.
# 'entry_point' - полный путь к асинхронной функции задачи.
# 'schedule' - cron-подобная строка для планировщика (если используется).
background_tasks:
  # daily_cleanup:
  #   entry_point: "modules.my_universal_module.tasks.run_daily_cleanup"
  #   schedule: "0 3 * * *" # Каждый день в 3:00
  #   description: "Ежедневная очистка временных данных модуля."

# ОПЦИОНАЛЬНО: Дополнительная метаинформация о модуле.
metadata:
  homepage: "https://example.com/my_universal_module" # URL домашней страницы модуля
  license: "MIT" # Лицензия модуля
  tags: ["universal", "template", "example"] # Теги для поиска/категоризации
  min_sdb_core_version: "0.1.0" # Минимальная совместимая версия ядра SDB
  assign_default_access_to_user_role: true # Если true, право '{module_name}.access' будет автоматически назначено роли 'User'
                                           # Имя базового права доступа должно быть '{module_name}.access_user_features' или '{module_name}.access'
                                           # В нашем случае это "my_universal_module.access" (см. permissions выше)
```

---

**2. `modules/my_universal_module/__init__.py` (ОБЯЗАТЕЛЬНО)**

```python
# modules/my_universal_module/__init__.py

from aiogram import Dispatcher, Bot, Router
from loguru import logger

# РЕКОМЕНДУЕТСЯ: Импортировать основной роутер модуля
from .handlers import universal_module_router 
# ОБЯЗАТЕЛЬНО: Импортировать имя модуля (должно совпадать с 'name' в манифесте)
from .permissions import MODULE_NAME 
# РЕКОМЕНДУЕТСЯ: Импортировать базовое разрешение для UI точки входа
from .permissions import PERM_ACCESS_USER_FEATURES 

from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from core.module_loader import ModuleInfo # Для получения информации о модуле

async def setup_module(dp: Dispatcher, bot: Bot, services: 'BotServicesProvider'):
    """
    ОБЯЗАТЕЛЬНАЯ функция. Вызывается ядром для инициализации модуля.
    Здесь происходит регистрация хэндлеров, UI-точек входа, подписка на события и т.д.
    """
    
    # Получение информации о модуле (включая манифест и загруженные настройки)
    module_info: Optional['ModuleInfo'] = services.modules.get_module_info(MODULE_NAME)
    
    if not module_info or not module_info.manifest:
        logger.error(f"Не удалось получить информацию или манифест для модуля '{MODULE_NAME}'. "
                     "Модуль не будет настроен.")
        return

    # Логирование начала настройки модуля
    display_name = module_info.manifest.display_name
    version = module_info.manifest.version
    logger.info(f"[{MODULE_NAME}] Настройка модуля: '{display_name}' v{version}...")

    # 1. РЕКОМЕНДУЕТСЯ: Регистрация хэндлеров (роутеров) этого модуля
    if isinstance(universal_module_router, Router):
        # ОПЦИОНАЛЬНО: Можно добавить фильтр на весь роутер модуля,
        # например, чтобы он работал только в личных чатах или для пользователей с определенным правом.
        # universal_module_router.message.filter(F.chat.type == "private") 
        dp.include_router(universal_module_router)
        logger.info(f"[{MODULE_NAME}] Роутер '{universal_module_router.name}' успешно зарегистрирован.")
    else:
        logger.error(f"[{MODULE_NAME}] Ошибка: 'universal_module_router' не является экземпляром aiogram.Router.")

    # 2. РЕКОМЕНДУЕТСЯ: Регистрация UI-точки входа модуля в UIRegistry ядра
    # Это позволит модулю появиться в общем списке "Модули" в UI ядра.
    # Callback_data для входа в модуль будет ModuleMenuEntry(module_name=MODULE_NAME).pack()
    # Хэндлер для этого callback_data должен быть определен в handlers.py.
    
    # Импортируем фабрику ModuleMenuEntry из ядра
    from core.ui.callback_data_factories import ModuleMenuEntry 

    entry_cb_data = ModuleMenuEntry(module_name=MODULE_NAME).pack()
    
    # ОПЦИОНАЛЬНО: Иконка и описание для кнопки в меню "Модули"
    icon = "✨" # Дефолтная иконка
    # Попробуем взять иконку из первой команды в манифесте, если она есть
    if module_info.manifest.commands:
        primary_command_name = MODULE_NAME # Или другое имя команды, которую считаем главной
        main_command_manifest = next((cmd for cmd in module_info.manifest.commands if cmd.command == primary_command_name), None)
        if not main_command_manifest and module_info.manifest.commands: # Если нет команды с именем модуля, берем первую
             main_command_manifest = module_info.manifest.commands[0]
        
        if main_command_manifest and main_command_manifest.icon:
            icon = main_command_manifest.icon

    description_for_ui = module_info.manifest.description or f"Функционал модуля {display_name}"

    services.ui_registry.register_module_entry(
        module_name=MODULE_NAME, 
        display_name=display_name,
        entry_callback_data=entry_cb_data, 
        icon=icon,
        description=description_for_ui,
        order=100, # Порядок в общем списке модулей (меньше - выше)
        # ОБЯЗАТЕЛЬНО, если хотите, чтобы доступ к кнопке модуля в общем меню "Модули"
        # проверялся автоматически ядром:
        required_permission_to_view=PERM_ACCESS_USER_FEATURES 
    )
    logger.info(f"[{MODULE_NAME}] UI-точка входа для модуля '{display_name}' зарегистрирована в UIRegistry.")

    # 3. ОПЦИОНАЛЬНО: Инициализация специфичных для модуля сервисов или задач
    # if hasattr(self, 'my_module_service'): # Если есть свой сервис
    #     await self.my_module_service.initialize(services_provider=services)
    #     logger.info(f"[{MODULE_NAME}] Внутренний сервис MyModuleService инициализирован.")

    # 4. ОПЦИОНАЛЬНО: Подписка на события ядра или других модулей
    # async def handle_user_registered_event(user_id: int, source_module: str):
    #     logger.info(f"[{MODULE_NAME}] Получено событие 'sdb:user:registered'. Пользователь: {user_id} из {source_module}")
    # services.events.subscribe("sdb:user:registered", handle_user_registered_event)
    # logger.info(f"[{MODULE_NAME}] Подписан на событие 'sdb:user:registered'.")

    # 5. ОПЦИОНАЛЬНО: Публикация собственных событий модуля, если это нужно для других модулей
    # await services.events.publish(f"{MODULE_NAME}:initialized", module_version=version)

    logger.success(f"✅ Модуль '{MODULE_NAME}' ({display_name} v{version}) успешно настроен.")
```

---

**3. `modules/my_universal_module/permissions.py` (РЕКОМЕНДУЕТСЯ)**

```python
# modules/my_universal_module/permissions.py

# ОБЯЗАТЕЛЬНО: Уникальное имя модуля, должно совпадать с именем папки и 'name' в manifest.yaml
MODULE_NAME = "my_universal_module"

# РЕКОМЕНДУЕТСЯ: Базовое разрешение для доступа к пользовательскому интерфейсу и основным функциям модуля.
# Его можно автоматически назначать роли 'User', если в manifest.yaml metadata.assign_default_access_to_user_role: true
PERM_ACCESS_USER_FEATURES = f"{MODULE_NAME}.access_user_features"

# ОПЦИОНАЛЬНО: Примеры других разрешений, специфичных для этого модуля
PERM_VIEW_SENSITIVE_DATA = f"{MODULE_NAME}.view_sensitive_data"
PERM_PERFORM_SPECIAL_ACTION = f"{MODULE_NAME}.perform_special_action"

# ОПЦИОНАЛЬНО: Разрешения для административных функций внутри модуля
PERM_ADMIN_MANAGE_SETTINGS = f"{MODULE_NAME}.admin_manage_settings"
PERM_ADMIN_VIEW_ALL_DATA = f"{MODULE_NAME}.admin_view_all_data"

# Для удобства можно собрать все разрешения модуля в один список или словарь,
# но это необязательно, так как они будут зарегистрированы из манифеста.
ALL_MODULE_PERMISSIONS = {
    PERM_ACCESS_USER_FEATURES: "Доступ к основным функциям Универсального Модуля.",
    PERM_VIEW_SENSITIVE_DATA: "Просмотр чувствительных данных в Универсальном Модуле.",
    PERM_PERFORM_SPECIAL_ACTION: "Выполнение специального действия в Универсальном Модуле.",
    PERM_ADMIN_MANAGE_SETTINGS: "[АДМИН] Управление настройками Универсального Модуля.",
    PERM_ADMIN_VIEW_ALL_DATA: "[АДМИН] Просмотр всех данных Универсального Модуля.",
}
# Этот словарь ALL_MODULE_PERMISSIONS здесь просто для примера,
# описания для регистрации берутся из manifest.yaml.
```

---

**4. `modules/my_universal_module/handlers.py` (РЕКОМЕНДУЕТСЯ)**

```python
# modules/my_universal_module/handlers.py

from aiogram import Router, types, F, Bot
from aiogram.filters import Command
from aiogram.utils.markdown import hbold
from loguru import logger

# РЕКОМЕНДУЕТСЯ: Импорт фабрик колбэков этого модуля и фабрик ядра для навигации
from .callback_data import MyUniversalModuleAction
from core.ui.callback_data_factories import ModuleMenuEntry 

# РЕКОМЕНДУЕТСЯ: Импорт функций для генерации клавиатур этого модуля
from .keyboards import get_universal_module_main_menu_keyboard

# РЕКОМЕНДУЕТСЯ: Импорт констант разрешений этого модуля
from .permissions import (
    MODULE_NAME,
    PERM_ACCESS_USER_FEATURES,
    PERM_VIEW_SENSITIVE_DATA,
    PERM_PERFORM_SPECIAL_ACTION
)

# ОПЦИОНАЛЬНО: Импорт FSM состояний, если используются
# from .states import MyFSMState

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession # Для проверок прав

# ОБЯЗАТЕЛЬНО: Создание роутера для этого модуля
universal_module_router = Router(name=f"sdb_{MODULE_NAME}_handlers")

# --- Вспомогательная функция для проверки прав (может быть общей для модуля) ---
async def check_module_permission(
    user_id: int, 
    permission_name: str, 
    services: 'BotServicesProvider', 
    session: 'AsyncSession' # Передаем сессию явно
) -> bool:
    has_perm = await services.rbac.user_has_permission(session, user_id, permission_name)
    if not has_perm:
        logger.warning(f"[{MODULE_NAME}] Пользователь {user_id} попытался выполнить действие, требующее права "
                       f"'{permission_name}', но не имеет его.")
    return has_perm

# --- Обработчик команды входа в модуль (пример) ---
@universal_module_router.message(Command(MODULE_NAME)) # Команда совпадает с именем модуля
async def cmd_universal_module_entry(message: types.Message, services_provider: 'BotServicesProvider'):
    user_id = message.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} вызвал команду /{MODULE_NAME}.")

    async with services_provider.db.get_session() as session:
        if not await check_module_permission(user_id, PERM_ACCESS_USER_FEATURES, services_provider, session):
            await message.answer("У вас нет доступа к этому модулю.")
            return
    
    module_info = services_provider.modules.get_module_info(MODULE_NAME)
    display_name = module_info.manifest.display_name if module_info and module_info.manifest else MODULE_NAME

    text = f"🌟 Добро пожаловать в {hbold(display_name)}!"
    async with services_provider.db.get_session() as session: # Новая сессия для клавиатуры
        keyboard = await get_universal_module_main_menu_keyboard(services_provider, user_id, session)
    await message.answer(text, reply_markup=keyboard)

# --- Обработчик входа в меню модуля через общий список модулей ---
@universal_module_router.callback_query(ModuleMenuEntry.filter(F.module_name == MODULE_NAME))
async def cq_universal_module_main_menu(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider'
):
    user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} вошел в меню модуля '{MODULE_NAME}'.")
    
    async with services_provider.db.get_session() as session:
        if not await check_module_permission(user_id, PERM_ACCESS_USER_FEATURES, services_provider, session):
            await query.answer("У вас нет доступа к этому меню.", show_alert=True)
            return

        module_info = services_provider.modules.get_module_info(MODULE_NAME)
        display_name = module_info.manifest.display_name if module_info and module_info.manifest else MODULE_NAME
        text = f"Меню модуля {hbold(display_name)}. Выберите действие:"
        keyboard = await get_universal_module_main_menu_keyboard(services_provider, user_id, session)

        if query.message:
            try:
                await query.message.edit_text(text, reply_markup=keyboard)
            except TelegramBadRequest as e:
                if "message is not modified" not in str(e).lower():
                    logger.warning(f"[{MODULE_NAME}] Ошибка edit_text в меню модуля: {e}")
            await query.answer()

# --- Обработчики действий модуля ---
@universal_module_router.callback_query(MyUniversalModuleAction.filter(F.action == "view_data"))
async def cq_view_module_data(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    async with services_provider.db.get_session() as session:
        # Для этого действия не требуется спец. разрешение, только PERM_ACCESS_USER_FEATURES (уже проверено при входе в меню)
        # Здесь будет логика получения данных, специфичных для пользователя
        # Например, если модуль хранит персональные данные пользователя
        
        # Доступ к настройкам модуля, если они нужны
        module_settings = services_provider.modules.get_module_settings(MODULE_NAME)
        greeting = module_settings.get("greeting_message", "Привет!") if module_settings else "Привет!"

        await query.answer(f"{greeting} Вот ваши данные из модуля!", show_alert=False)
        logger.info(f"[{MODULE_NAME}] Пользователь {user_id} просмотрел свои данные.")

@universal_module_router.callback_query(MyUniversalModuleAction.filter(F.action == "view_sensitive"))
async def cq_view_sensitive_data(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    async with services_provider.db.get_session() as session:
        if not await check_module_permission(user_id, PERM_VIEW_SENSITIVE_DATA, services_provider, session):
            await query.answer("У вас нет прав для просмотра этой информации.", show_alert=True)
            return
    await query.answer("Это очень чувствительные данные!", show_alert=True)
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} просмотрел чувствительные данные.")


@universal_module_router.callback_query(MyUniversalModuleAction.filter(F.action == "special_action"))
async def cq_do_special_action(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    async with services_provider.db.get_session() as session:
        if not await check_module_permission(user_id, PERM_PERFORM_SPECIAL_ACTION, services_provider, session):
            await query.answer("Это специальное действие доступно не всем.", show_alert=True)
            return
    await query.answer("✨ Специальное действие выполнено! ✨", show_alert=True)
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} выполнил специальное действие.")

# ОПЦИОНАЛЬНО: Хэндлеры для административных действий модуля (если есть)
# @universal_module_router.message(Command("universal_admin_manage"))
# async def cmd_admin_manage_module(message: types.Message, services_provider: 'BotServicesProvider'):
#     user_id = message.from_user.id
#     async with services_provider.db.get_session() as session:
#         if not await check_module_permission(user_id, PERM_ADMIN_MANAGE_MODULE, services_provider, session):
#             await message.answer("У вас нет прав для администрирования этого модуля.")
#             return
#     await message.answer("Добро пожаловать в админ-панель Универсального Модуля!")
```

---

**5. `modules/my_universal_module/keyboards.py` (РЕКОМЕНДУЕТСЯ)**

```python
# modules/my_universal_module/keyboards.py

from aiogram.types import InlineKeyboardMarkup
from aiogram.utils.keyboard import InlineKeyboardBuilder

# РЕКОМЕНДУЕТСЯ: Импорт фабрик для этого модуля
from .callback_data import MyUniversalModuleAction
# РЕКОМЕНДУЕТСЯ: Импорт фабрик ядра для стандартной навигации (назад и т.д.)
from core.ui.callback_data_factories import CoreMenuNavigate 
# РЕКОМЕНДУЕТСЯ: Импорт констант разрешений для динамического отображения кнопок
from .permissions import PERM_VIEW_SENSITIVE_DATA, PERM_PERFORM_SPECIAL_ACTION

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession


async def get_universal_module_main_menu_keyboard(
    services: 'BotServicesProvider', 
    user_id: int, 
    session: 'AsyncSession' # Нужна для проверки прав
) -> InlineKeyboardMarkup:
    """
    Генерирует клавиатуру для главного меню универсального модуля.
    Кнопки отображаются в зависимости от прав пользователя.
    """
    builder = InlineKeyboardBuilder()
    
    # Кнопка 1: Простое действие, доступное с базовым разрешением (PERM_ACCESS_USER_FEATURES)
    # Право PERM_ACCESS_USER_FEATURES уже должно быть проверено перед показом этого меню.
    builder.button(
        text="📊 Посмотреть мои данные",
        callback_data=MyUniversalModuleAction(action="view_data").pack()
    )

    # Кнопка 2: Доступна только при наличии разрешения PERM_VIEW_SENSITIVE_DATA
    if await services.rbac.user_has_permission(session, user_id, PERM_VIEW_SENSITIVE_DATA):
        builder.button(
            text="🔒 Просмотреть чувствительные данные",
            callback_data=MyUniversalModuleAction(action="view_sensitive").pack()
        )

    # Кнопка 3: Доступна только при наличии разрешения PERM_PERFORM_SPECIAL_ACTION
    if await services.rbac.user_has_permission(session, user_id, PERM_PERFORM_SPECIAL_ACTION):
        builder.button(
            text="🚀 Выполнить специальное действие",
            callback_data=MyUniversalModuleAction(action="special_action").pack()
        )

    # Если ни одна из "основных" кнопок не была добавлена (из-за отсутствия прав),
    # можно добавить информационную кнопку.
    if not builder.export(): # Проверяем, были ли добавлены какие-либо кнопки выше
         builder.button(text="🤷‍♂️ Нет доступных действий", callback_data="my_universal_module:no_actions_dummy")


    # Кнопка "Назад" в общее меню модулей SDB
    builder.button(
        text="⬅️ Назад к списку модулей",
        callback_data=CoreMenuNavigate(target_menu="modules_list", page=1).pack() 
    )
    
    builder.adjust(1) # Каждая кнопка на новой строке
    return builder.as_markup()
```

---

**6. `modules/my_universal_module/callback_data.py` (РЕКОМЕНДУЕТСЯ)**

```python
# modules/my_universal_module/callback_data.py

from aiogram.filters.callback_data import CallbackData
from typing import Optional

# РЕКОМЕНДУЕТСЯ: Уникальный префикс для колбэков этого модуля
MY_UNIVERSAL_MODULE_PREFIX = "muniv" 

class MyUniversalModuleAction(CallbackData, prefix=MY_UNIVERSAL_MODULE_PREFIX):
    # ОБЯЗАТЕЛЬНО: Поле 'action' для определения типа действия
    action: str 
    
    # ОПЦИОНАЛЬНО: Дополнительные поля, если нужны для передачи данных
    item_id: Optional[int] = None
    page: Optional[int] = None
    # ... другие поля
```

---

**7. `modules/my_universal_module/states.py` (ОПЦИОНАЛЬНО)**

```python
# modules/my_universal_module/states.py

from aiogram.fsm.state import State, StatesGroup

# ОПЦИОНАЛЬНО: Определите здесь состояния FSM, если ваш модуль их использует.
class MyUniversalModuleFSM(StatesGroup):
    first_step = State()
    second_step = State()
    # ... другие состояния
```

---

**8. `modules/my_universal_module/models.py` (ОПЦИОНАЛЬНО)**
(Мы уже добавили `UserNote` в предыдущем примере, здесь может быть больше моделей)

```python
# modules/my_universal_module/models.py
from sqlalchemy import String, Integer, ForeignKey, Text, Boolean 
from sqlalchemy.orm import Mapped, mapped_column, relationship
from core.database.base import SDBBaseModel 
from typing import Optional

# Пример модели для этого модуля
class MyFirstTable(SDBBaseModel): 
    __tablename__ = "mod_universal_my_first_table" # РЕКОМЕНДУЕТСЯ: Префикс mod_{module_name}_
    
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    value: Mapped[Optional[int]] = mapped_column(Integer)

    def __repr__(self):
        return f"<MyFirstTable(id={self.id}, name='{self.name}')>"

# Не забудьте добавить "modules.my_universal_module.models.MyFirstTable"
# в 'model_definitions' в manifest.yaml, если хотите, чтобы CLI мог ее чистить.
```

---

**9. `modules/my_universal_module/module_settings_defaults.yaml` (ОПЦИОНАЛЬНО)**

Файл с настройками по умолчанию для модуля. Имена ключей должны совпадать с теми, что описаны в секции `settings` файла `manifest.yaml`.

```yaml
# modules/my_universal_module/module_settings_defaults.yaml

greeting_message: "Универсальный модуль приветствует вас (из файла дефолтов)!"
enable_feature_x: false
item_limit: 5
# theme_color: "green" # Если это значение есть в options в манифесте
# admin_email: # Обязательные поля без default в манифесте должны быть заданы в пользовательском конфиге
```

---

**10. `modules/my_universal_module/services.py` (ОПЦИОНАЛЬНО)**

Здесь можно разместить вспомогательные классы, функции, бизнес-логику, специфичную для этого модуля.

```python
# modules/my_universal_module/services.py

from loguru import logger
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession

class UniversalModuleHelperService:
    def __init__(self, services: 'BotServicesProvider', module_name: str):
        self.services = services
        self.module_name = module_name
        self.logger = logger.bind(service=f"{module_name}_helper")
        self.logger.info("UniversalModuleHelperService инициализирован.")

    async def get_user_specific_data(self, user_id: int, session: 'AsyncSession') -> str:
        # Пример: получение данных из БД или настроек
        module_settings = self.services.modules.get_module_settings(self.module_name)
        max_items = module_settings.get("item_limit", 10) if module_settings else 10
        
        # Здесь может быть запрос к БД для получения данных пользователя
        # user_items = await session.execute(select(SomeModel).where(SomeModel.user_id == user_id).limit(max_items))
        # items = list(user_items.scalars().all())
        
        self.logger.debug(f"Получение данных для пользователя {user_id} с лимитом {max_items}.")
        return f"Ваши данные (до {max_items} шт.) из Универсального Модуля!"

    async def perform_complex_action(self, user_id: int, data: dict) -> bool:
        self.logger.info(f"Пользователь {user_id} выполняет сложное действие с данными: {data}")
        # ... логика сложного действия ...
        # await self.services.events.publish(f"{self.module_name}:complex_action_done", user_id=user_id, result="success")
        return True

# Использовать этот сервис можно было бы в __init__.py модуля:
# from .services import UniversalModuleHelperService
# ...
# async def setup_module(dp, bot, services):
#     module_name = "my_universal_module"
#     helper = UniversalModuleHelperService(services, module_name)
#     services.ext.register_module_service(module_name, "helper", helper) 
#     # services.ext - это гипотетический способ регистрации кастомных сервисов модуля
#     # Либо просто передавать helper в хэндлеры через data['module_helper'] = helper в __init__
# ...
```

---

**Важные моменты для разработчика модуля:**

*   **Именование**: Старайся использовать `snake_case` для имен файлов, переменных, функций. Имя модуля (`name` в манифесте) должно совпадать с именем папки.
*   **Разрешения**:
    *   Всегда объявляй разрешения, которые использует твой модуль, в `manifest.yaml` в секции `permissions`. Имя разрешения должно начинаться с `имя_модуля.`.
    *   В хэндлерах всегда проверяй права пользователя перед выполнением привилегированных действий или показом чувствительных данных.
    *   Для UI-точки входа модуля (кнопки в общем меню "Модули") указывай `required_permission_to_view` в `services.ui_registry.register_module_entry`, чтобы ядро автоматически скрывало кнопку от тех, у кого нет этого базового права.
    *   Если модуль должен быть доступен всем пользователям по умолчанию, установи `metadata.assign_default_access_to_user_role: true` в манифесте и убедись, что у тебя есть разрешение вида `имя_модуля.access_user_features`.
*   **Настройки**:
    *   Описывай все настройки модуля в секции `settings` манифеста.
    *   Предоставляй файл `module_settings_defaults.yaml` с разумными значениями по умолчанию.
    *   В коде модуля получай настройки через `services.modules.get_module_settings(MODULE_NAME)`.
*   **База данных**:
    *   Все модели SQLAlchemy должны наследоваться от `core.database.base.SDBBaseModel`.
    *   Имена таблиц должны иметь префикс, например, `mod_{module_name}_`.
    *   Указывай полные пути к классам моделей в `model_definitions` манифеста.
    *   Для работы с БД в хэндлерах используй `async with services_provider.db.get_session() as session:`.
*   **Логирование**: Используй `logger` из `loguru`, который доступен через `services.logger` или импортируется напрямую. Рекомендуется биндить логгер к имени модуля: `logger.bind(module=MODULE_NAME)`.
*   **Изоляция**: Старайся минимизировать прямые импорты из других модулей (кроме ядра). Если нужна межмодульная коммуникация, используй систему событий (`services.events`).
*   **Асинхронность**: Все хэндлеры и функции, работающие с I/O (БД, сеть, файловая система), должны быть асинхронными (`async def`).
*   **Чистота кода**: Следуй PEP 8, добавляй комментарии, пиши понятный код.

Этот шаблон должен покрыть большинство сценариев. Если у тебя есть конкретные пожелания или идеи по его дополнению, дай знать!


======================================================================

------------------------------ FILE: modules/__init__.py ------------------------------



======================================================================

------------------------------ FILE: project_data/.gitignore ------------------------------
*
!.gitignore
!*/
!.gitkeep



======================================================================

------------------------------ FILE: cli_commands/db_cmd.py ------------------------------
# cli_commands/db_cmd.py

import typer
from rich.console import Console
from rich.panel import Panel
import subprocess
import sys
import os
from pathlib import Path
import asyncio

console = Console()

db_app = typer.Typer(
    name="db",
    help="🗄️ Управление базой данных и миграциями Alembic.",
    rich_markup_mode="rich",
    no_args_is_help=True  # <--- ДОБАВЛЕНО
)

# Корень проекта определяется относительно текущего файла (__file__)
# cli_commands/db_cmd.py -> cli_commands/ -> PROJECT_ROOT
PROJECT_ROOT_FROM_DB_CMD = Path(__file__).resolve().parent.parent
ALEMBIC_INI_PATH_STR = str(PROJECT_ROOT_FROM_DB_CMD / "alembic.ini")


def _run_alembic_command(args: list[str], suppress_success_output: bool = False) -> bool:
    try:
        alembic_ini_actual_path = Path(ALEMBIC_INI_PATH_STR)
        if not alembic_ini_actual_path.is_file():
            console.print(f"[bold red]Ошибка: Файл конфигурации Alembic '{ALEMBIC_INI_PATH_STR}' не найден.[/]")
            console.print(f"  Убедитесь, что команда выполняется из корня проекта или путь к alembic.ini корректен.")
            return False

        command = ["alembic", "-c", ALEMBIC_INI_PATH_STR] + args
        
        env = os.environ.copy()
        # Добавляем корень проекта в PYTHONPATH, чтобы Alembic мог найти core и modules
        # Это важно, так как env.py импортирует компоненты SDB
        existing_python_path = env.get("PYTHONPATH", "")
        project_root_str = str(PROJECT_ROOT_FROM_DB_CMD)
        
        if existing_python_path:
            # Убедимся, что project_root_str не дублируется, если он уже есть
            path_parts = existing_python_path.split(os.pathsep)
            if project_root_str not in path_parts:
                env["PYTHONPATH"] = f"{project_root_str}{os.pathsep}{existing_python_path}"
            else: # Уже есть, не добавляем
                env["PYTHONPATH"] = existing_python_path
        else:
            env["PYTHONPATH"] = project_root_str
        
        # Дополнительно убедимся, что sys.path передан в окружение, если это необходимо
        # (Обычно PYTHONPATH достаточно)
        # current_sys_path_str = os.pathsep.join(s.strip() for s in sys.path if s.strip())
        # env["PYTHONPATH"] = f"{current_sys_path_str}{os.pathsep}{env.get('PYTHONPATH', '')}"


        process = subprocess.run(
            command,
            capture_output=True,
            text=True,
            encoding='utf-8',
            env=env,
            cwd=str(PROJECT_ROOT_FROM_DB_CMD) # Запускаем из корня проекта
        )

        if process.stdout and not (process.returncode == 0 and suppress_success_output):
            console.print(process.stdout.strip())

        if process.stderr:
            is_actual_error_in_stderr = "error" in process.stderr.lower() or \
                                        "fail" in process.stderr.lower() or \
                                        "traceback" in process.stderr.lower() or \
                                        "critical" in process.stderr.lower()

            if process.returncode != 0 or is_actual_error_in_stderr:
                console.print(f"[bold red]Alembic STDERR:[/]\n{process.stderr.strip()}")
            elif not (process.returncode == 0 and suppress_success_output):
                 console.print(f"[dim yellow]Alembic STDERR (info/warnings):[/]\n{process.stderr.strip()}")

        if process.returncode != 0:
            console.print(f"[bold red]Команда Alembic завершилась с ошибкой (код: {process.returncode}). Проверьте вывод выше.[/]")
            return False
        return True

    except FileNotFoundError:
        console.print(f"[bold red]Ошибка: Команда 'alembic' не найдена.[/]")
        console.print("Убедитесь, что Alembic установлен в вашем виртуальном окружении и доступен в системном PATH.")
        console.print(f"Попробуйте: [cyan]pip install alembic[/]")
        return False
    except Exception as e:
        console.print(f"[bold red]Неожиданная ошибка при выполнении команды Alembic: {e}[/]")
        return False

@db_app.command(name="upgrade", help="Применить миграции Alembic (по умолчанию до 'head', т.е. последней).")
def db_upgrade_cmd(
    revision: str = typer.Argument("head", help="ID ревизии для обновления (например, 'head', 'base', specific_id, '+1', '-2').")
):
    console.print(f"Запуск применения миграций Alembic до ревизии: [cyan]{revision}[/]...")
    if not _run_alembic_command(["upgrade", revision]):
        raise typer.Exit(code=1)
    console.print(f"[bold green]Команда 'db upgrade {revision}' успешно выполнена.[/]")

@db_app.command(name="downgrade", help="Откатить миграции Alembic.")
def db_downgrade_cmd(
    revision: str = typer.Argument(
        "1", 
        help="ID ревизии для отката (например, 'base', specific_id) или количество ревизий для отката (например, '1' для отката последней, '2' для двух последних). Для отката на одну ревизию можно также указать '-1'."
    )
):
    target_revision = revision
    if revision.isdigit():
        target_revision = f"-{revision}" 
        description_log = f"на {revision} ревизию(и) назад (до {target_revision})"
    else:
        description_log = f"до ревизии '{revision}'"

    console.print(f"Запуск отката миграций Alembic {description_log}...")
    if typer.confirm(f"Вы [bold red]УВЕРЕНЫ[/], что хотите откатить миграции {description_log}? Это может привести к потере данных.", abort=True):
        if not _run_alembic_command(["downgrade", revision]):
            raise typer.Exit(code=1)
        console.print(f"[bold green]Команда 'db downgrade {revision}' успешно выполнена.[/]")

@db_app.command(name="revision", help="Создать новый файл миграции Alembic.")
def db_revision_cmd(
    message: str = typer.Option(..., "-m", "--message", help="Краткое описание изменений для новой ревизии (обязательно)."),
    autogenerate: bool = typer.Option(True, "--autogenerate/--no-autogenerate",
                                     help="Попытаться автоматически определить изменения в моделях (рекомендуется).")
):
    args = ["revision"]
    if autogenerate:
        args.append("--autogenerate")
    args.extend(["-m", message])

    console.print(f"Создание новой ревизии Alembic с сообщением: '[cyan]{message}[/]' (autogenerate: {autogenerate})...")
    if not _run_alembic_command(args):
        raise typer.Exit(code=1)
    console.print(f"[bold green]Команда 'db revision' успешно выполнена. Новый файл миграции должен быть создан в 'alembic_migrations/versions/'.[/]")

@db_app.command(name="status", help="Показать текущий статус миграций и историю.")
def db_status_cmd(
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Показать более детальный вывод.")
):
    console.print(Panel("[bold blue]Текущий статус миграций Alembic (команда 'current')[/]", expand=False, border_style="blue"))
    current_args = ["current"]
    if verbose:
        current_args.append("--verbose")

    success_current = _run_alembic_command(current_args, suppress_success_output=verbose)
    if not success_current:
        console.print("[yellow]Не удалось получить текущий статус Alembic (Alembic current).[/yellow]")

    console.print(Panel("[bold blue]История миграций Alembic (команда 'history')[/]", expand=False, border_style="blue", style="blue"))
    history_args = ["history"]
    if not _run_alembic_command(history_args):
        console.print("[yellow]Не удалось получить историю миграций Alembic (Alembic history).[/yellow]")

@db_app.command(name="init-core", help="[ОПАСНО] Создать таблицы ядра и дефолтные роли напрямую, минуя Alembic.")
def db_init_core_cmd():
    console.print(Panel("[bold yellow]Инициализация таблиц ядра SDB и стандартных ролей напрямую[/]", expand=False, border_style="yellow"))
    console.print("[bold red]ПРЕДУПРЕЖДЕНИЕ:[/bold red] Эта команда создаст таблицы ядра и роли напрямую, игнорируя Alembic.")
    if typer.confirm("Вы уверены, что хотите создать таблицы ядра и стандартные роли напрямую?", abort=True):
        try:
            from core.app_settings import settings
            from core.database.manager import DBManager
            from core.rbac.service import RBACService

            async def _init_core_data_task_runner():
                nonlocal settings
                console.print(f"Используется БД: {settings.db.type} (URL строится на основе настроек).")
                db_m = DBManager(db_settings=settings.db, app_settings=settings)
                try:
                    await db_m.initialize()

                    console.print("Вызов DBManager.create_all_core_tables() для создания таблиц ядра...")
                    await db_m.create_all_core_tables()
                    console.print("[bold green]Таблицы ядра успешно созданы (или уже существовали).[/]")

                    console.print("Попытка создания стандартных ролей...")
                    rbac_s = RBACService(db_manager=db_m) # Передаем DBManager
                    async with db_m.get_session() as session:
                        roles_created_count = await rbac_s.ensure_default_roles_exist(session)
                        if roles_created_count > 0:
                            console.print(f"[bold green]Успешно создано и закоммичено {roles_created_count} стандартных ролей.[/bold green]")
                        else:
                            console.print("[dim]Стандартные роли уже существовали или не были созданы (проверьте логи RBACService).[/dim]")
                except Exception as e_task:
                    console.print(f"[bold red]Ошибка во время выполнения задачи инициализации: {e_task}[/]")
                    raise
                finally:
                    await db_m.dispose()

            asyncio.run(_init_core_data_task_runner())
            console.print("\n[bold green]Команда 'db init-core' успешно завершена.[/]")
            console.print("[yellow]ВАЖНО: Если вы использовали Alembic ранее, состояние миграций может быть некорректным.[/]")
            console.print("  [yellow]Возможно, потребуется выполнить 'sdb db stamp head', чтобы синхронизировать Alembic с текущей схемой БД.[/]")
            console.print("  [yellow]Делайте это, только если вы уверены, что текущая схема БД является целевой 'головой'.[/]")

        except ImportError as e_imp:
             console.print(f"[bold red]Ошибка импорта: Не удалось загрузить компоненты ядра для 'db init-core': {e_imp}[/]")
             raise typer.Exit(code=1)
        except Exception as e:
            console.print(f"[bold red]Ошибка при выполнении 'db init-core': {e}[/]")
            raise typer.Exit(code=1)

@db_app.command(name="stamp", help="Установить текущую ревизию Alembic в БД, не применяя миграции.")
def db_stamp_cmd(
    revision: str = typer.Argument(..., help="ID ревизии для установки (например, 'head', 'base', specific_id)."),
    purge: bool = typer.Option(False, "--purge", help="Очистить таблицу версий Alembic перед установкой новой ревизии (используйте с осторожностью!).")
):
    console.print(f"Установка ревизии Alembic: [cyan]{revision}[/]" + ("[bold yellow] с очисткой таблицы версий[/]" if purge else ""))
    if purge:
        if not typer.confirm(f"[bold red]ВНИМАНИЕ: Опция --purge УДАЛИТ ВСЕ ЗАПИСИ из таблицы версий Alembic перед установкой ревизии '{revision}'. Это может привести к потере истории миграций в БД. Продолжить?", abort=True):
            return
    
    args = ["stamp"]
    if purge:
        args.append("--purge")
    args.append(revision)
    
    if not _run_alembic_command(args):
        raise typer.Exit(code=1)
    console.print(f"[bold green]Команда 'db stamp {revision}{' --purge' if purge else ''}' успешно выполнена.[/]")


======================================================================

------------------------------ FILE: cli_commands/bot_cmd.py ------------------------------
import typer
import asyncio
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from loguru import logger
from aiogram import Bot
from aiogram.types import BotCommand
from pathlib import Path
from core.services_provider import BotServicesProvider
from .cli_utils import get_sdb_services_for_cli
from core.module_loader import ModuleLoader

console = Console()
bot_app = typer.Typer(
    name="bot",
    help="🤖 Управление настройками Telegram-бота.",
    rich_markup_mode="rich",
    no_args_is_help=True  # <--- ДОБАВЛЕНО
)

@bot_app.command(name="delete-commands", help="Удалить все команды из меню команд Telegram.")
def delete_commands():
    """Удаляет все команды из меню команд Telegram."""
    async def _delete_commands_async():
        settings_obj, _, _ = await get_sdb_services_for_cli(init_db=False, init_rbac=False)
        if not settings_obj:
            console.print("[bold red]Ошибка: Не удалось загрузить настройки бота.[/]")
            logger.error("Не удалось загрузить настройки для команды delete-commands")
            raise typer.Exit(code=1)

        try:
            bot_token = settings_obj.telegram.token
            if not bot_token:
                console.print("[bold red]Ошибка: Токен бота не найден в настройках.[/]")
                logger.error("Токен бота не найден в настройках")
                raise typer.Exit(code=1)

            bot = Bot(token=bot_token)
            await bot.delete_my_commands()
            await bot.session.close()
            console.print(Panel("[bold green]Все команды успешно удалены из меню Telegram![/]", expand=False, border_style="green"))
            logger.success("Все команды удалены из меню Telegram")
        except AttributeError as e:
            console.print(f"[bold red]Ошибка: Неправильная структура настроек CoreAppSettings: {e}[/]")
            logger.error(f"Ошибка структуры настроек CoreAppSettings: {e}")
            raise typer.Exit(code=1)
        except Exception as e:
            console.print(f"[bold red]Ошибка при удалении команд: {e}[/]")
            logger.error(f"Ошибка при удалении команд: {e}")
            raise typer.Exit(code=1)

    try:
        asyncio.run(_delete_commands_async())
    except Exception as e:
        console.print(f"[bold red]Неожиданная ошибка: {e}[/]")
        logger.error(f"Неожиданная ошибка в delete-commands: {e}")
        raise typer.Exit(code=1)

@bot_app.command(name="set-commands", help="Установить команды в меню Telegram из модулей и настроек.")
def set_commands():
    """Устанавливает команды в меню Telegram."""
    async def _set_commands_async():
        settings_obj, _, _ = await get_sdb_services_for_cli(init_db=False, init_rbac=False)
        if not settings_obj:
            console.print("[bold red]Ошибка: Не удалось загрузить настройки бота.[/]")
            logger.error("Не удалось загрузить настройки для команды set-commands")
            raise typer.Exit(code=1)

        try:
            bot_token = settings_obj.telegram.token
            if not bot_token:
                console.print("[bold red]Ошибка: Токен бота не найден в настройках.[/]")
                logger.error("Токен бота не найден в настройках")
                raise typer.Exit(code=1)

            # Инициализируем ModuleLoader
            temp_bsp = BotServicesProvider(settings=settings_obj)
            loader = ModuleLoader(settings=settings_obj, services_provider=temp_bsp)
            loader.scan_all_available_modules()
            if hasattr(loader, '_load_enabled_plugin_names'):
                loader._load_enabled_plugin_names()

            # Собираем команды из модулей
            commands = []
            for module_info in loader.available_modules.values():
                if module_info.manifest and module_info.name in loader.enabled_plugin_names:
                    for cmd in module_info.manifest.commands or []:
                        if cmd.get('command') and cmd.get('description'):
                            commands.append(BotCommand(command=cmd['command'].lstrip('/'), description=cmd['description']))

            # Добавляем команды из core_settings.yaml (если есть)
            core_commands_path = settings_obj.core.project_data_path / 'Config' / 'bot_commands.yaml'
            if core_commands_path.exists():
                import yaml
                with core_commands_path.open('r', encoding='utf-8') as f:
                    core_commands = yaml.safe_load(f) or []
                for cmd in core_commands:
                    if cmd.get('command') and cmd.get('description'):
                        commands.append(BotCommand(command=cmd['command'].lstrip('/'), description=cmd['description']))

            if not commands:
                console.print("[yellow]Не найдено команд для установки.[/]")
                logger.warning("Нет команд для установки в меню Telegram")
                return

            # Устанавливаем команды
            bot = Bot(token=bot_token)
            await bot.set_my_commands(commands)
            await bot.session.close()

            # Выводим таблицу установленных команд
            table = Table(title="[bold cyan]Установленные команды[/]", show_header=True, header_style="bold magenta")
            table.add_column("Команда", style="cyan")
            table.add_column("Описание", style="green")
            for cmd in commands:
                table.add_row(f"/{cmd.command}", cmd.description)
            console.print(table)
            console.print(Panel("[bold green]Команды успешно установлены в меню Telegram![/]", expand=False, border_style="green"))
            logger.success(f"Установлено {len(commands)} команд в меню Telegram")
        except AttributeError as e:
            console.print(f"[bold red]Ошибка: Неправильная структура настроек CoreAppSettings: {e}[/]")
            logger.error(f"Ошибка структуры настроек CoreAppSettings: {e}")
            raise typer.Exit(code=1)
        except Exception as e:
            console.print(f"[bold red]Ошибка при установке команд: {e}[/]")
            logger.error(f"Ошибка при установке команд: {e}")
            raise typer.Exit(code=1)

    try:
        asyncio.run(_set_commands_async())
    except Exception as e:
        console.print(f"[bold red]Неожиданная ошибка: {e}[/]")
        logger.error(f"Неожиданная ошибка в set-commands: {e}")
        raise typer.Exit(code=1)

@bot_app.command(name="status", help="Проверить статус бота.")
def status():
    """Проверяет, доступен ли бот."""
    async def _status_async():
        settings_obj, _, _ = await get_sdb_services_for_cli(init_db=False, init_rbac=False)
        if not settings_obj:
            console.print("[bold red]Ошибка: Не удалось загрузить настройки бота.[/]")
            logger.error("Не удалось загрузить настройки для команды status")
            raise typer.Exit(code=1)

        try:
            bot_token = settings_obj.telegram.token
            if not bot_token:
                console.print("[bold red]Ошибка: Токен бота не найден в настройках.[/]")
                logger.error("Токен бота не найден в настройках")
                raise typer.Exit(code=1)

            bot = Bot(token=bot_token)
            bot_info = await bot.get_me()
            await bot.session.close()
            console.print(Panel(f"[bold green]Бот активен! ID: {bot_info.id}, Имя: @{bot_info.username}[/]", expand=False, border_style="green"))
            logger.success(f"Бот активен: @{bot_info.username}")
        except AttributeError as e:
            console.print(f"[bold red]Ошибка: Неправильная структура настроек CoreAppSettings: {e}[/]")
            logger.error(f"Ошибка структуры настроек CoreAppSettings: {e}")
            raise typer.Exit(code=1)
        except Exception as e:
            console.print(f"[bold red]Ошибка при проверке статуса: {e}[/]")
            logger.error(f"Ошибка при проверке статуса: {e}")
            raise typer.Exit(code=1)

    try:
        asyncio.run(_status_async())
    except Exception as e:
        console.print(f"[bold red]Неожиданная ошибка: {e}[/]")
        logger.error(f"Неожиданная ошибка в status: {e}")
        raise typer.Exit(code=1)

if __name__ == "__main__":
    bot_app()


======================================================================

------------------------------ FILE: cli_commands/system_cmd.py ------------------------------
# cli_commands/system_cmd.py

import typer
from rich.console import Console
from rich.panel import Panel
import shutil
import subprocess
from pathlib import Path
import sys
import tarfile
from datetime import datetime
import os
from typing import Optional, List

# Создаем свою консоль для этого модуля
console = Console()

# Typer-приложение для команд группы 'system'
system_app = typer.Typer(
    name="system", 
    help="🛠️ Системные команды SDB (обновление ядра, откат, информация о системе).",
    rich_markup_mode="rich"
    # no_args_is_help=True  # <-- УБИРАЕМ ЭТОТ ПАРАМЕТР
)

# --- НОВЫЙ БЛОК ---
# Добавляем callback для обработки вызова `sdb system` без подкоманд
@system_app.callback(invoke_without_command=True)
def system_main(ctx: typer.Context):
    """
    Выводит справку, если команда `system` вызвана без подкоманд.
    """
    if ctx.invoked_subcommand is None:
        console.print(ctx.get_help())
        raise typer.Exit()
# --- КОНЕЦ НОВОГО БЛОКА ---


# --- Константы и конфигурация для системных операций ---
# Пути могут быть настроены через AppSettings в будущем
CORE_BACKUP_DIR_NAME_IN_PROJECT_DATA = "core_backups" # Имя папки для бэкапов ядра

# URL официального репозитория SDB (пример, нужно будет заменить на реальный)
SDB_OFFICIAL_REPO_URL = "https://github.com/soverxos/SwiftDevBot.git" 
# Или URL для скачивания релизов, если они будут в ZIP/TAR.GZ


@system_app.command(name="info", help="Показать информацию о текущей системе SDB.")
def system_info_cmd():
    """Отображает информацию о версии SDB, путях и других системных параметрах."""
    console.print(Panel("[bold cyan]Системная информация SwiftDevBot[/]", expand=False, border_style="cyan"))
    try:
        from core.app_settings import settings, PROJECT_ROOT_DIR
        from aiogram import __version__ as aiogram_version
        import platform

        console.print(f"[bold]Версия SwiftDevBot (SDB Core):[/bold] {settings.core.sdb_version}")
        console.print(f"[bold]Корень проекта SDB:[/bold] {PROJECT_ROOT_DIR}")
        console.print(f"[bold]Директория данных проекта:[/bold] {settings.core.project_data_path}")
        console.print(f"[bold]Версия Aiogram:[/bold] {aiogram_version}")
        console.print(f"[bold]Версия Python:[/bold] {sys.version.split()[0]}")
        console.print(f"[bold]Операционная система:[/bold] {platform.system()} {platform.release()} ({platform.machine()})")
        
        # TODO: Добавить информацию о состоянии БД (последняя миграция), активных модулях и т.д.
        # Это может потребовать инициализации DBManager и ModuleLoader.
        
    except ImportError:
        console.print("[bold red]Ошибка: Не удалось импортировать 'core.app_settings'.[/]")
    except Exception as e:
        console.print(f"[bold red]Произошла ошибка при получении системной информации: {e}[/]")


@system_app.command(name="core-update", help="Обновить ядро SDB до последней или указанной версии.")
def core_update_cmd(
    version: Optional[str] = typer.Option(
        None, "--version", "-v", 
        help="Указать конкретную версию/тег/ветку для обновления (например, '1.2.0', 'latest', 'dev'). По умолчанию - последняя стабильная."
    ),
    source_repo: str = typer.Option(
        SDB_OFFICIAL_REPO_URL, "--source", "-s",
        help="URL Git-репозитория или источника для обновления ядра SDB."
    ),
    yes_to_all: bool = typer.Option(False, "--yes", "-y", help="Автоматически отвечать 'да' на все запросы подтверждения (ОПАСНО).")
):
    """
    [bold yellow]ЭКСПЕРИМЕНТАЛЬНАЯ КОМАНДА![/bold yellow]
    Пытается обновить файлы ядра SwiftDevBot из указанного источника.
    Это сложная и потенциально опасная операция.

    Шаги (план):
    1. Проверить наличие Git и доступ к репозиторию.
    2. Определить текущую и целевую версии.
    3. Создать бэкап текущей директории 'core/' и важных файлов.
    4. Скачать/склонировать/переключить ветку на новую версию во временную директорию.
    5. Заменить файлы в текущей директории 'core/'.
    6. Обновить 'requirements.txt', если он изменился, и предложить пользователю `pip install -r`.
    7. Сообщить о необходимости проверить и применить миграции БД (`sdb db upgrade head`).
    8. Предоставить информацию о том, как выполнить откат, если что-то пойдет не так.
    """
    console.print(Panel(f"[bold yellow]Обновление ядра SwiftDevBot[/]", expand=False, border_style="yellow"))
    console.print("[bold red]ВНИМАНИЕ: Это экспериментальная и потенциально опасная операция![/]")
    console.print("Перед обновлением настоятельно рекомендуется создать полный бэкап всего проекта (`sdb backup create --name pre_core_update`).")

    if not yes_to_all:
        if not typer.confirm(f"Вы уверены, что хотите попытаться обновить ядро SDB из '{source_repo}'?", abort=True):
            return
    
    # TODO: Реализовать детальную логику обновления ядра.
    # Это очень сложная задача для надежной автоматизации.
    # - Работа с Git (clone, fetch, checkout, diff)
    # - Замена файлов с сохранением пользовательских изменений (если есть)
    # - Управление зависимостями
    # - Миграции БД ядра
    # - Создание надежного механизма отката

    console.print(f"[yellow]Команда 'system core-update' (версия: {version if version else 'последняя'}, источник: {source_repo}) находится в активной разработке.[/]")
    console.print("[yellow]На данный момент автоматическое обновление ядра не реализовано.[/]")
    console.print("Пожалуйста, следите за обновлениями проекта для получения инструкций по ручному или будущему автоматическому обновлению.")
    
    # Пример создания бэкапа директории core
    try:
        from core.app_settings import settings, PROJECT_ROOT_DIR
        core_dir_path = PROJECT_ROOT_DIR / "core"
        if core_dir_path.is_dir():
            backup_base_dir = settings.core.project_data_path / CORE_BACKUP_DIR_NAME_IN_PROJECT_DATA
            backup_base_dir.mkdir(parents=True, exist_ok=True)
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            core_backup_name = f"core_backup_before_update_{timestamp}"
            core_backup_archive = backup_base_dir / f"{core_backup_name}.tar.gz"

            console.print(f"\nСоздание бэкапа текущей директории 'core/' в '{core_backup_archive}'...")
            with tarfile.open(core_backup_archive, "w:gz") as tar:
                tar.add(str(core_dir_path), arcname="core") # Сохраняем 'core' в корне архива
            console.print(f"[green]Бэкап директории 'core/' успешно создан: {core_backup_archive}[/]")
            console.print(f"[dim]Для отката (в случае проблем) вы можете вручную восстановить папку 'core' из этого архива.[/dim]")
        else:
            console.print(f"[yellow]Директория 'core' не найдена в '{PROJECT_ROOT_DIR}'. Бэкап не создан.[/]")
    except Exception as e_backup_core:
        console.print(f"[red]Ошибка при создании бэкапа директории 'core': {e_backup_core}[/]")


@system_app.command(name="core-rollback", help="[ОПАСНО] Откатить ядро SDB к предыдущему состоянию из бэкапа.")
def core_rollback_cmd(
    backup_name: Optional[str] = typer.Option(
        None, "--from-backup", "-b", 
        help="Имя файла бэкапа ядра (tar.gz) для восстановления (из папки core_backups). Если не указано, попытается найти последний."
    )
):
    """
    [bold red]КРАЙНЕ ОПАСНАЯ КОМАНДА![/bold red]
    Пытается восстановить директорию 'core/' из ранее созданного бэкапа.
    Не откатывает изменения в БД или зависимостях автоматически.
    """
    console.print(Panel(f"[bold red]Откат ядра SwiftDevBot[/]", expand=False, border_style="red"))
    console.print("[bold red]ВНИМАНИЕ: Эта операция перезапишет текущие файлы ядра SDB файлами из бэкапа![/]")
    
    if not typer.confirm(f"Вы уверены, что хотите попытаться откатить ядро SDB?", abort=True):
        return

    # TODO: Реализовать логику отката:
    # 1. Найти нужный файл бэкапа (по имени или последний).
    # 2. Предложить пользователю подтвердить путь к бэкапу.
    # 3. Распаковать архив во временную директорию.
    # 4. Заменить текущую директорию 'core/' файлами из бэкапа (с созданием бэкапа текущего состояния на всякий случай).
    # 5. Сообщить пользователю о необходимости ручного отката миграций БД и зависимостей, если это требуется.

    console.print(f"[yellow]Команда 'system core-rollback' (из бэкапа: {backup_name if backup_name else 'последний'}) находится в разработке.[/]")
    console.print("[yellow]На данный момент автоматический откат ядра не реализован.[/]")
    console.print("Для ручного отката: найдите нужный .tar.gz архив в 'project_data/core_backups/', "
                  "распакуйте его и замените содержимое папки 'core/' вашего проекта.")
    console.print("[bold yellow]Не забудьте также откатить миграции БД (`sdb db downgrade ...`) и Python-зависимости, если это необходимо![/bold yellow]")


======================================================================

------------------------------ FILE: cli_commands/cli_utils.py ------------------------------
# cli_commands/cli_utils.py

from typing import Optional, Any, Tuple
from pathlib import Path
import asyncio
import typer # Для typer.confirm
from rich.console import Console # Можно использовать для вывода, если понадобится

# console_cli_utils = Console() # Если нужен свой экземпляр консоли для утилит

async def get_sdb_services_for_cli(
    init_db: bool = False,
    init_rbac: bool = False,
) -> Tuple[Optional[Any], Optional[Any], Optional[Any]]: # (settings, db_manager, rbac_service)
    """
    Вспомогательная асинхронная функция для получения основных сервисов SDB,
    необходимых для выполнения многих CLI команд.
    Инициализирует DBManager "на лету" и, опционально, RBACService.
    Возвращает кортеж (settings, db_manager, rbac_service).
    DBManager нужно будет закрыть вручную через await db_manager.dispose().
    """
    settings_instance: Optional[Any] = None
    db_manager_instance: Optional[Any] = None
    rbac_service_instance: Optional[Any] = None

    try:
        from core.app_settings import settings # Загружаем глобальные настройки
        settings_instance = settings

        if init_db or init_rbac: # DBManager нужен для RBAC
            from core.database.manager import DBManager
            # Используем app_settings=settings, чтобы DBManager правильно строил пути и т.д.
            db_m = DBManager(db_settings=settings.db, app_settings=settings)
            await db_m.initialize()
            db_manager_instance = db_m

            if init_rbac and db_manager_instance:
                from core.rbac.service import RBACService
                rbac_service_instance = RBACService(db_manager=db_manager_instance) # Передаем DBManager

        return settings_instance, db_manager_instance, rbac_service_instance

    except ImportError as e_imp:
        # Ошибки импорта должны быть обработаны в вызывающем коде, здесь просто перевыбрасываем
        # Console().print(f"[bold red]Ошибка импорта в get_sdb_services_for_cli: {e_imp}[/]")
        raise
    except Exception as e_init:
        # Console().print(f"[bold red]Ошибка инициализации сервисов в get_sdb_services_for_cli: {e_init}[/]")
        if db_manager_instance: # Попытаться закрыть, если что-то создалось до ошибки
            await db_manager_instance.dispose()
        raise


def confirm_action(prompt_message: str, default_choice: bool = False, abort_on_false: bool = True) -> bool:
    """
    Общая функция для запроса подтверждения действия у пользователя через Typer.
    Если abort_on_false=True и пользователь отвечает "нет", вызывает typer.Abort().
    Возвращает True, если пользователь ответил "да".
    """
    confirmed = typer.confirm(prompt_message, default=default_choice, abort=abort_on_false)
    # Если abort_on_false=True и пользователь выбрал "нет", typer.confirm уже вызовет typer.Abort().
    # Если abort_on_false=False и пользователь выбрал "нет", вернется False.
    # Если пользователь выбрал "да", вернется True.
    return confirmed


def format_size(size_bytes: int) -> str:
    """Форматирует размер в байтах в человекочитаемый вид (KB, MB, GB)."""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024**2:
        return f"{size_bytes/1024:.2f} KB"
    elif size_bytes < 1024**3:
        return f"{size_bytes/(1024**2):.2f} MB"
    else:
        return f"{size_bytes/(1024**3):.2f} GB"


======================================================================

------------------------------ FILE: cli_commands/backup_cmd.py ------------------------------
# cli_commands/backup_cmd.py

import typer
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
import shutil
import subprocess
from pathlib import Path
import sys
from datetime import datetime
import tarfile
import os
from typing import Optional, List, Tuple as TypingTuple 
from urllib.parse import urlparse 

console = Console()
backup_app = typer.Typer(
    name="backup", 
    help="💾 Создание, управление и восстановление бэкапов SwiftDevBot.", 
    rich_markup_mode="rich",
    no_args_is_help=True  # <--- ДОБАВЛЕНО
)

DB_BACKUP_DIR_NAME = "database"
DATA_FILES_BACKUP_DIR_NAME = "project_data_files"
DATA_ARCHIVE_EXTENSION = ".tar.gz"
POSTGRES_BACKUP_FILENAME = "sdb_postgres_backup.dump" 
MYSQL_BACKUP_FILENAME = "sdb_mysql_backup.sql"       
USER_CONFIG_DIR_NAME_FOR_BACKUP_DEFAULT = "Config"

def _get_backup_base_dir() -> Optional[Path]:
    try:
        from core.app_settings import settings
        backup_dir = settings.core.project_data_path / "sdb_backups" 
        backup_dir.mkdir(parents=True, exist_ok=True)
        return backup_dir
    except ImportError:
        console.print("[bold red]Ошибка: Не удалось импортировать настройки для определения пути к бэкапам.[/]")
        return None
    except Exception as e:
        console.print(f"[bold red]Ошибка при создании/доступе к директории бэкапов: {e}[/]")
        return None

def _find_system_utility(name: str) -> Optional[str]:
    return shutil.which(name)

def _execute_system_command(command: List[str], env_vars: Optional[dict] = None, input_data: Optional[str] = None, show_stdout_on_success: bool = False) -> bool:
    full_env = os.environ.copy()
    if env_vars:
        full_env.update(env_vars)
    
    try:
        process = subprocess.run(
            command,
            capture_output=True,
            text=True,
            encoding='utf-8',
            env=full_env,
            input=input_data, 
            check=False 
        )
        if process.returncode == 0:
            if show_stdout_on_success and process.stdout:
                 console.print(f"[dim cyan]  --- STDOUT ---[/]\n{process.stdout.strip()}")
            return True
        else:
            console.print(f"[bold red]  ❌ Ошибка выполнения команды (код: {process.returncode}): {' '.join(command)}[/]")
            if process.stdout:
                console.print(f"[yellow]  --- STDOUT ---[/]\n{process.stdout.strip()}")
            if process.stderr:
                console.print(f"[red]  --- STDERR ---[/]\n{process.stderr.strip()}")
            return False
    except FileNotFoundError:
        console.print(f"[bold red]  ❌ Ошибка: Команда '{command[0]}' не найдена. Убедитесь, что утилита установлена и доступна в PATH.[/]")
        return False
    except Exception as e:
        console.print(f"[bold red]  ❌ Неожиданная ошибка при выполнении команды '{command[0]}': {e}[/]")
        return False

@backup_app.command(name="create", help="Создать новый бэкап данных и/или базы данных SDB.")
def create_backup_cmd(
    name: Optional[str] = typer.Option( None, "--name", "-n", help="Пользовательское имя для этого бэкапа (иначе генерируется по дате и времени)."),
    include_db: bool = typer.Option(True, "--db/--no-db", help="Включить ли базу данных в бэкап."),
    include_data_dirs: Optional[List[str]] = typer.Option( None, "--data-dir", "-dd", help=(f"Какие директории из 'project_data/' включить в бэкап (относительно 'project_data/'). По умолчанию: ['{USER_CONFIG_DIR_NAME_FOR_BACKUP_DEFAULT}'] (папка Config). Можно указать несколько через пробел или несколько раз опцию. Пример: -dd Config -dd ModulesData")),
    compress_data: bool = typer.Option(True, "--compress/--no-compress", help="Сжимать ли бэкап данных в архив (.tar.gz).")
):
    from core.app_settings import settings 

    if include_data_dirs is None: 
        include_data_dirs = [USER_CONFIG_DIR_NAME_FOR_BACKUP_DEFAULT]

    backup_base_dir = _get_backup_base_dir()
    if not backup_base_dir: 
        raise typer.Exit(code=1)

    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_name = name if name else f"sdb_backup_{timestamp}"
    
    current_backup_path = backup_base_dir / backup_name
    if current_backup_path.exists():
        console.print(f"[bold red]Ошибка: Директория/файл бэкапа с именем '{backup_name}' уже существует.[/]")
        raise typer.Exit(code=1)
    
    try:
        current_backup_path.mkdir(parents=True)
    except Exception as e_mkdir:
        console.print(f"[bold red]Ошибка создания директории для бэкапа '{current_backup_path}': {e_mkdir}[/]")
        raise typer.Exit(code=1)
        
    console.print(Panel(f"[bold cyan]Создание бэкапа: {backup_name}[/]", expand=False, border_style="cyan", subtitle=f"Расположение: {current_backup_path}"))

    db_backup_successful = False
    data_backup_successful = False

    if include_db:
        console.print("\n[bold blue]1. Бэкап Базы Данных[/]")
        db_settings = settings.db
        db_backup_target_dir = current_backup_path / DB_BACKUP_DIR_NAME
        db_backup_target_dir.mkdir()

        if db_settings.type == "sqlite":
            sqlite_file_path = Path(db_settings.sqlite_path) 
            if sqlite_file_path.exists() and sqlite_file_path.is_file():
                try:
                    backup_db_file = db_backup_target_dir / sqlite_file_path.name
                    shutil.copy2(sqlite_file_path, backup_db_file)
                    console.print(f"[green]  ✅ Бэкап SQLite БД успешно создан: '{backup_db_file}'[/]")
                    db_backup_successful = True
                except Exception as e_sqlite:
                    console.print(f"[bold red]  ❌ Ошибка при копировании файла SQLite БД: {e_sqlite}[/]")
            else:
                console.print(f"[bold red]  ❌ Ошибка: Файл SQLite БД не найден по пути '{sqlite_file_path}'[/]")
        
        elif db_settings.type == "postgresql":
            pg_dump_path = _find_system_utility("pg_dump")
            if not pg_dump_path: console.print("[bold red]  ❌ Утилита 'pg_dump' не найдена. Бэкап PostgreSQL невозможен.[/]")
            elif not db_settings.pg_dsn: console.print("[bold red]  ❌ DSN для PostgreSQL (pg_dsn) не настроен. Бэкап невозможен.[/]")
            else:
                parsed_url = urlparse(str(db_settings.pg_dsn))
                pg_host = parsed_url.hostname if parsed_url.hostname else "localhost"
                pg_port = str(parsed_url.port) if parsed_url.port is not None else "5432"
                pg_user = parsed_url.username if parsed_url.username else ""
                pg_password = parsed_url.password if parsed_url.password else ""
                pg_database = parsed_url.path.lstrip('/') if parsed_url.path else ""
                backup_file = db_backup_target_dir / POSTGRES_BACKUP_FILENAME
                cmd = [ pg_dump_path ]
                if pg_host: cmd.extend(["-h", pg_host])
                if pg_port: cmd.extend(["-p", pg_port])
                if pg_user: cmd.extend(["-U", pg_user])
                if not pg_database: console.print("[bold red]  ❌ Имя базы данных не найдено в DSN PostgreSQL. Бэкап невозможен.[/]")
                else:
                    cmd.extend(["-d", pg_database, "-F", "c", "-f", str(backup_file)])
                    env = {}
                    if pg_password: env["PGPASSWORD"] = pg_password
                    console.print(f"  Выполнение pg_dump для PostgreSQL в '{backup_file}'...")
                    if _execute_system_command(cmd, env_vars=env):
                        console.print(f"[green]  ✅ Бэкап PostgreSQL успешно создан: '{backup_file}'[/]")
                        db_backup_successful = True
                    else: console.print(f"[bold red]  ❌ Ошибка при создании бэкапа PostgreSQL.[/]")
        
        elif db_settings.type == "mysql":
            mysqldump_path = _find_system_utility("mysqldump")
            if not mysqldump_path: console.print("[bold red]  ❌ Утилита 'mysqldump' не найдена. Бэкап MySQL невозможен.[/]")
            elif not db_settings.mysql_dsn: console.print("[bold red]  ❌ DSN для MySQL (mysql_dsn) не настроен. Бэкап невозможен.[/]")
            else:
                parsed_url = urlparse(str(db_settings.mysql_dsn))
                mysql_host = parsed_url.hostname if parsed_url.hostname else "localhost"
                mysql_port = str(parsed_url.port) if parsed_url.port is not None else "3306"
                mysql_user = parsed_url.username if parsed_url.username else ""
                mysql_password = parsed_url.password if parsed_url.password else ""
                mysql_database = parsed_url.path.lstrip('/') if parsed_url.path else ""
                backup_file = db_backup_target_dir / MYSQL_BACKUP_FILENAME
                cmd = [ mysqldump_path ]
                if mysql_host: cmd.extend(["-h", mysql_host])
                if mysql_port: cmd.extend(["-P", mysql_port])
                if mysql_user: cmd.extend(["-u", mysql_user])
                cmd.append("--column-statistics=0") 
                if not mysql_database: console.print("[bold red]  ❌ Имя базы данных не найдено в DSN MySQL. Бэкап невозможен.[/]")
                else:
                    cmd.extend(["--databases", mysql_database]) # Эта опция включает CREATE DATABASE IF NOT EXISTS
                    cmd.append(f"--result-file={backup_file}")
                    env = {}
                    if mysql_password: env["MYSQL_PWD"] = mysql_password
                    console.print(f"  Выполнение mysqldump для MySQL в '{backup_file}'...")
                    if _execute_system_command(cmd, env_vars=env):
                        console.print(f"[green]  ✅ Бэкап MySQL успешно создан: '{backup_file}'[/]")
                        db_backup_successful = True
                    else: console.print(f"[bold red]  ❌ Ошибка при создании бэкапа MySQL.[/]")
        else: console.print(f"[bold red]  ❌ Неподдерживаемый тип БД для бэкапа: {db_settings.type}[/]")
    else: console.print("\n[dim blue]1. Бэкап Базы Данных пропущен (согласно опции).[/dim]")

    if include_data_dirs: 
        console.print(f"\n[bold blue]2. Бэкап Данных Проекта (директории: {', '.join(include_data_dirs)})[/]")
        project_data_root_path = settings.core.project_data_path
        data_to_archive_paths: List[TypingTuple[Path, str]] = []
        for dir_name_rel in include_data_dirs:
            source_dir_abs = (project_data_root_path / dir_name_rel).resolve()
            if source_dir_abs.exists() and source_dir_abs.is_dir(): data_to_archive_paths.append((source_dir_abs, dir_name_rel))
            else: console.print(f"[yellow]  ⚠️ Предупреждение: Директория данных '{source_dir_abs}' не найдена или не является директорией. Пропущена.[/]")
        if data_to_archive_paths:
            data_backup_target_dir = current_backup_path / DATA_FILES_BACKUP_DIR_NAME
            data_backup_target_dir.mkdir(exist_ok=True)
            archive_filename_stem = f"project_data_backup_{timestamp}"
            archive_file_path = data_backup_target_dir / (archive_filename_stem + (DATA_ARCHIVE_EXTENSION if compress_data else ".tar"))
            try:
                mode = "w:gz" if compress_data else "w"
                with tarfile.open(archive_file_path, mode) as tar:
                    for source_path, arcname_prefix in data_to_archive_paths:
                        tar.add(str(source_path), arcname=arcname_prefix) 
                        console.print(f"[green]    Директория '{source_path.relative_to(project_data_root_path.parent)}' добавлена в архив.[/]")
                console.print(f"[green]  ✅ Бэкап данных проекта успешно создан: '{archive_file_path}'[/]")
                data_backup_successful = True
            except Exception as e_tar: console.print(f"[bold red]  ❌ Ошибка при создании архива данных проекта: {e_tar}[/]")
        elif not include_data_dirs: console.print("[yellow]  Не указаны директории для бэкапа данных.[/]")
        else: console.print("[yellow]  Нет валидных директорий данных для бэкапа (все указанные не найдены).[/]")
    else: console.print("\n[dim blue]2. Бэкап Данных Проекта пропущен (директории не указаны).[/dim]")
    
    console.print("\n[bold underline]Итоги создания бэкапа:[/]")
    if include_db:
        if db_backup_successful: console.print("[bold green]  БД: УСПЕШНО[/]")
        else: console.print("[bold red]  БД: ОШИБКА[/]")
    if include_data_dirs: 
        if data_backup_successful: console.print("[bold green]  Данные проекта: УСПЕШНО[/]")
        elif data_to_archive_paths: console.print("[bold red]  Данные проекта: ОШИБКА[/]") 
    if not (include_db or (include_data_dirs and data_to_archive_paths)):
        console.print("[yellow]  Не было выбрано или найдено компонентов для бэкапа.[/]")
        try:
            if current_backup_path.is_dir(): shutil.rmtree(current_backup_path)
            console.print(f"[dim]Пустая/неполная директория бэкапа '{current_backup_path}' удалена.[/dim]")
        except Exception as e_rm: console.print(f"[yellow]Не удалось удалить пустую директорию бэкапа: {e_rm}[/yellow]")
    elif not db_backup_successful and include_db or (include_data_dirs and data_to_archive_paths and not data_backup_successful):
        console.print("[bold red]Создание бэкапа завершилось с ошибками для некоторых компонентов.[/]")
    else: console.print(f"\n[bold green]🎉 Бэкап '{backup_name}' успешно завершен.[/]")

@backup_app.command(name="list", help="Показать список доступных бэкапов SDB.")
def list_backups_cmd():
    backup_base_dir = _get_backup_base_dir()
    if not backup_base_dir: return typer.Exit(code=1)
    backups = [d for d in backup_base_dir.iterdir() if d.is_dir()] 
    if not backups:
        console.print(f"[yellow]Не найдено ни одного бэкапа в директории '{backup_base_dir}'.[/]")
        return
    table = Table(title="[bold cyan]Доступные бэкапы SwiftDevBot[/]", show_header=True, header_style="bold magenta")
    table.add_column("Имя Бэкапа", style="cyan", min_width=25)
    table.add_column("Дата Создания (из имени)", min_width=20)
    table.add_column("Содержит БД?", justify="center")
    table.add_column("Содержит Данные?", justify="center")
    table.add_column("Размер (приблизительно)", justify="right")
    for backup_dir_path in sorted(backups, key=lambda p: p.name, reverse=True):
        backup_name = backup_dir_path.name
        date_from_name = "N/A"
        if backup_name.startswith("sdb_backup_") and len(backup_name.split("_")[-1]) == 15: 
            try:
                ts_str = backup_name.split("_")[-1]
                dt_obj = datetime.strptime(ts_str, '%Y%m%d_%H%M%S')
                date_from_name = dt_obj.strftime('%Y-%m-%d %H:%M:%S')
            except ValueError: pass
        has_db_backup_dir = (backup_dir_path / DB_BACKUP_DIR_NAME).is_dir()
        db_files_exist = any((backup_dir_path / DB_BACKUP_DIR_NAME).iterdir()) if has_db_backup_dir else False
        has_data_backup_dir = (backup_dir_path / DATA_FILES_BACKUP_DIR_NAME).is_dir()
        data_files_exist = any((backup_dir_path / DATA_FILES_BACKUP_DIR_NAME).iterdir()) if has_data_backup_dir else False
        total_size = 0
        try:
            for f_item in backup_dir_path.rglob('*'):
                if f_item.is_file(): total_size += f_item.stat().st_size
            size_str = f"{total_size / (1024*1024):.2f} MB" if total_size > (1024*512) else f"{total_size / 1024:.1f} KB"
        except Exception: size_str = "N/A"
        table.add_row(backup_name, date_from_name, "✅" if db_files_exist else "❌" if has_db_backup_dir else "-", "✅" if data_files_exist else "❌" if has_data_backup_dir else "-", size_str)
    console.print(table)

@backup_app.command(name="restore", help="[ОПАСНО!] Восстановить систему SDB из указанного бэкапа.")
def restore_backup_cmd(
    backup_name: str = typer.Argument(..., help="Имя бэкапа для восстановления (из команды 'sdb backup list')."),
    restore_db: bool = typer.Option(True, "--db/--no-db", help="Восстановить ли базу данных из бэкапа."),
    restore_data_dirs: bool = typer.Option(True, "--data/--no-data", help="Восстановить ли директории данных проекта из бэкапа.")
):
    from core.app_settings import settings 

    console.print(Panel(f"[bold red]ВОССТАНОВЛЕНИЕ ИЗ БЭКАПА: {backup_name}[/]", expand=False, border_style="red"))
    console.print("[bold red]ВНИМАНИЕ: ЭТА ОПЕРАЦИЯ ПЕРЕЗАПИШЕТ ТЕКУЩУЮ БАЗУ ДАННЫХ И/ИЛИ ДАННЫЕ ПРОЕКТА![/]")
    console.print("[bold yellow]Убедитесь, что Telegram-бот SDB ОСТАНОВЛЕН перед началом восстановления.[/]")
    
    if not (restore_db or restore_data_dirs):
        console.print("[yellow]Не выбрано ни одного компонента для восстановления (ни БД, ни данные). Операция отменена.[/yellow]")
        raise typer.Exit()

    base_backup_dir = _get_backup_base_dir()
    if not base_backup_dir: raise typer.Exit(code=1)
    
    target_backup_path = base_backup_dir / backup_name
    if not target_backup_path.is_dir():
        console.print(f"[bold red]Ошибка: Директория бэкапа '{target_backup_path}' не найдена.[/]")
        raise typer.Exit(code=1)

    if not typer.confirm(f"Вы АБСОЛЮТНО уверены, что хотите восстановить систему из бэкапа '{backup_name}'?", abort=True):
        return 
    if not typer.confirm(f"ПОСЛЕДНЕЕ ПРЕДУПРЕЖДЕНИЕ: Это необратимо. Продолжить восстановление?", default=False, abort=True):
        return

    db_restore_successful = False
    data_restore_successful = False
    timestamp_for_files = datetime.now().strftime('%Y%m%d%H%M%S')

    if restore_db:
        console.print("\n[bold blue]1. Восстановление Базы Данных[/]")
        db_settings = settings.db
        backup_db_content_path = target_backup_path / DB_BACKUP_DIR_NAME
        
        if not backup_db_content_path.is_dir() or not any(backup_db_content_path.iterdir()):
            console.print(f"[yellow]  Не найдены файлы бэкапа БД в '{backup_db_content_path}'. Пропуск восстановления БД.[/yellow]")
        else:
            if db_settings.type == "sqlite":
                sqlite_backup_files = list(backup_db_content_path.glob("*.db")) or \
                                      list(backup_db_content_path.glob("*.sqlite")) or \
                                      list(backup_db_content_path.glob("*.sqlite3"))
                if sqlite_backup_files:
                    source_db_file_in_backup = sqlite_backup_files[0]
                    target_current_db_file = Path(db_settings.sqlite_path)
                    console.print(f"  Подготовка к восстановлению SQLite из '{source_db_file_in_backup}' в '{target_current_db_file}'...")
                    if target_current_db_file.exists():
                        current_db_backup_path = target_current_db_file.with_suffix(f"{target_current_db_file.suffix}.before_restore_{timestamp_for_files}")
                        try:
                            shutil.copy2(target_current_db_file, current_db_backup_path)
                            console.print(f"[dim]    Текущий файл БД сохранен в: '{current_db_backup_path}'[/dim]")
                        except Exception as e_backup_current: console.print(f"[yellow]    Не удалось создать бэкап текущего файла БД: {e_backup_current}[/yellow]")
                    try:
                        shutil.copy2(source_db_file_in_backup, target_current_db_file)
                        console.print(f"[green]  ✅ База данных SQLite успешно восстановлена из бэкапа.[/]")
                        db_restore_successful = True
                    except Exception as e_restore_sqlite: console.print(f"[bold red]  ❌ Ошибка при восстановлении SQLite: {e_restore_sqlite}[/]")
                else: console.print(f"[yellow]  Не найден файл бэкапа SQLite (.db, .sqlite, .sqlite3) в '{backup_db_content_path}'.[/yellow]")

            elif db_settings.type == "postgresql":
                pg_restore_path = _find_system_utility("pg_restore")
                backup_file_in_archive = backup_db_content_path / POSTGRES_BACKUP_FILENAME
                if not pg_restore_path: console.print("[bold red]  ❌ Утилита 'pg_restore' не найдена. Восстановление PostgreSQL невозможно.[/]")
                elif not db_settings.pg_dsn: console.print("[bold red]  ❌ DSN для PostgreSQL (pg_dsn) не настроен. Восстановление невозможно.[/]")
                elif not backup_file_in_archive.is_file(): console.print(f"[bold red]  ❌ Файл бэкапа '{POSTGRES_BACKUP_FILENAME}' не найден в '{backup_db_content_path}'.[/]")
                else:
                    parsed_url = urlparse(str(db_settings.pg_dsn))
                    pg_host = parsed_url.hostname if parsed_url.hostname else "localhost"
                    pg_port = str(parsed_url.port) if parsed_url.port is not None else "5432"
                    pg_user = parsed_url.username if parsed_url.username else ""
                    pg_password = parsed_url.password if parsed_url.password else ""
                    pg_database = parsed_url.path.lstrip('/') if parsed_url.path else ""
                    cmd = [ pg_restore_path ]
                    if pg_host: cmd.extend(["-h", pg_host])
                    if pg_port: cmd.extend(["-p", pg_port])
                    if pg_user: cmd.extend(["-U", pg_user])
                    if not pg_database: console.print("[bold red]  ❌ Имя базы данных не найдено в DSN PostgreSQL. Восстановление невозможно.[/]")
                    else:
                        cmd.extend(["-d", pg_database, "--clean", "--if-exists", str(backup_file_in_archive)])
                        env = {}
                        if pg_password: env["PGPASSWORD"] = pg_password
                        console.print(f"  Выполнение pg_restore для PostgreSQL из '{backup_file_in_archive}' в БД '{pg_database}'...")
                        if _execute_system_command(cmd, env_vars=env, show_stdout_on_success=True):
                            console.print(f"[green]  ✅ База данных PostgreSQL успешно восстановлена.[/]")
                            db_restore_successful = True
                        else: console.print(f"[bold red]  ❌ Ошибка при восстановлении PostgreSQL.[/]")
            
            elif db_settings.type == "mysql":
                mysql_path = _find_system_utility("mysql")
                backup_file_in_archive = backup_db_content_path / MYSQL_BACKUP_FILENAME
                if not mysql_path: console.print("[bold red]  ❌ Утилита 'mysql' не найдена. Восстановление MySQL невозможно.[/]")
                elif not db_settings.mysql_dsn: console.print("[bold red]  ❌ DSN для MySQL (mysql_dsn) не настроен. Восстановление невозможно.[/]")
                elif not backup_file_in_archive.is_file(): console.print(f"[bold red]  ❌ Файл бэкапа '{MYSQL_BACKUP_FILENAME}' не найден в '{backup_db_content_path}'.[/]")
                else:
                    parsed_url = urlparse(str(db_settings.mysql_dsn))
                    mysql_host = parsed_url.hostname if parsed_url.hostname else "localhost"
                    mysql_port = str(parsed_url.port) if parsed_url.port is not None else "3306"
                    mysql_user = parsed_url.username if parsed_url.username else ""
                    mysql_password = parsed_url.password if parsed_url.password else ""
                    mysql_database = parsed_url.path.lstrip('/') if parsed_url.path else ""
                    cmd = [ mysql_path ]
                    if mysql_host: cmd.extend(["-h", mysql_host])
                    if mysql_port: cmd.extend(["-P", mysql_port])
                    if mysql_user: cmd.extend(["-u", mysql_user])
                    if not mysql_database: console.print("[bold red]  ❌ Имя базы данных не найдено в DSN MySQL. Восстановление невозможно.[/]")
                    else:
                        cmd.append(mysql_database) 
                        env = {}
                        if mysql_password: env["MYSQL_PWD"] = mysql_password
                        try:
                            sql_dump_content = backup_file_in_archive.read_text(encoding='utf-8')
                            console.print(f"  Выполнение восстановления MySQL из '{backup_file_in_archive}' в БД '{mysql_database}'...")
                            if _execute_system_command(cmd, env_vars=env, input_data=sql_dump_content, show_stdout_on_success=True):
                                console.print(f"[green]  ✅ База данных MySQL успешно восстановлена.[/]")
                                db_restore_successful = True
                            else: console.print(f"[bold red]  ❌ Ошибка при восстановлении MySQL.[/]")
                        except Exception as e_read_sql: console.print(f"[bold red]  ❌ Ошибка чтения SQL-дампа '{backup_file_in_archive}': {e_read_sql}[/]")
            else:
                console.print(f"[bold red]  ❌ Неподдерживаемый тип БД для восстановления: {db_settings.type}[/]")
    else:
        console.print("\n[dim blue]1. Восстановление Базы Данных пропущено.[/dim]")

    if restore_data_dirs:
        console.print(f"\n[bold blue]2. Восстановление Данных Проекта[/]")
        backup_data_archive_dir = target_backup_path / DATA_FILES_BACKUP_DIR_NAME
        target_project_data_dir = settings.core.project_data_path
        if not backup_data_archive_dir.is_dir() or not any(backup_data_archive_dir.iterdir()):
            console.print(f"[yellow]  Не найдены архивы с данными проекта в '{backup_data_archive_dir}'. Пропуск.[/yellow]")
        else:
            data_archives = list(backup_data_archive_dir.glob(f"*{DATA_ARCHIVE_EXTENSION}")) or list(backup_data_archive_dir.glob("*.tar"))
            if data_archives:
                source_data_archive = data_archives[0] 
                console.print(f"  Распаковка архива данных '{source_data_archive}' в '{target_project_data_dir}'...")
                try:
                    temp_extract_path = target_project_data_dir.parent / f"__{target_project_data_dir.name}_restore_temp_{timestamp_for_files}"
                    temp_extract_path.mkdir(parents=True, exist_ok=True)
                    with tarfile.open(source_data_archive, "r:*") as tar: tar.extractall(path=str(temp_extract_path))
                    console.print(f"[dim]    Содержимое архива распаковано во временную папку: {temp_extract_path}[/dim]")
                    console.print(f"[dim]    Перемещение/копирование в целевую директорию: {target_project_data_dir} ...[/dim]")
                    for item_in_temp in temp_extract_path.iterdir():
                        target_item_path = target_project_data_dir / item_in_temp.name
                        if item_in_temp.is_dir():
                            if target_item_path.exists(): shutil.rmtree(target_item_path)
                            shutil.move(str(item_in_temp), str(target_item_path))
                        elif item_in_temp.is_file(): shutil.move(str(item_in_temp), str(target_item_path)) 
                    shutil.rmtree(temp_extract_path) 
                    console.print(f"[green]  ✅ Данные проекта успешно восстановлены из архива.[/]")
                    data_restore_successful = True
                except tarfile.ReadError as e_tar_read: console.print(f"[bold red]  ❌ Ошибка чтения архива данных '{source_data_archive}': {e_tar_read}[/]")
                except Exception as e_restore_data:
                    console.print(f"[bold red]  ❌ Ошибка при восстановлении данных проекта: {e_restore_data}[/]")
                    if 'temp_extract_path' in locals() and temp_extract_path.exists():
                         try: shutil.rmtree(temp_extract_path)
                         except Exception: pass
            else: console.print(f"[yellow]  Не найден архив данных (.tar.gz или .tar) в '{backup_data_archive_dir}'.[/yellow]")
    else: console.print("\n[dim blue]2. Восстановление Данных Проекта пропущено.[/dim]")

    console.print("\n[bold underline]Итоги восстановления:[/]")
    if restore_db:
        if db_restore_successful: console.print("[bold green]  БД: УСПЕШНО[/]")
        else: console.print("[bold red]  БД: ОШИБКА или НЕ ВЫПОЛНЕНО[/]")
    if restore_data_dirs:
        if data_restore_successful: console.print("[bold green]  Данные проекта: УСПЕШНО[/]")
        else: console.print("[bold red]  Данные проекта: ОШИБКА или НЕ ВЫПОЛНЕНО[/]")
    if not db_restore_successful and restore_db or (not data_restore_successful and restore_data_dirs):
        console.print("[bold red]Восстановление завершилось с ошибками для некоторых компонентов.[/]")
    elif not restore_db and not restore_data_dirs: pass 
    else:
        console.print(f"\n[bold green]🎉 Восстановление из бэкапа '{backup_name}' успешно завершено для выбранных компонентов.[/]")
        console.print("[yellow]Не забудьте проверить конфигурацию и, возможно, перезапустить бота, если он был запущен во время восстановления.[/yellow]")
        console.print("[yellow]Если восстанавливалась БД, может потребоваться `alembic stamp head` или проверка миграций.[/yellow]")


======================================================================

------------------------------ FILE: cli_commands/control_cmd.py ------------------------------
# cli_commands/control_cmd.py

import typer
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.columns import Columns 
from rich.text import Text
import os
import signal
import time
import subprocess
from pathlib import Path
import sys
import asyncio
from typing import Optional, List, Tuple as TypingTuple, Any 

try:
    import psutil
except ImportError:
    psutil = None

from datetime import datetime, timedelta

from .cli_utils import get_sdb_services_for_cli

console = Console()
PID_FILENAME = "sdb_bot.pid"
control_app = typer.Typer(
    name="control", 
    help="🚦 Управление процессом Telegram-бота SDB.", 
    rich_markup_mode="rich",
    no_args_is_help=True  # <--- ДОБАВЛЕНО
)

def _get_pid_file_path() -> Path:
    from core.app_settings import settings
    project_data_dir = Path(settings.core.project_data_path)
    return project_data_dir / PID_FILENAME

def _read_pid_from_file(pid_file: Path) -> Optional[int]:
    if not pid_file.is_file(): return None
    try:
        with open(pid_file, "r") as f: pid_str = f.read().strip()
        if not pid_str.isdigit():
            sys.stderr.write(f"Предупреждение: PID-файл {pid_file} содержит нечисловое значение: '{pid_str}'.\n")
            return None
        return int(pid_str)
    except Exception as e:
        sys.stderr.write(f"Ошибка чтения PID из файла {pid_file}: {e}\n")
        return None

def _is_process_running(pid: int) -> bool:
    if psutil:
        try: return psutil.pid_exists(pid)
        except Exception: pass
            
    if sys.platform != "win32":
        try:
            os.kill(pid, 0)
            return True
        except OSError: 
            return False
    else: 
        try:
            result = subprocess.run(
                ['tasklist', '/FI', f'PID eq {pid}'], 
                capture_output=True, text=True, check=False, 
                creationflags=getattr(subprocess, 'CREATE_NO_WINDOW', 0)
            )
            return str(pid) in result.stdout
        except FileNotFoundError:
            return False 
        except Exception:
            return False

async def _get_total_users_count_cli() -> Optional[int]:
    settings_obj, db_m, _ = None, None, None
    try:
        settings_obj, db_m, _ = await get_sdb_services_for_cli(init_db=True)
        if not db_m:
            return None
        
        from core.database.core_models import User
        from sqlalchemy import select, func as sql_func

        async with db_m.get_session() as session:
            count_stmt = select(sql_func.count(User.id))
            total_users_result = await session.execute(count_stmt)
            return total_users_result.scalar_one_or_none() or 0
    except Exception: 
        return None
    finally:
        if db_m:
            await db_m.dispose()

@control_app.command()
def status():
    """Показать текущий статус и информацию о SDB боте."""
    from core.app_settings import settings 
    from aiogram import __version__ as aiogram_version

    pid_file = _get_pid_file_path()
    pid = _read_pid_from_file(pid_file)

    status_text_elements: List[Text] = [] 
    process_info_data: Optional[List[TypingTuple[str, str]]] = None 

    is_running_flag = False
    if pid and _is_process_running(pid):
        is_running_flag = True
        status_text_elements.append(Text.assemble(("● SDB бот запущен ", "green"), (f"(PID: {pid})", "green bold")))
        if psutil:
            try:
                p = psutil.Process(pid)
                process_info_data = [] 
                with p.oneshot(): 
                    create_time = datetime.fromtimestamp(p.create_time())
                    uptime_delta = datetime.now() - create_time
                    days, remainder = divmod(uptime_delta.total_seconds(), 86400)
                    hours, remainder = divmod(remainder, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    uptime_str_parts = []
                    if days > 0: uptime_str_parts.append(f"{int(days)}д")
                    if hours > 0: uptime_str_parts.append(f"{int(hours)}ч")
                    if minutes > 0: uptime_str_parts.append(f"{int(minutes)}м")
                    uptime_str_parts.append(f"{int(seconds)}с")
                    
                    process_info_data.append(("Запущен:", create_time.strftime("%Y-%m-%d %H:%M:%S")))
                    process_info_data.append(("Время работы:", " ".join(uptime_str_parts) or "0с"))
                    process_info_data.append(("CPU нагрузка:", f"{p.cpu_percent(interval=0.1):.1f}%"))
                    rss_mb = p.memory_info().rss / (1024 * 1024)
                    process_info_data.append(("Память (RSS):", f"{rss_mb:.2f} MB"))
                    try: process_info_data.append(("Кол-во потоков:", str(p.num_threads())))
                    except (psutil.Error, AttributeError, NotImplementedError): pass
                    process_info_data.append(("Статус процесса:", str(p.status())))
                    try: process_info_data.append(("Запущен от:", str(p.username())))
                    except (psutil.Error, AttributeError, NotImplementedError): pass
            except psutil.NoSuchProcess:
                is_running_flag = False 
                status_text_elements.clear() 
                status_text_elements.append(Text(f"⚠ PID-файл ({pid_file}) для PID {pid} существует, но процесс уже не найден (устарел).", style="yellow"))
                if pid_file.is_file(): status_text_elements.append(Text(f"  Рекомендуется удалить PID-файл: rm {pid_file}", style="cyan"))
            except psutil.AccessDenied:
                status_text_elements.append(Text(f"✗ Отказано в доступе к информации о процессе PID {pid}.", style="red"))
            except Exception as e_psutil:
                status_text_elements.append(Text(f"✗ Ошибка psutil для PID {pid}: {e_psutil}", style="red"))
        else: 
             status_text_elements.append(Text("(Установите 'psutil' для детальной информации о процессе)", style="dim"))
    elif pid: 
        status_text_elements.append(Text(f"⚠ SDB бот не запущен (PID-файл {pid_file} (PID {pid}) устарел).", style="yellow"))
        if pid_file.is_file(): status_text_elements.append(Text(f"  Рекомендуется удалить PID-файл: rm {pid_file}", style="cyan"))
    else: 
        status_text_elements.append(Text("◎ SDB бот не запущен (PID-файл не найден).", style="red"))

    status_panel_content = Text("\n").join(status_text_elements)
    status_panel = Panel(status_panel_content, title="[bold green]Статус Бота[/bold green]", border_style="green", expand=False, padding=(1,2))
    
    process_panel_renderable = None
    if process_info_data and is_running_flag: 
        proc_table = Table(show_header=False, box=None, padding=(0, 1), show_edge=False)
        proc_table.add_column(style="dim blue", justify="right", min_width=18, max_width=20) 
        proc_table.add_column(min_width=20)
        for key, value in process_info_data:
            proc_table.add_row(key, value)
        process_panel_renderable = Panel(proc_table, title="[bold blue]Процесс SDB[/bold blue]", border_style="blue", expand=False, padding=1)

    sdb_info_data_list: List[TypingTuple[str, Any]] = []
    sdb_info_data_list.append(("Версия SDB Core:", settings.core.sdb_version))
    sdb_info_data_list.append(("Версия Aiogram:", aiogram_version))
    sdb_info_data_list.append(("Тип БД:", settings.db.type.upper()))
    sdb_info_data_list.append(("Тип кэша:", settings.cache.type.capitalize()))
    
    try:
        from core.module_loader import ModuleLoader
        from core.services_provider import BotServicesProvider 
        temp_bsp = BotServicesProvider(settings=settings)
        loader = ModuleLoader(settings=settings, services_provider=temp_bsp)
        loader.scan_all_available_modules()
        loader._load_enabled_plugin_names() 
        sdb_info_data_list.append(("Найдено модулей:", str(len(loader.available_modules))))
        sdb_info_data_list.append(("Активных модулей:", str(len(loader.enabled_plugin_names))))
    except Exception: 
        sdb_info_data_list.append(("Модули:", Text("Ошибка подсчета", style="yellow")))
    
    total_users = asyncio.run(_get_total_users_count_cli()) 
    user_count_text_val = str(total_users) if total_users is not None else Text("Не удалось получить", style="yellow")
    sdb_info_data_list.append(("Всего пользователей в БД:", user_count_text_val))

    sdb_info_table = Table(show_header=False, box=None, padding=(0,1), show_edge=False)
    sdb_info_table.add_column(style="dim magenta", justify="right", min_width=26) 
    sdb_info_table.add_column(min_width=25)
    for key, value in sdb_info_data_list:
        sdb_info_table.add_row(key, value)
    sdb_info_panel = Panel(sdb_info_table, title="[bold magenta]Конфигурация SDB[/bold magenta]", border_style="magenta", expand=False, padding=1)

    console.print(status_panel) 
    
    columns_content = []
    if process_panel_renderable:
        columns_content.append(process_panel_renderable)
    columns_content.append(sdb_info_panel)
        
    if columns_content: 
        console.print(Columns(columns_content, expand=True, equal=False, padding=(0,2), column_first=False))


@control_app.command()
def stop(
    force: bool = typer.Option(False, "--force", "-f", help="Принудительно остановить (SIGKILL), если SIGTERM не сработал (ОПАСНО)."),
    timeout: int = typer.Option(5, "--timeout", "-t", help="Время ожидания (сек) после SIGTERM перед SIGKILL (если --force).", min=1, max=60)
):
    """Остановить SDB бота."""
    pid_file = _get_pid_file_path()
    pid = _read_pid_from_file(pid_file)

    if not pid:
        console.print("[yellow]SDB бот не запущен (PID-файл не найден).[/yellow]")
        return 

    if not _is_process_running(pid):
        console.print(f"[yellow]SDB бот (PID: {pid} из файла) уже не запущен.[/yellow]")
        if pid_file.is_file(): 
            try:
                pid_file.unlink()
                console.print(f"Устаревший PID-файл {pid_file} удален.")
            except Exception as e_unlink:
                console.print(f"[red]Не удалось удалить устаревший PID-файл {pid_file}: {e_unlink}[/red]")
        return

    console.print(f"Попытка остановить SDB бота (PID: {pid})...")
    
    if sys.platform == "win32":
        console.print("[yellow]Автоматическая остановка для Windows не реализована. Пожалуйста, остановите процесс вручную (taskkill /F /PID {pid}).[/yellow]")
        raise typer.Exit(code=1) 

    try:
        os.kill(pid, signal.SIGTERM) 
        console.print(f"Отправлен сигнал SIGTERM процессу {pid}.")
        
        for i in range(timeout):
            time.sleep(1) 
            if not _is_process_running(pid):
                console.print(f"[green]SDB бот (PID: {pid}) успешно остановлен (через {i+1} сек).[/green]")
                if pid_file.is_file(): pid_file.unlink(missing_ok=True) 
                return 
        
        if _is_process_running(pid):
            if force:
                console.print(f"[yellow]Процесс {pid} все еще активен после {timeout} сек. Принудительная остановка (SIGKILL)...[/yellow]")
                os.kill(pid, signal.SIGKILL)
                time.sleep(0.1) 
                if not _is_process_running(pid):
                    console.print(f"[green]SDB бот (PID: {pid}) принудительно остановлен (SIGKILL).[/green]")
                else: 
                    console.print(f"[red]✗ SDB бот (PID: {pid}) не остановился даже после SIGKILL. Проверьте вручную.[/red]")
                    raise typer.Exit(code=1) 
                if pid_file.is_file(): pid_file.unlink(missing_ok=True)
            else:
                console.print(f"[red]✗ SDB бот (PID: {pid}) не остановился после SIGTERM ({timeout} сек).[/red]")
                console.print(f"  Попробуйте './sdb control stop --force' или остановите процесс вручную (kill {pid}).")
                raise typer.Exit(code=1) 
        else: 
            console.print(f"[green]SDB бот (PID: {pid}) успешно остановлен.[/green]")
            if pid_file.is_file(): pid_file.unlink(missing_ok=True)

    except ProcessLookupError: 
        console.print(f"[green]SDB бот (PID: {pid}) уже был остановлен.[/green]")
        if pid_file.is_file(): pid_file.unlink(missing_ok=True)
    except typer.Exit: 
        raise 
    except Exception as e:
        console.print(f"[red]Ошибка при остановке бота: {e}[/red]")
        raise typer.Exit(code=1)


@control_app.command()
def restart(
    force_stop: bool = typer.Option(False, "--force-stop", help="Использовать --force при остановке перед перезапуском."),
    stop_timeout: int = typer.Option(5, "--stop-timeout", help="Время ожидания (сек) для команды stop.", min=1, max=60),
    background: bool = typer.Option(True, "--background/--no-background", "-b", help="Запустить бота в фоновом режиме после перезапуска."),
    debug: bool = typer.Option(False, "--debug", "-d", help="Запустить бота в режиме отладки после перезапуска.")
):
    """Перезапустить SDB бота: останавливает (если запущен) и затем запускает."""
    console.print(Panel("[blue]Перезапуск SDB бота...[/blue]", expand=False))
    
    console.print("\n[cyan]Шаг 1: Остановка текущего экземпляра бота (если запущен)...[/cyan]")
    stop_failed = False
    
    sdb_executable_str: Optional[str] = None
    if Path(sys.argv[0]).is_absolute():
        sdb_executable_str = sys.argv[0]
    else:
        sdb_script_in_bin = Path(sys.executable).parent / Path(sys.argv[0]).name
        if sdb_script_in_bin.exists() and (os.access(sdb_script_in_bin, os.X_OK) or str(sdb_script_in_bin).endswith(".py")):
            sdb_executable_str = str(sdb_script_in_bin)
        else: 
            sdb_py_in_cwd = Path.cwd() / "sdb.py"
            sdb_in_cwd = Path.cwd() / "sdb"
            if sdb_py_in_cwd.exists():
                sdb_executable_str = str(sdb_py_in_cwd)
            elif sdb_in_cwd.exists() and os.access(sdb_in_cwd, os.X_OK):
                sdb_executable_str = str(sdb_in_cwd)
    
    if not sdb_executable_str:
        console.print(f"[bold red]Не удалось определить исполняемый файл SDB CLI. Проверьте sys.argv[0]: {sys.argv[0]}[/bold red]")
        raise typer.Exit(1)

    try:
        stop_command_args = [str(sys.executable), sdb_executable_str, "control", "stop", f"--timeout={stop_timeout}"]
        if force_stop:
            stop_command_args.append("--force")
        
        console.print(f"[dim]Вызов команды остановки: {' '.join(stop_command_args)}[/dim]")
        stop_process_result = subprocess.run(stop_command_args, capture_output=True, text=True, encoding='utf-8')

        # Печатаем stdout и stderr как обычный текст, Rich разберется с разметкой внутри них
        if stop_process_result.stdout:
            console.print(f"[dim cyan]Вывод 'stop':[/]\n{stop_process_result.stdout.strip()}")
        if stop_process_result.stderr:
            console.print(f"[dim yellow]Ошибки от 'stop':[/]\n{stop_process_result.stderr.strip()}")

        if stop_process_result.returncode != 0:
            console.print(f"[bold red]Ошибка на фазе остановки (код: {stop_process_result.returncode}).[/bold red]")
            if not typer.confirm("Продолжить попытку запуска, несмотря на ошибку остановки?", default=False):
                console.print("[bold yellow]Перезапуск отменен пользователем.[/bold yellow]")
                raise typer.Exit(code=1)
            console.print("[yellow]Продолжение перезапуска, несмотря на ошибку остановки...[/yellow]")
            stop_failed = True
        else:
            console.print("[green]Фаза остановки успешно завершена (бот остановлен или не был запущен).[/green]")

    except Exception as e_stop_wrapper:
        console.print(Text.assemble(("[bold red]Непредвиденная ошибка при вызове подпроцесса 'stop': ", "bold red"), Text(str(e_stop_wrapper))))
        if not typer.confirm("Продолжить попытку запуска, несмотря на ошибку?", default=False):
            console.print("[bold yellow]Перезапуск отменен пользователем.[/bold yellow]")
            raise typer.Exit(code=1)
        console.print("[yellow]Продолжение перезапуска...[/yellow]")
        stop_failed = True

    if not stop_failed:
        console.print("[dim]Ожидание 1 секунда перед запуском...[/dim]")
        time.sleep(1)

    console.print("\n[cyan]Шаг 2: Запуск нового экземпляра бота...[/cyan]")
    try:
        start_command_args = [str(sys.executable), sdb_executable_str, "start"]
        if background:
            start_command_args.append("--background")
        if debug:
            start_command_args.append("--debug")

        console.print(f"[dim]Вызов команды запуска: {' '.join(start_command_args)}[/dim]")
        
        if background:
            subprocess.Popen(start_command_args)
            console.print("[green]Команда запуска бота в фоновом режиме успешно отправлена.[/green]")
        else:
            start_process_result = subprocess.run(start_command_args, capture_output=True, text=True, encoding='utf-8')
            if start_process_result.stdout:
                 console.print(f"[dim cyan]Вывод 'start':[/]\n{start_process_result.stdout.strip()}")
            if start_process_result.stderr: 
                 console.print(f"[dim yellow]Вывод (возможно, ошибки) от 'start':[/]\n{start_process_result.stderr.strip()}")
            if start_process_result.returncode != 0:
                console.print(f"[bold red]Ошибка на фазе запуска бота (код: {start_process_result.returncode}).[/bold red]")
                raise typer.Exit(code=1)
            console.print("[green]Команда запуска бота успешно вызвана (интерактивный режим).[/green]")

    except Exception as e_start_wrapper:
        console.print(Text.assemble(("[bold red]Непредвиденная ошибка на этапе запуска: ", "bold red"), Text(str(e_start_wrapper))))
        raise typer.Exit(code=1)

    console.print("\n[bold green]Команда перезапуска завершена.[/bold green]")
    if background:
        console.print("  Проверьте статус бота через: [cyan]./sdb control status[/cyan]")


======================================================================

------------------------------ FILE: cli_commands/setup_cmd.py ------------------------------
# cli_commands/setup_cmd.py

import typer
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax # Для красивого вывода конфига
import yaml # Для работы с YAML файлами
import json # Для возможного вывода в JSON
import shutil # Для копирования файлов
from pathlib import Path
import sys
from datetime import datetime

# Создаем свою консоль для этого модуля
console = Console()

# Typer-приложение для команд группы 'config' (ранее setup_app)
# Переименовал setup_app в config_app для ясности, что это группа команд "config"
config_app = typer.Typer(
    name="config", 
    help="🔧 Управление конфигурацией SwiftDevBot (инициализация, просмотр).",
    rich_markup_mode="rich",
    no_args_is_help=True  # <--- ДОБАВЛЕНО
)

# Определяем корень проекта относительно текущего файла
# cli_commands/setup_cmd.py -> cli_commands -> SDB_ROOT
PROJECT_ROOT = Path(__file__).resolve().parent.parent
DEFAULT_CONFIG_TEMPLATE_NAME = "config.yaml" # Шаблон в корне проекта
USER_CONFIG_DIR_NAME_IN_PROJECT_DATA = "Config" # Имя папки Config внутри project_data
USER_CONFIG_FILENAME = "core_settings.yaml" # Имя пользовательского конфига

@config_app.command(name="init", help="Инициализировать или обновить файл конфигурации пользователя.")
def setup_config_cmd(
    force: bool = typer.Option(False, "--force", "-f", help="Принудительно перезаписать существующий конфиг (с созданием бэкапа).")
):
    """
    Создает или обновляет пользовательский файл конфигурации 'core_settings.yaml'
    в директории 'project_data/Config/' на основе шаблона 'config.yaml' из корня проекта.
    """
    console.print(Panel("[bold cyan]Инициализация конфигурации SwiftDevBot[/]", expand=False, border_style="cyan"))

    try:
        # Импортируем настройки SDB, чтобы получить путь к project_data
        from core.app_settings import settings, PROJECT_ROOT_DIR # settings уже загружены, если sdb.py их импортировал
        
        project_data_path = settings.core.project_data_path
        user_config_dir = project_data_path / USER_CONFIG_DIR_NAME_IN_PROJECT_DATA
        user_config_file_path = user_config_dir / USER_CONFIG_FILENAME
        template_config_path = PROJECT_ROOT_DIR / DEFAULT_CONFIG_TEMPLATE_NAME

        user_config_dir.mkdir(parents=True, exist_ok=True) # Создаем директорию, если ее нет

        if not template_config_path.exists():
            console.print(f"[bold red]Ошибка: Шаблон конфигурации '{template_config_path}' не найден.[/]")
            console.print("Убедитесь, что файл 'config.yaml' существует в корне проекта.")
            raise typer.Exit(code=1)

        if user_config_file_path.exists():
            console.print(f"[yellow]Обнаружен существующий файл конфигурации: '{user_config_file_path}'[/]")
            if force:
                should_overwrite = True
                console.print("[yellow]Опция --force: существующий конфиг будет перезаписан (с бэкапом).[/]")
            else:
                # Спрашиваем пользователя, что делать
                # TODO: Добавить опцию "обновить/дополнить" (слияние YAML) - это сложнее.
                # Пока предлагаем только перезаписать или отменить.
                overwrite_options = ["Перезаписать (создать бэкап)", "Отмена"]
                # Это псевдо-интерактивность для Typer, реальная интерактивность сложнее.
                # Проще использовать typer.confirm
                # choice = typer.prompt(f"Что вы хотите сделать?", type=typer.Choice(overwrite_options), default=overwrite_options[1])
                # if choice == overwrite_options[1]: # Отмена
                if not typer.confirm(f"Перезаписать существующий файл '{user_config_file_path}' (старый будет сохранен как .bak)?", default=False):
                    console.print("[bold green]Операция отменена пользователем.[/]")
                    raise typer.Exit()
                should_overwrite = True
            
            if should_overwrite:
                backup_path = user_config_file_path.with_suffix(f".{datetime.now().strftime('%Y%m%d_%H%M%S')}.bak")
                try:
                    shutil.copy2(user_config_file_path, backup_path) # copy2 сохраняет метаданные
                    console.print(f"[green]Создан бэкап старого конфига: '{backup_path}'[/]")
                except Exception as e_backup:
                    console.print(f"[bold red]Ошибка создания бэкапа для '{user_config_file_path}': {e_backup}[/]")
                    if not typer.confirm("Продолжить перезапись без бэкапа?", default=False):
                        raise typer.Exit()
                
                # Удаляем старый файл перед копированием нового, чтобы избежать проблем с правами/слиянием
                user_config_file_path.unlink(missing_ok=True) 
        
        # Копируем шаблон в пользовательский конфиг
        try:
            shutil.copy2(template_config_path, user_config_file_path)
            console.print(f"[bold green]Файл конфигурации успешно создан/обновлен: '{user_config_file_path}'[/]")
            console.print(f"Пожалуйста, отредактируйте этот файл, указав ваши настройки (особенно BOT_TOKEN, если он не в .env).")
            console.print(f"Не забудьте также создать файл '.env' в корне проекта и указать в нем BOT_TOKEN.")
        except Exception as e_copy:
            console.print(f"[bold red]Ошибка копирования шаблона '{template_config_path}' в '{user_config_file_path}': {e_copy}[/]")
            raise typer.Exit(code=1)

    except ImportError:
        console.print(f"[bold red]Ошибка: Не удалось импортировать 'core.app_settings'.[/]")
        console.print("Убедитесь, что SDB установлен корректно и вы запускаете команду из корня проекта.")
        raise typer.Exit(code=1)
    except Exception as e:
        console.print(f"[bold red]Произошла непредвиденная ошибка: {e}[/]")
        console.print_exception(show_locals=False)
        raise typer.Exit(code=1)

@config_app.command(name="info", help="Показать текущую активную конфигурацию SDB.")
def show_info_cmd(
    show_defaults: bool = typer.Option(False, "--show-defaults", help="Включить в вывод значения по умолчанию (для Pydantic моделей)."),
    output_format: str = typer.Option("yaml", "--format", "-fmt", help="Формат вывода: 'yaml' или 'json'.", 
                                       case_sensitive=False, show_choices=True, 
                                       # typer.Choice не работает напрямую в typer.Option в некоторых версиях,
                                       # но можно использовать callback для валидации или просто информировать.
                                       ) 
):
    """
    Отображает текущую загруженную конфигурацию SwiftDevBot, объединяя значения
    из файла настроек, переменных окружения и дефолтов.
    """
    console.print(Panel("[bold cyan]Текущая активная конфигурация SwiftDevBot[/]", expand=False, border_style="cyan"))
    output_format = output_format.lower()
    if output_format not in ["yaml", "json"]:
        console.print(f"[bold red]Ошибка: Неподдерживаемый формат вывода '{output_format}'. Доступны: 'yaml', 'json'.[/]")
        raise typer.Exit(code=1)

    try:
        from core.app_settings import settings # Загружаем уже инициализированные настройки

        # Используем model_dump() из Pydantic V2 для получения словаря
        # mode='json' гарантирует, что типы данных (Path, HttpUrl и т.д.) будут сериализованы
        # в JSON-совместимые типы (строки).
        # exclude_defaults=not show_defaults - если show_defaults=False (дефолт), то exclude_defaults=True
        config_dict = settings.model_dump(mode='json', exclude_defaults=not show_defaults)

        if output_format == "yaml":
            try:
                # Преобразуем строки Path обратно в Path для красивого вывода YAML (если PyYAML это умеет)
                # Это может быть излишним, если model_dump(mode='json') уже все сделал правильно.
                # Для простоты оставим как есть, PyYAML должен справиться со строками.
                yaml_output_str = yaml.dump(config_dict, indent=2, allow_unicode=True, sort_keys=False)
                syntax = Syntax(yaml_output_str, "yaml", theme="native", line_numbers=True, word_wrap=True)
                console.print(syntax)
            except ImportError:
                console.print("[yellow]PyYAML не установлен. Вывод будет в формате JSON.[/]")
                output_format = "json" # Переключаемся на JSON
            except Exception as e_yaml:
                console.print(f"[red]Ошибка форматирования вывода в YAML: {e_yaml}. Попробуйте JSON.[/]")
                output_format = "json" # Переключаемся на JSON
        
        if output_format == "json": # Если был выбран JSON или переключились из-за ошибки YAML
            json_output_str = json.dumps(config_dict, indent=2, ensure_ascii=False)
            syntax = Syntax(json_output_str, "json", theme="native", line_numbers=True, word_wrap=True)
            console.print(syntax)
            
        console.print(f"\n[dim]Конфигурация загружена с учетом дефолтов, '{USER_CONFIG_FILENAME}', и переменных окружения.[/dim]")
        if not show_defaults:
            console.print("[dim]Значения по умолчанию не показаны. Используйте --show-defaults для их отображения.[/dim]")

    except ImportError:
        console.print(f"[bold red]Ошибка: Не удалось импортировать 'core.app_settings'.[/]")
        raise typer.Exit(code=1)
    except Exception as e:
        console.print(f"[bold red]Произошла непредвиденная ошибка при отображении конфигурации: {e}[/]")
        console.print_exception(show_locals=False)
        raise typer.Exit(code=1)


======================================================================

------------------------------ FILE: cli_commands/module_cmd.py ------------------------------
import typer
import shutil
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from rich.syntax import Syntax
import json
from pathlib import Path
import sys
import asyncio
import importlib
from typing import List, Dict, Any, Optional, Type

from .cli_utils import get_sdb_services_for_cli, confirm_action
from core.database.base import Base as SDBBaseAlchemyModel 

console = Console()
module_app = typer.Typer(
    name="module",
    help="🧩 Управление модулями (плагинами) SwiftDevBot.",
    rich_markup_mode="rich",
    no_args_is_help=True  # <--- ДОБАВЛЕНО
)

async def _get_module_loader_instance_async() -> Optional[Any]: 
    settings_obj, _, _ = await get_sdb_services_for_cli(init_db=False, init_rbac=False)
    if not settings_obj:
        console.print("[bold red]Ошибка: Не удалось загрузить настройки SDB для ModuleLoader (из CLI).[/]")
        return None
    try:
        from core.module_loader import ModuleLoader
        from core.services_provider import BotServicesProvider
        
        # Создаем временный BotServicesProvider только для ModuleLoader,
        # так как полная инициализация сервисов здесь не нужна и может быть долгой.
        # ModuleLoader в основном использует settings и самого себя (для логирования через services.logger).
        # Это не идеальный вариант, но для CLI команд, где нам нужен только ModuleLoader, это может быть приемлемо.
        # Либо ModuleLoader должен быть переделан, чтобы не требовать полного BSP для таких операций.
        # Пока оставим так, но с комментарием.
        temp_bsp = BotServicesProvider(settings=settings_obj)
        # Не вызываем temp_bsp.setup_services(), так как это для рантайма бота.
        # ModuleLoader должен уметь работать с settings и логгером.
        
        loader = ModuleLoader(settings=settings_obj, services_provider=temp_bsp) # Передаем temp_bsp
        
        # ИЗМЕНЕНО ЗДЕСЬ
        if hasattr(loader, 'scan_all_available_modules'):
            loader.scan_all_available_modules()
        else:
            console.print("[bold red]Критическая ошибка: Метод 'scan_all_available_modules' не найден в ModuleLoader.[/]")
            return None
            
        if hasattr(loader, '_load_enabled_plugin_names'):
            getattr(loader, '_load_enabled_plugin_names')()
        else:
            console.print("[yellow]Предупреждение: Метод '_load_enabled_plugin_names' не найден в ModuleLoader при вызове из CLI.[/yellow]")
        
        return loader
    except ImportError as e_imp:
        console.print(f"[bold red]Ошибка импорта компонентов ядра SDB для ModuleLoader (из CLI): {e_imp}[/]")
        return None
    except Exception as e_load:
        console.print(f"[bold red]Ошибка при инициализации ModuleLoader (из CLI): {e_load}[/]")
        console.print_exception(show_locals=False) # Добавим вывод трейсбека
        return None

def _get_module_loader_sync() -> Optional[Any]: 
    try:
        return asyncio.run(_get_module_loader_instance_async())
    except Exception as e:
        # Лог ошибки уже должен быть в _get_module_loader_instance_async
        # console.print(f"[bold red]Не удалось получить ModuleLoader синхронно: {e}[/]")
        return None

def _save_enabled_modules(module_names: List[str], config_path: Path) -> bool:
    try:
        # Убедимся, что сохраняем только уникальные имена
        unique_module_names = sorted(list(set(name.strip() for name in module_names if name.strip())))
        data_to_save = {"active_modules": unique_module_names, "disabled_modules": []} # disabled_modules пока не используется активно
        
        config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(data_to_save, f, indent=2, ensure_ascii=False)
        return True
    except Exception as e:
        console.print(f"[bold red]Ошибка сохранения списка активных модулей в {config_path}: {e}[/]")
        return False

@module_app.command(name="create", help="Создать шаблон нового модуля.")
def create_module_cmd(name: str = typer.Argument(..., help="Имя нового модуля (без пробелов, только буквы, цифры, '_').")):
    """Создаёт шаблон нового модуля."""
    from loguru import logger  # Локальный импорт, чтобы не конфликтовать с rich

    # Проверяем валидность имени
    if not name.isidentifier():
        console.print(f"[bold red]Ошибка: Имя модуля '{name}' недопустимо. Используйте буквы, цифры и '_', без пробелов.[/]")
        raise typer.Exit(code=1)

    module_dir = Path("modules") / name
    if module_dir.exists():
        console.print(f"[bold red]Ошибка: Модуль '{name}' уже существует в {module_dir}.[/]")
        raise typer.Exit(code=1)

    console.print(Panel(f"[bold cyan]Создание модуля: {name}[/]", expand=False, border_style="cyan"))
    try:
        module_dir.mkdir(parents=True)
        
        # Создаём manifest.yaml
        manifest_content = f"""\
name: {name}
version: 0.1.0
display_name: {name.title()}
description: Модуль {name} для SwiftDevBot
commands:
  - command: /{name}
    description: Запустить модуль {name}
permissions:
  - {name}.use: Право использовать модуль
  - {name}.admin: Право администрировать модуль
model_definitions: []
"""
        (module_dir / "manifest.yaml").write_text(manifest_content, encoding="utf-8")
        console.print(f"[green]Создан файл: {module_dir / 'manifest.yaml'}[/]")

        # Создаём __init__.py
        init_content = f"""\
from aiogram import Router
from core.services.ui_registry import register_module_entry
from core.services_provider import BotServicesProvider

router = Router(name="{name}")

def setup_module(services: BotServicesProvider):
    register_module_entry(
        services=services,
        module_name="{name}",
        title="{{{{_('{name.title()}')}}}}",
        description="{{{{_('Модуль {name.title()}')}}}}",
        icon="🔧",
        entry_command="/{name}",
        required_permission="{name}.use",
    )
    services.routers.append(router)
"""
        (module_dir / "__init__.py").write_text(init_content, encoding="utf-8")
        console.print(f"[green]Создан файл: {module_dir / '__init__.py'}[/]")

        # Создаём handlers.py
        handlers_content = f"""\
from aiogram import types, Router
from aiogram.filters import Command
from core.services_provider import BotServicesProvider

router = Router(name="{name}_handlers")

@router.message(Command("{name}"))
async def cmd_{name}(message: types.Message, services: BotServicesProvider):
    if not await services.rbac.user_has_permission(services.db_session, message.from_user.id, "{name}.use"):
        await message.answer("Доступ запрещён")
        return
    await message.answer("Привет от модуля {name}!")
"""
        (module_dir / "handlers.py").write_text(handlers_content, encoding="utf-8")
        console.print(f"[green]Создан файл: {module_dir / 'handlers.py'}[/]")

        # Создаём пустые папки и __init__.py
        (module_dir / "keyboards").mkdir()
        (module_dir / "keyboards" / "__init__.py").touch()
        console.print(f"[green]Создана папка: {module_dir / 'keyboards'}[/]")
        (module_dir / "models").mkdir()
        (module_dir / "models" / "__init__.py").touch()
        console.print(f"[green]Создана папка: {module_dir / 'models'}[/]")

        console.print(f"[bold green]Модуль '{name}' успешно создан в {module_dir}![/]")
        console.print(f"[yellow]Действия для активации:[/]")
        console.print(f"1. Добавьте модуль в core_settings.yaml:")
        console.print(Syntax(f"""modules:
  enabled:
    - {name}
""", "yaml", theme="fruity"))
        console.print(f"2. Включите модуль: [cyan]./sdb.py module enable {name}[/]")
        console.print(f"3. Перезапустите бот: [cyan]./sdb.py control restart[/]")
        logger.success(f"Модуль {name} создан в {module_dir}")
    except Exception as e:
        console.print(f"[bold red]Ошибка при создании модуля '{name}': {e}[/]")
        logger.error(f"Ошибка создания модуля {name}: {e}")
        shutil.rmtree(module_dir, ignore_errors=True)
        raise typer.Exit(code=1)

@module_app.command(name="list", help="Показать список всех найденных модулей и их статус.")
def list_modules_cmd():
    loader = _get_module_loader_sync()
    if not loader: 
        # Сообщение об ошибке уже должно быть выведено из _get_module_loader_sync или _get_module_loader_instance_async
        raise typer.Exit(code=1)
        
    table = Table(title="[bold cyan]Модули SwiftDevBot[/]", show_header=True, header_style="bold magenta")
    table.add_column("Имя Модуля (name)", style="dim cyan", min_width=20)
    table.add_column("Отображаемое Имя", min_width=25)
    table.add_column("Версия", style="yellow")
    table.add_column("Тип", style="blue") # Добавим тип
    table.add_column("Статус", style="green")
    table.add_column("Описание", max_width=50, overflow="fold")

    if not loader.available_modules:
        console.print("[yellow]Не найдено ни одного модуля (в modules/ или core/sys_modules/).[/]")
        return
        
    sorted_modules = sorted(loader.available_modules.values(), key=lambda m_info: (m_info.is_system_module, m_info.name))
    
    for module_info in sorted_modules:
        module_type = "Системный" if module_info.is_system_module else "Плагин"
        
        # Статус для плагинов зависит от enabled_plugin_names
        # Статус для системных - они "всегда активны для загрузки" (но могут не загрузиться из-за ошибок)
        if module_info.is_system_module:
            status_text = Text("Активен (системный)", style="green") # или "Загружен", если есть is_loaded_successfully
            if module_info.is_loaded_successfully:
                status_text = Text("Загружен ✅ (сист.)", style="green")
            elif module_info.error:
                 status_text = Text(f"Ошибка ⚠️ (сист.)", style="red")

        else: # Это плагин
            status_text = Text("Активен ✅", style="green") if module_info.name in loader.enabled_plugin_names else Text("Неактивен ❌", style="red")
            if module_info.name in loader.enabled_plugin_names and module_info.is_loaded_successfully:
                status_text = Text("Загружен ✅", style="green")
            elif module_info.name in loader.enabled_plugin_names and module_info.error:
                status_text = Text(f"Ошибка ⚠️", style="red")

        version_str = module_info.manifest.version if module_info.manifest else "[N/A]"
        display_name_str = module_info.manifest.display_name if module_info.manifest else module_info.name # fallback на имя папки
        description_str = module_info.manifest.description if module_info.manifest and module_info.manifest.description else "-"
        
        table.add_row(module_info.name, display_name_str, version_str, module_type, status_text, description_str)
    console.print(table)

@module_app.command(name="info", help="Показать детальную информацию о модуле (из manifest).")
def info_module_cmd(module_name: str = typer.Argument(..., help="Имя модуля (из manifest.name или имя папки).")):
    loader = _get_module_loader_sync()
    if not loader: raise typer.Exit(code=1)
    
    module_info = loader.get_module_info(module_name)
    
    if not module_info:
        console.print(f"[bold red]Ошибка: Модуль '{module_name}' не найден.[/]")
        raise typer.Exit(code=1)
        
    if not module_info.manifest:
        console.print(f"[yellow]Модуль '{module_name}' найден, но не имеет валидного манифеста (или он не был распарсен).[/yellow]")
        console.print(f"  Путь к модулю: {module_info.path}")
        console.print(f"  Тип: {'Системный' if module_info.is_system_module else 'Плагин'}")
        if module_info.error: console.print(f"  Ошибка при попытке загрузки манифеста: {module_info.error}")
        raise typer.Exit(code=1)

    display_name_header = module_info.manifest.display_name or module_info.name
    console.print(Panel(f"[bold cyan]Информация о модуле: {display_name_header} ({module_name})[/]", expand=False, border_style="cyan"))
    
    try:
        import yaml
        manifest_str = yaml.dump(module_info.manifest.model_dump(mode='json'), indent=2, allow_unicode=True, sort_keys=False)
        syntax = Syntax(manifest_str, "yaml", theme="fruity", line_numbers=True, background_color="default")
    except ImportError:
        manifest_str = json.dumps(module_info.manifest.model_dump(mode='json'), indent=2, ensure_ascii=False)
        syntax = Syntax(manifest_str, "json", theme="fruity", line_numbers=True, background_color="default")
    except Exception as e_dump:
        console.print(f"[yellow]Не удалось красиво отобразить манифест: {e_dump}. Вывод как словарь:[/]")
        console.print(module_info.manifest.model_dump())
        raise typer.Exit(code=1)
    console.print(syntax)

@module_app.command(name="enable", help="Активировать плагин (добавить в enabled_modules.json).")
def enable_module_cmd(module_name: str = typer.Argument(..., help="Имя плагина для активации.")):
    loader = _get_module_loader_sync()
    if not loader: raise typer.Exit(code=1)

    module_info = loader.get_module_info(module_name)
    if not module_info:
        console.print(f"[bold red]Ошибка: Модуль '{module_name}' не найден среди доступных. Проверьте имя.[/]")
        console.print(f"Доступные для управления (плагины): {[m.name for m in loader.available_modules.values() if not m.is_system_module]}")
        raise typer.Exit(code=1)

    if module_info.is_system_module:
        console.print(f"[bold red]Ошибка: Системные модули ('{module_name}') не управляются через enable/disable. Они загружаются ядром.[/]")
        raise typer.Exit(code=1)

    enabled_modules_file_path = loader._settings.core.enabled_modules_config_path
    
    if module_name in loader.enabled_plugin_names:
        console.print(f"[yellow]Плагин '{module_name}' уже активен.[/]")
        return

    new_enabled_list = loader.enabled_plugin_names + [module_name]
    if _save_enabled_modules(new_enabled_list, enabled_modules_file_path):
        console.print(f"[bold green]Плагин '{module_name}' успешно активирован![/]")
        console.print(f"Изменения вступят в силу после перезапуска бота (`./sdb control restart`).")
    else:
        console.print(f"[bold red]Не удалось сохранить изменения в '{enabled_modules_file_path}'.[/]")
        raise typer.Exit(code=1)

@module_app.command(name="disable", help="Деактивировать плагин (удалить из enabled_modules.json).")
def disable_module_cmd(module_name: str = typer.Argument(..., help="Имя плагина для деактивации.")):
    loader = _get_module_loader_sync()
    if not loader: raise typer.Exit(code=1)

    module_info = loader.get_module_info(module_name)
    if not module_info:
        console.print(f"[bold red]Ошибка: Модуль '{module_name}' не найден.[/]")
        raise typer.Exit(code=1)

    if module_info.is_system_module:
        console.print(f"[bold red]Ошибка: Системные модули ('{module_name}') не управляются через enable/disable.[/]")
        raise typer.Exit(code=1)

    enabled_modules_file_path = loader._settings.core.enabled_modules_config_path
    
    if module_name not in loader.enabled_plugin_names:
        console.print(f"[yellow]Плагин '{module_name}' не был активен.[/]")
        return
    
    new_enabled_list = [m for m in loader.enabled_plugin_names if m != module_name]
    if _save_enabled_modules(new_enabled_list, enabled_modules_file_path):
        console.print(f"[bold green]Плагин '{module_name}' успешно деактивирован![/]")
        console.print(f"Изменения вступят в силу после перезапуска бота (`./sdb control restart`).")
    else:
        console.print(f"[bold red]Не удалось сохранить изменения в '{enabled_modules_file_path}'.[/]")
        raise typer.Exit(code=1)

async def _clean_tables_module_async_internal(module_name: str, loader: Any, called_from_uninstall: bool = False) -> bool:
    if not called_from_uninstall:
        console.print(Panel(f"[bold red]УДАЛЕНИЕ ТАБЛИЦ МОДУЛЯ: {module_name}[/]", expand=False, border_style="red"))

    module_info = loader.get_module_info(module_name)
    if not module_info: # Манифест может отсутствовать у системного модуля
        console.print(f"[bold red]Ошибка: Модуль '{module_name}' не найден.[/]")
        return False
        
    if not module_info.manifest:
         console.print(f"[yellow]Модуль '{module_name}' не имеет манифеста. Невозможно определить таблицы для удаления.[/yellow]")
         return True # Считаем успешным, так как нечего удалять

    model_definitions_paths = module_info.manifest.model_definitions
    if not model_definitions_paths:
        console.print(f"[yellow]Модуль '{module_name}' не декларирует модели в манифесте ('model_definitions'). Удаление таблиц не требуется.[/]")
        return True

    if not called_from_uninstall:
        console.print(f"Модуль '{module_name}' декларирует следующие пути к моделям для удаления таблиц:")
        for path_str in model_definitions_paths: console.print(f"  - {path_str}")
        if not confirm_action(f"Вы АБСОЛЮТНО уверены, что хотите УДАЛИТЬ таблицы для моделей модуля '{module_name}'? Это [bold red]НЕОБРАТИМО[/]!", default_choice=False, abort_on_false=True):
            return False

    models_to_drop: List[Type[SDBBaseAlchemyModel]] = []
    failed_imports: List[str] = []
    console.print(f"\nИмпорт классов моделей для '{module_name}'...")

    # Определяем базовый путь для импорта в зависимости от типа модуля
    # Это важно, так как model_definitions в манифесте могут быть относительными (хотя рекомендуется полные)
    # Но для простоты, пока ожидаем полные пути типа "modules.my_plugin.models.MyTable"
    # или "core.sys_modules.my_sys_mod.models.SysTable"
    
    for import_path_str in model_definitions_paths:
        try:
            # Проверяем, есть ли точка в пути, иначе это не путь для импорта
            if '.' not in import_path_str:
                failed_imports.append(import_path_str)
                console.print(f"  [yellow]Предупреждение:[/yellow] '{import_path_str}' не является корректным путем для импорта Python-модели.")
                continue

            module_path_part, class_name = import_path_str.rsplit('.', 1)
            imported_py_module = importlib.import_module(module_path_part)
            model_class_obj = getattr(imported_py_module, class_name) # Получаем сам объект класса

            # Проверяем, что это действительно класс и он наследуется от SDBBaseAlchemyModel
            if isinstance(model_class_obj, type) and issubclass(model_class_obj, SDBBaseAlchemyModel) and hasattr(model_class_obj, '__table__'):
                models_to_drop.append(model_class_obj) # Добавляем класс, а не экземпляр
                console.print(f"  [green]Успех:[/green] {import_path_str} (таблица: {model_class_obj.__tablename__})")
            else:
                failed_imports.append(import_path_str)
                console.print(f"  [yellow]Предупреждение:[/yellow] '{import_path_str}' не является корректной моделью SQLAlchemy, наследуемой от SDBBaseModel.")
        except Exception as e_import:
            failed_imports.append(import_path_str)
            console.print(f"  [red]Ошибка импорта для '{import_path_str}':[/red] {type(e_import).__name__} - {e_import}")

    if failed_imports:
        console.print(f"\n[bold yellow]Не удалось импортировать {len(failed_imports)} из {len(model_definitions_paths)} объявленных моделей для '{module_name}'.[/]")
        if not models_to_drop: # Если ВООБЩЕ ничего не удалось импортировать
            console.print("[bold red]Нет успешно импортированных моделей. Операция удаления таблиц прервана.[/]")
            return False
        # Если часть импортировалась, а часть нет - спрашиваем, продолжать ли с тем, что есть
        if not called_from_uninstall and not confirm_action(f"Продолжить удаление таблиц для {len(models_to_drop)} успешно импортированных моделей?", default_choice=False, abort_on_false=True):
            return False
        elif called_from_uninstall: # Если это часть деинсталляции, то лучше не продолжать с частичным удалением
            console.print("[bold yellow]Из-за ошибок импорта моделей, автоматическое удаление таблиц при деинсталляции не будет выполнено. "
                          "Удалите таблицы вручную, если это необходимо.[/]")
            return False # Сигнализируем, что удаление данных не было полным/успешным

    if not models_to_drop: # Если список пуст после всех проверок
        console.print(f"[bold yellow]Нет валидных моделей для удаления таблиц для модуля '{module_name}'.[/]")
        return True # Считаем успешным, так как нечего было удалять

    if not called_from_uninstall: # Дополнительное подтверждение, если это не часть uninstall
        console.print("\n[bold blue]Следующие таблицы SQLAlchemy будут удалены из БД:[/]")
        for model_cls_to_drop in models_to_drop: console.print(f"  - [cyan]{model_cls_to_drop.__tablename__}[/cyan]")
        if not confirm_action(f"ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ: Удалить {len(models_to_drop)} таблиц для '{module_name}'?", default_choice=False, abort_on_false=True):
            return False

    settings_obj, db_m, _ = await get_sdb_services_for_cli(init_db=True)
    if not (settings_obj and db_m):
        console.print("[bold red]Не удалось инициализировать DBManager для удаления таблиц.[/]")
        return False
    try:
        console.print(f"\n[magenta]Удаление таблиц для '{module_name}'...[/magenta]")
        await db_m.drop_specific_module_tables(models_to_drop) # Передаем список КЛАССОВ моделей
        console.print(f"[bold green]Таблицы для '{module_name}' успешно удалены.[/]")
        if not called_from_uninstall:
            console.print("[yellow]Примечание: Alembic не знает об этом удалении. "
                          "Если вы планируете использовать миграции для этих таблиц в будущем, "
                          "вам может потребоваться создать новую ревизию или 'заштамповать' состояние Alembic.[/yellow]")
        return True
    except Exception as e_drop:
        console.print(f"[bold red]Ошибка при удалении таблиц для '{module_name}': {e_drop}[/]")
        return False
    finally:
        if db_m: await db_m.dispose()

@module_app.command(name="clean-tables", help="[ОПАСНО] Удалить таблицы модуля из БД (согласно manifest).")
def clean_tables_module_cmd_wrapper(module_name: str = typer.Argument(..., help="Имя модуля, чьи таблицы удалить.")):
    try:
        loader = asyncio.run(_get_module_loader_instance_async())
        if not loader: raise typer.Exit(code=1)
        if not asyncio.run(_clean_tables_module_async_internal(module_name=module_name, loader=loader)):
            raise typer.Exit(code=1)
    except typer.Exit: raise
    except Exception as e:
        console.print(f"[bold red]Ошибка в 'module clean-tables': {e}[/]")
        raise typer.Exit(code=1)

@module_app.command(name="uninstall", help="[ОПАСНО] Удалить модуль (файлы и, опционально, его данные).")
def uninstall_module_cmd_wrapper(
    module_name: str = typer.Argument(..., help="Имя модуля для полного удаления."),
    remove_data: bool = typer.Option(False, "--remove-data/--keep-data",
                                   help="Удалить ли данные модуля (таблицы БД). По умолчанию ДАННЫЕ СОХРАНЯЮТСЯ.")
):
    try:
        asyncio.run(_uninstall_module_async(module_name=module_name, remove_data=remove_data))
    except typer.Exit: raise
    except Exception as e:
        console.print(f"[bold red]Неожиданная ошибка в команде 'module uninstall': {e}[/]")
        raise typer.Exit(code=1)

async def _uninstall_module_async(module_name: str, remove_data: bool):
    console.print(Panel(f"[bold red]УДАЛЕНИЕ МОДУЛЯ: {module_name}[/]", expand=False, border_style="red"))

    loader = await _get_module_loader_instance_async()
    if not loader: raise typer.Exit(code=1)

    module_info = loader.get_module_info(module_name)
    if not module_info:
        console.print(f"[bold red]Ошибка: Модуль '{module_name}' не найден. Невозможно удалить.[/]")
        raise typer.Exit(code=1)

    if module_info.is_system_module:
        console.print(f"[bold red]Ошибка: Системный модуль ('{module_name}') не может быть удален через эту команду.[/]")
        raise typer.Exit(code=1)

    console.print(f"Путь к директории плагина для удаления: [cyan]{module_info.path}[/]")
    if not confirm_action(f"Вы уверены, что хотите УДАЛИТЬ ФАЙЛЫ плагина '{module_name}'?", default_choice=False, abort_on_false=True):
        return

    data_cleaned_successfully = True # По умолчанию, если удаление данных не требуется
    if remove_data:
        console.print(f"\nЗапрошено удаление данных для плагина '{module_name}'.")
        # Проверяем, есть ли что удалять (декларированы ли модели)
        if module_info.manifest and module_info.manifest.model_definitions:
            if confirm_action(f"Удаление данных плагина '{module_name}' приведет к [bold red]ПОТЕРЕ ВСЕХ ЕГО ТАБЛИЦ В БД[/]. Продолжить?", default_choice=False, abort_on_false=True):
                data_cleaned_successfully = await _clean_tables_module_async_internal(module_name, loader, called_from_uninstall=True)
                if not data_cleaned_successfully:
                    console.print(f"[bold red]Произошла ошибка при удалении данных плагина '{module_name}'.[/]")
                    if not confirm_action("Продолжить удаление файлов плагина, несмотря на ошибку удаления данных?", default_choice=False, abort_on_false=True):
                        console.print("[bold yellow]Удаление плагина полностью отменено.[/bold yellow]")
                        raise typer.Exit(code=1)
            else: # Пользователь отказался удалять данные
                data_cleaned_successfully = False # Данные не удалены по решению пользователя
                console.print("[yellow]Удаление данных отменено. Файлы плагина все еще будут удалены (если подтверждено).[/yellow]")
        else: # Нет моделей в манифесте
             console.print(f"[dim]Плагин '{module_name}' не декларирует модели в манифесте. Удаление данных (таблиц) не требуется.[/dim]")
             # data_cleaned_successfully остается True
    else:
        console.print(f"\n[yellow]Данные плагина '{module_name}' (таблицы БД) не будут удалены (опция --keep-data).[/yellow]")
        data_cleaned_successfully = False # Данные не удалялись

    console.print(f"\nДеактивация плагина '{module_name}' (удаление из enabled_modules.json)...")
    enabled_modules_file_path = loader._settings.core.enabled_modules_config_path
    if module_name in loader.enabled_plugin_names:
        new_enabled_list = [m for m in loader.enabled_plugin_names if m != module_name]
        if _save_enabled_modules(new_enabled_list, enabled_modules_file_path):
            console.print(f"[green]Плагин '{module_name}' успешно деактивирован.[/]")
        else:
            console.print(f"[bold red]Ошибка деактивации плагина '{module_name}' (не удалось сохранить enabled_modules.json).[/]")
            if not confirm_action("Продолжить удаление файлов плагина, несмотря на ошибку деактивации?", default_choice=False, abort_on_false=True):
                console.print("[bold yellow]Удаление плагина полностью отменено.[/bold yellow]")
                raise typer.Exit(code=1)
    else:
        console.print(f"[dim]Плагин '{module_name}' не был активен.[/dim]")

    module_dir_path = module_info.path
    console.print(f"\nУдаление директории плагина: [cyan]{module_dir_path}[/]")
    if not confirm_action(f"[bold red]ПОСЛЕДНЕЕ ПРЕДУПРЕЖДЕНИЕ: Удалить директорию '{module_dir_path}'? Это НЕОБРАТИМО.[/bold red]", default_choice=False, abort_on_false=True):
        return

    try:
        shutil.rmtree(module_dir_path)
        console.print(f"[bold green]Директория плагина '{module_dir_path}' успешно удалена.[/]")
    except Exception as e_rmtree:
        console.print(f"[bold red]Ошибка при удалении директории '{module_dir_path}': {e_rmtree}[/]")
        raise typer.Exit(code=1)

    console.print(f"\n[bold green]Плагин '{module_name}' успешно удален.[/]")
    if remove_data and not data_cleaned_successfully: # Если запрашивали удаление данных, но оно не удалось
         console.print("[bold yellow]Однако, при удалении данных плагина (таблиц) возникли проблемы или операция была отменена.[/bold yellow]")
    elif not remove_data: # Если не запрашивали удаление данных
        console.print("[dim](Данные плагина не удалялись).[/dim]")
    console.print("Перезапустите бота, чтобы изменения вступили в силу.")

SHOP_COMMANDS_WIP_MSG = "[yellow]Эта команда для 'магазина' модулей находится в разработке и пока не реализована.[/]"
SYNC_DEPS_WIP_MSG = """
[yellow]Команда 'module sync-deps' находится в разработке.[/]
[yellow]Планируется интеграция с `pip-tools` для сбора и компиляции зависимостей из манифестов активных модулей.[/]
"""
@module_app.command(name="list-available", help="Показать модули, доступные в репозитории (НЕ РЕАЛИЗОВАНО).")
def list_available_modules_cmd(): console.print(SHOP_COMMANDS_WIP_MSG)
@module_app.command(name="install", help="Установить модуль из репозитория (НЕ РЕАЛИЗОВАНО).")
def install_module_cmd(module_name: str = typer.Argument(..., help="Имя модуля для установки.")): console.print(SHOP_COMMANDS_WIP_MSG)
@module_app.command(name="update", help="Обновить модуль из репозитория (НЕ РEАЛИЗОВАНО).")
def update_module_cmd(module_name: str = typer.Argument(..., help="Имя модуля для обновления, или '--all'."), force: bool = typer.Option(False, "--force", help="Принудительное обновление.")): console.print(SHOP_COMMANDS_WIP_MSG)
@module_app.command(name="sync-deps", help="Собрать Python-зависимости модулей (НЕ РЕАЛИЗОВАНО).")
def sync_deps_cmd(): console.print(SYNC_DEPS_WIP_MSG)

if __name__ == "__main__":
    module_app()


======================================================================

------------------------------ FILE: cli_commands/user_cmd.py ------------------------------
# cli_commands/user_cmd.py


import typer
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text # Для более гибкого форматирования текста
import asyncio
from typing import Optional, List, Any, Tuple

from .cli_utils import get_sdb_services_for_cli # Наша утилита

console = Console()
user_app = typer.Typer(
    name="user",
    help="👤 Управление пользователями SDB и их ролями (RBAC).",
    rich_markup_mode="rich",
    no_args_is_help=True  # <--- ДОБАВЛЕНО
)

# --- Асинхронная логика команд ---

async def _list_users_cmd_async(limit: int, offset: int, sort_by: str, sort_desc: bool):
    panel_title = "[bold blue]Список пользователей SwiftDevBot[/]"
    settings, db_m, _ = None, None, None # rbac_s здесь не нужен для простого списка
    try:
        settings, db_m, _ = await get_sdb_services_for_cli(init_db=True, init_rbac=False)
        if not (settings and db_m):
            console.print("[bold red]Ошибка: Не удалось инициализировать DBManager для команды 'user list'.[/]")
            raise typer.Exit(code=1)

        async with db_m.get_session() as session:
            from core.database.core_models import User
            from sqlalchemy import select, func as sql_func, desc, asc
            from sqlalchemy.orm import selectinload

            count_stmt = select(sql_func.count(User.id))
            total_users_result = await session.execute(count_stmt)
            total_users = total_users_result.scalar_one_or_none() or 0

            if total_users == 0:
                console.print(Panel("[yellow]В базе данных нет зарегистрированных пользователей.[/yellow]", title=panel_title))
                return

            # Логика сортировки
            order_column = getattr(User, sort_by, User.id) # Дефолт по id, если атрибут не найден
            order_expression = desc(order_column) if sort_desc else asc(order_column)

            stmt = (
                select(User)
                .options(selectinload(User.roles))
                .order_by(order_expression)
                .limit(limit)
                .offset(offset)
            )
            result = await session.execute(stmt)
            users: List[User] = list(result.scalars().all())

            if not users and total_users > 0 : # Если есть пользователи, но не на этой странице
                console.print(Panel(
                    f"[yellow]На этой странице (смещение {offset}, лимит {limit}) пользователей нет, но всего в БД: {total_users}.[/yellow]",
                    title=panel_title
                ))
                return
            elif not users: # Это условие уже покрыто выше, но для ясности
                console.print(Panel("[yellow]В базе данных нет зарегистрированных пользователей.[/yellow]", title=panel_title))
                return


            table_title = f"Пользователи SDB (Показано: {len(users)} из {total_users}, Лимит: {limit}, Смещение: {offset}, Сортировка: {sort_by} {'DESC' if sort_desc else 'ASC'})"
            table = Table(title=table_title, show_header=True, header_style="bold magenta", expand=True)
            table.add_column("DB ID", style="dim cyan", justify="right", no_wrap=True)
            table.add_column("TG ID", style="cyan", justify="right", no_wrap=True)
            table.add_column("Полное Имя", min_width=20)
            table.add_column("Username", style="yellow", no_wrap=True)
            table.add_column("Роли", min_width=15)
            table.add_column("Язык", justify="center", no_wrap=True)
            table.add_column("Активен", justify="center", no_wrap=True)
            table.add_column("Бот блок.", justify="center", no_wrap=True)
            table.add_column("Регистрация", no_wrap=True)
            table.add_column("Активность", no_wrap=True)

            for user_obj in users:
                roles_str = ", ".join(sorted([role.name for role in user_obj.roles])) if user_obj.roles else "-"
                active_str = "✅" if user_obj.is_active else "❌"
                blocked_str = "🚫" if user_obj.is_bot_blocked else "✅"
                created_at_str = user_obj.created_at.strftime('%Y-%m-%d %H:%M') if user_obj.created_at else "-"
                last_activity_str = user_obj.last_activity_at.strftime('%Y-%m-%d %H:%M') if user_obj.last_activity_at else "-"

                table.add_row(
                    str(user_obj.id), str(user_obj.telegram_id), user_obj.full_name,
                    f"@{user_obj.username}" if user_obj.username else "-",
                    roles_str,
                    user_obj.preferred_language_code or "-",
                    active_str,
                    blocked_str,
                    created_at_str,
                    last_activity_str
                )
            console.print(Panel(table, title=panel_title, border_style="blue", padding=(1,1)))
    finally:
        if db_m: await db_m.dispose()

async def _find_user_interactive(session: Any, identifier: str) -> Optional[Any]: # User
    """Интерактивный поиск пользователя по ID или username."""
    from core.database.core_models import User
    from sqlalchemy import select
    from sqlalchemy.orm import selectinload

    user: Optional[User] = None
    if identifier.isdigit():
        user_id_int = int(identifier)
        stmt = select(User).options(selectinload(User.roles)).where(User.telegram_id == user_id_int)
        result = await session.execute(stmt)
        user = result.scalars().first()
        if user: return user
        # Если не нашли по TG ID, попробуем по DB ID
        stmt_db_id = select(User).options(selectinload(User.roles)).where(User.id == user_id_int)
        result_db_id = await session.execute(stmt_db_id)
        user = result_db_id.scalars().first()
        if user: return user

    # Если не число или не найдено по ID, ищем по username (без @)
    username_to_search = identifier.lstrip('@')
    stmt_uname = select(User).options(selectinload(User.roles)).where(User.username_lower == username_to_search.lower())
    # Предполагая, что у тебя есть колонка username_lower или ты используешь ILIKE для PostgreSQL/других БД
    # Для SQLite это будет WHERE lower(username) = lower(:username_to_search)
    # Чтобы это работало кросс-СУБД без ILIKE, лучше иметь отдельное поле username_lower или делать lower() в запросе
    # stmt_uname = select(User).options(selectinload(User.roles)).where(func.lower(User.username) == username_to_search.lower())
    result_uname = await session.execute(stmt_uname)
    user = result_uname.scalars().first()
    return user


async def _info_user_cmd_async(user_identifier: str):
    settings, db_m, _ = None, None, None # rbac_s здесь не нужен для инфо
    try:
        settings, db_m, _ = await get_sdb_services_for_cli(init_db=True, init_rbac=False)
        if not (settings and db_m):
            console.print("[bold red]Ошибка: Не удалось инициализировать DBManager для команды 'user info'.[/]")
            raise typer.Exit(code=1)

        async with db_m.get_session() as session:
            user = await _find_user_interactive(session, user_identifier)

            if not user:
                console.print(f"[bold red]Ошибка: Пользователь с идентификатором '{user_identifier}' не найден в базе данных.[/]")
                raise typer.Exit(code=1)
            
            panel_title = f"[bold blue]Информация о пользователе: {user.full_name} (TG ID: {user.telegram_id})[/]"
            info_text = Text()
            info_text.append(f"DB ID: {user.id}\n", style="bold")
            info_text.append(f"Telegram ID: {user.telegram_id}\n", style="bold")
            info_text.append(f"Полное имя: {user.full_name}\n")
            info_text.append(f"Username: @{user.username}\n" if user.username else "Username: -\n")
            info_text.append(f"Язык бота: {user.preferred_language_code or '(не установлен)'}\n")
            info_text.append(f"Активен в системе: {'Да ✅' if user.is_active else 'Нет ❌'}\n")
            info_text.append(f"Бот заблокирован: {'Да 🚫' if user.is_bot_blocked else 'Нет ✅'}\n")
            created_at_str = user.created_at.strftime('%Y-%m-%d %H:%M:%S %Z') if user.created_at and user.created_at.tzinfo else (user.created_at.strftime('%Y-%m-%d %H:%M:%S') if user.created_at else '-')
            updated_at_str = user.updated_at.strftime('%Y-%m-%d %H:%M:%S %Z') if user.updated_at and user.updated_at.tzinfo else (user.updated_at.strftime('%Y-%m-%d %H:%M:%S') if user.updated_at else '-')
            last_activity_str = user.last_activity_at.strftime('%Y-%m-%d %H:%M:%S %Z') if user.last_activity_at and user.last_activity_at.tzinfo else (user.last_activity_at.strftime('%Y-%m-%d %H:%M:%S') if user.last_activity_at else ' (нет данных)')
            info_text.append(f"Дата регистрации: {created_at_str}\n")
            info_text.append(f"Последнее обновление: {updated_at_str}\n")
            info_text.append(f"Последняя активность: {last_activity_str}\n")
            roles_str = ", ".join(sorted([role.name for role in user.roles])) if user.roles else " (нет назначенных ролей)"
            info_text.append(f"Роли пользователя: {roles_str}\n", style="bold")
            
            console.print(Panel(info_text, title=panel_title, border_style="blue", padding=1))
    finally:
        if db_m: await db_m.dispose()

async def _list_roles_cmd_async():
    panel_title = "[bold blue]Список всех ролей в системе SDB[/]"
    settings, db_m, rbac_s = None, None, None
    try:
        settings, db_m, rbac_s = await get_sdb_services_for_cli(init_db=True, init_rbac=True)
        if not (settings and db_m and rbac_s):
            console.print("[bold red]Ошибка: Не удалось инициализировать DBManager и RBACService для команды 'user roles'.[/]")
            raise typer.Exit(code=1)

        async with db_m.get_session() as session:
            from core.database.core_models import Role # Role уже импортирована в RBACService
            all_roles: List[Role] = await rbac_s.get_all_roles(session)

            if not all_roles:
                console.print(Panel("[yellow]В системе нет определенных ролей.[/yellow]", title=panel_title))
                return

            table = Table(title="Системные роли SDB", show_header=True, header_style="bold magenta", expand=True)
            table.add_column("DB ID", style="dim cyan", justify="right", no_wrap=True)
            table.add_column("Имя Роли", style="cyan", min_width=15)
            table.add_column("Описание", min_width=30, max_width=70, overflow="fold")
            
            for role_obj in all_roles:
                table.add_row(
                    str(role_obj.id), role_obj.name,
                    role_obj.description if role_obj.description else "-"
                )
            console.print(Panel(table, title=panel_title, border_style="blue", padding=(1,1)))
    finally:
        if db_m: await db_m.dispose()

async def _assign_role_cmd_async(user_identifier: str, role_name: str):
    console.print(f"Попытка назначить роль [cyan]'{role_name}'[/] пользователю [cyan]'{user_identifier}'[/]...")
    settings, db_m, rbac_s = None, None, None
    try:
        settings, db_m, rbac_s = await get_sdb_services_for_cli(init_db=True, init_rbac=True)
        if not (settings and db_m and rbac_s):
            console.print("[bold red]Ошибка: Не удалось инициализировать сервисы для 'user assign-role'.[/]")
            raise typer.Exit(code=1)

        async with db_m.get_session() as session:
            user_obj = await _find_user_interactive(session, user_identifier)
            if not user_obj:
                console.print(f"[bold red]Ошибка: Пользователь '{user_identifier}' не найден.[/]")
                raise typer.Exit(code=1)
            
            if await rbac_s.assign_role_to_user(session, user_obj, role_name):
                await session.commit()
                console.print(f"[bold green]Роль '{role_name}' успешно назначена пользователю {user_obj.telegram_id} (@{user_obj.username}).[/]")
            else:
                # RBACService должен был залогировать детали
                console.print(f"[bold red]Не удалось назначить роль '{role_name}' пользователю {user_obj.telegram_id}. "
                              "Возможно, роль не существует или уже назначена (см. логи).[/]")
                # Не будем делать rollback здесь, так как assign_role_to_user мог добавить роль в сессию, но не UserRole
                raise typer.Exit(code=1)
    finally:
        if db_m: await db_m.dispose()

async def _remove_role_cmd_async(user_identifier: str, role_name: str):
    console.print(f"Попытка снять роль [cyan]'{role_name}'[/] с пользователя [cyan]'{user_identifier}'[/]...")
    settings, db_m, rbac_s = None, None, None
    try:
        settings, db_m, rbac_s = await get_sdb_services_for_cli(init_db=True, init_rbac=True)
        if not (settings and db_m and rbac_s):
            console.print("[bold red]Ошибка: Не удалось инициализировать сервисы для 'user remove-role'.[/]")
            raise typer.Exit(code=1)

        async with db_m.get_session() as session:
            user_obj = await _find_user_interactive(session, user_identifier)
            if not user_obj:
                console.print(f"[bold red]Ошибка: Пользователь '{user_identifier}' не найден.[/]")
                raise typer.Exit(code=1)

            if await rbac_s.remove_role_from_user(session, user_obj, role_name):
                await session.commit()
                console.print(f"[bold green]Роль '{role_name}' успешно снята с пользователя {user_obj.telegram_id} (@{user_obj.username}).[/]")
            else:
                console.print(f"[bold red]Не удалось снять роль '{role_name}' с пользователя {user_obj.telegram_id}. "
                              "Возможно, роль не была назначена (см. логи).[/]")
                raise typer.Exit(code=1)
    finally:
        if db_m: await db_m.dispose()


# --- Синхронные обертки для Typer ---

@user_app.command(name="list", help="Показать список всех пользователей SDB из базы данных.")
def list_users_cmd_wrapper(
    limit: int = typer.Option(20, "--limit", "-l", help="Максимальное количество пользователей для отображения.", min=1, max=200),
    offset: int = typer.Option(0, "--offset", "-o", help="Смещение для пагинации списка пользователей.", min=0),
    sort_by: str = typer.Option("id", "--sort-by", help="Поле для сортировки (id, telegram_id, username, first_name, last_name, created_at, last_activity_at).", case_sensitive=False),
    desc: bool = typer.Option(False, "--desc", help="Сортировать по убыванию.")
):
    valid_sort_fields = ["id", "telegram_id", "username", "first_name", "last_name", "created_at", "last_activity_at"]
    if sort_by.lower() not in valid_sort_fields:
        console.print(f"[bold red]Ошибка: Недопустимое значение для --sort-by: '{sort_by}'.[/]")
        console.print(f"Допустимые значения: {', '.join(valid_sort_fields)}")
        raise typer.Exit(code=1)
    try:
        asyncio.run(_list_users_cmd_async(limit=limit, offset=offset, sort_by=sort_by.lower(), sort_desc=desc))
    except Exception as e:
        console.print(f"[bold red]Ошибка выполнения команды 'user list': {type(e).__name__} - {e}[/]")
        # console.print_exception(show_locals=True) # для отладки
        raise typer.Exit(code=1)

@user_app.command(name="info", help="Показать детальную информацию о пользователе по его Telegram ID, DB ID или Username.")
def info_user_cmd_wrapper(user_identifier: str = typer.Argument(..., help="Telegram ID, DB ID или Username (@ник) пользователя.")):
    try:
        asyncio.run(_info_user_cmd_async(user_identifier=user_identifier))
    except typer.Exit: # Пробрасываем Exit, если пользователь не найден
        raise
    except Exception as e:
        console.print(f"[bold red]Ошибка выполнения команды 'user info': {type(e).__name__} - {e}[/]")
        raise typer.Exit(code=1)

@user_app.command(name="roles", help="Показать список всех доступных ролей в системе.")
def list_roles_cmd_wrapper():
    try:
        asyncio.run(_list_roles_cmd_async())
    except Exception as e:
        console.print(f"[bold red]Ошибка выполнения команды 'user roles': {type(e).__name__} - {e}[/]")
        raise typer.Exit(code=1)

@user_app.command(name="assign-role", help="Назначить роль пользователю.")
def assign_role_cmd_wrapper(
    user_identifier: str = typer.Argument(..., help="Telegram ID, DB ID или Username (@ник) пользователя."),
    role_name: str = typer.Argument(..., help="Имя роли для назначения (например, 'Admin', 'User').")
):
    try:
        asyncio.run(_assign_role_cmd_async(user_identifier=user_identifier, role_name=role_name))
    except typer.Exit: raise
    except Exception as e:
        # Сообщение об ошибке уже должно быть в _assign_role_cmd_async
        raise typer.Exit(code=1)

@user_app.command(name="remove-role", help="Снять роль с пользователя.")
def remove_role_cmd_wrapper(
    user_identifier: str = typer.Argument(..., help="Telegram ID, DB ID или Username (@ник) пользователя."),
    role_name: str = typer.Argument(..., help="Имя роли для снятия.")
):
    try:
        asyncio.run(_remove_role_cmd_async(user_identifier=user_identifier, role_name=role_name))
    except typer.Exit: raise
    except Exception as e:
        raise typer.Exit(code=1)


======================================================================

------------------------------ FILE: cli_commands/__init__.py ------------------------------
# cli_commands/__init__.py
# Делает cli_commands пакетом


======================================================================

------------------------------ FILE: core/services_provider.py ------------------------------
# core/services_provider.py

from typing import Optional, TYPE_CHECKING

from loguru import logger as global_logger 

if TYPE_CHECKING:
    from core.app_settings import AppSettings
    from core.database.manager import DBManager
    from core.cache.manager import CacheManager
    from core.http_client.manager import HTTPClientManager
    from core.module_loader import ModuleLoader
    from core.events.dispatcher import EventDispatcher
    from core.ui.registry_ui import UIRegistry
    from core.rbac.service import RBACService
    from core.users.service import UserService


class BotServicesProvider:
    def __init__(self, settings: 'AppSettings'):
        self._settings: 'AppSettings' = settings
        self._logger = global_logger.bind(service="BotServicesProvider")

        self._db_manager: Optional['DBManager'] = None
        self._cache_manager: Optional['CacheManager'] = None
        self._http_client_manager: Optional['HTTPClientManager'] = None
        self._module_loader: Optional['ModuleLoader'] = None
        self._event_dispatcher: Optional['EventDispatcher'] = None
        self._ui_registry: Optional['UIRegistry'] = None
        self._rbac_service: Optional['RBACService'] = None
        self._user_service: Optional['UserService'] = None

        self._logger.info(f"BotServicesProvider создан (версия SDB: {settings.core.sdb_version}). Ожидает настройки сервисов.")

    async def setup_services(self) -> None:
        self._logger.info("Начало асинхронной настройки основных сервисов SDB...")
        
        from core.database.manager import DBManager 
        try:
            self._db_manager = DBManager(db_settings=self._settings.db, app_settings=self._settings)
            await self._db_manager.initialize() 
            self._logger.success("Сервис DBManager успешно настроен.")
        except Exception as e:
            self._logger.critical(f"КРИТИЧЕСКАЯ ОШИБКА настройки DBManager: {e}", exc_info=True)
            raise

        # Сначала инициализируем ModuleLoader, так как RBACService может от него зависеть для получения разрешений модулей
        from core.module_loader import ModuleLoader 
        try:
            self._module_loader = ModuleLoader(settings=self._settings, services_provider=self)
            self._module_loader.scan_all_available_modules() 
            self._module_loader._load_enabled_plugin_names() 
            self._logger.success(f"Сервис ModuleLoader инициализирован (найдено {len(self._module_loader.available_modules)} модулей, "
                                 f"активно плагинов {len(self._module_loader.enabled_plugin_names)}).")
        except Exception as e_mod_load:
            self._logger.critical(f"КРИТИЧЕСКАЯ ОШИБКА инициализации ModuleLoader: {e_mod_load}", exc_info=True)
            raise 

        from core.rbac.service import RBACService 
        try:
            # Передаем self (BotServicesProvider) в RBACService
            self._rbac_service = RBACService(services=self) # <--- ИЗМЕНЕНИЕ ЗДЕСЬ
            if self._db_manager and self._rbac_service:
                try:
                    async with self._db_manager.get_session() as db_session:
                        # Вызываем ensure_default_entities_exist
                        roles_c, core_perms_c, mod_perms_c = await self._rbac_service.ensure_default_entities_exist(db_session) # <--- ИЗМЕНЕНИЕ ЗДЕСЬ
                        self._logger.info(f"RBACService.ensure_default_entities_exist отработал. "
                                          f"Ролей создано: {roles_c}, Разрешений ядра: {core_perms_c}, Разрешений модулей: {mod_perms_c}")
                except Exception as e_roles:
                    self._logger.error(f"Критическая ошибка при создании/проверке стандартных RBAC сущностей: {e_roles}", exc_info=True)
            self._logger.success("Сервис RBACService успешно настроен.")
        except ValueError as e_rbac_val: # Например, если DBManager не был передан
            self._logger.error(f"Ошибка инициализации RBACService (возможно, проблема с DBManager или ModuleLoader): {e_rbac_val}")
            self._rbac_service = None
        except Exception as e_rbac:
            self._logger.error(f"Не удалось настроить RBACService: {e_rbac}", exc_info=True)
            self._rbac_service = None 

        from core.users.service import UserService
        try:
            self._user_service = UserService(services_provider=self) 
            self._logger.success("Сервис UserService успешно настроен.")
        except Exception as e_user_svc:
            self._logger.error(f"Не удалось настроить UserService: {e_user_svc}", exc_info=True)
            self._user_service = None
        
        from core.cache.manager import CacheManager 
        try:
            self._cache_manager = CacheManager(cache_settings=self._settings.cache)
            await self._cache_manager.initialize()
            if self._cache_manager.is_available():
                 self._logger.success(f"Сервис CacheManager ({self._settings.cache.type}) успешно настроен.")
            else:
                 self._logger.warning(f"CacheManager ({self._settings.cache.type}) инициализирован, но кэш недоступен.")
        except ImportError as e_cache_imp: 
             self._logger.warning(f"Не удалось инициализировать CacheManager: {e_cache_imp}")
        except Exception as e_cache:
            self._logger.error(f"Ошибка настройки CacheManager: {e_cache}", exc_info=True)
            self._cache_manager = None

        from core.http_client.manager import HTTPClientManager 
        try:
            self._http_client_manager = HTTPClientManager(app_settings=self._settings) 
            await self._http_client_manager.initialize()
            if self._http_client_manager.is_available():
                self._logger.success("Сервис HTTPClientManager успешно настроен.")
            else:
                self._logger.warning("HTTPClientManager инициализирован, но HTTP-клиент недоступен.")
        except ImportError as e_http_imp: 
            self._logger.warning(f"Не удалось инициализировать HTTPClientManager: {e_http_imp}")
        except Exception as e_http:
            self._logger.error(f"Ошибка настройки HTTPClientManager: {e_http}", exc_info=True)
            self._http_client_manager = None

        from core.events.dispatcher import EventDispatcher 
        try:
            self._event_dispatcher = EventDispatcher()
            self._logger.success("Сервис EventDispatcher успешно инициализирован.")
        except Exception as e_event:
            self._logger.error(f"Ошибка инициализации EventDispatcher: {e_event}", exc_info=True)
            self._event_dispatcher = None

        from core.ui.registry_ui import UIRegistry 
        try:
            self._ui_registry = UIRegistry()
            self._logger.success("Сервис UIRegistry успешно инициализирован.")
        except Exception as e_ui_reg:
            self._logger.error(f"Ошибка инициализации UIRegistry: {e_ui_reg}", exc_info=True)
            self._ui_registry = None
        
        # ModuleLoader уже инициализирован выше

        self._logger.info("✅ Первичная настройка всех основных сервисов SDB завершена.")


    async def close_services(self) -> None:
        self._logger.info("Начало процедуры закрытия и освобождения ресурсов сервисов SDB...")
        
        if self._module_loader: self._logger.debug("ModuleLoader не требует специального dispose().")
        if self._ui_registry:
            try: await self._ui_registry.dispose(); self._logger.info("UIRegistry ресурсы освобождены.")
            except Exception as e: self._logger.error(f"Ошибка при освобождении UIRegistry: {e}", exc_info=True)
        if self._event_dispatcher:
            try: await self._event_dispatcher.dispose(); self._logger.info("EventDispatcher ресурсы освобождены.")
            except Exception as e: self._logger.error(f"Ошибка при освобождении EventDispatcher: {e}", exc_info=True)
        if self._http_client_manager:
            try: await self._http_client_manager.dispose(); self._logger.info("HTTPClientManager ресурсы освобождены.")
            except Exception as e: self._logger.error(f"Ошибка при освобождении HTTPClientManager: {e}", exc_info=True)
        if self._cache_manager:
            try: await self._cache_manager.dispose(); self._logger.info("CacheManager ресурсы освобождены.")
            except Exception as e: self._logger.error(f"Ошибка при освобождении CacheManager: {e}", exc_info=True)
        
        if self._user_service: self._logger.debug("UserService не требует специального dispose().")
        if self._rbac_service: self._logger.debug("RBACService не требует специального dispose().")
        
        if self._db_manager:
            try: await self._db_manager.dispose(); self._logger.info("DBManager ресурсы освобождены.")
            except Exception as e: self._logger.error(f"Ошибка при освобождении DBManager: {e}", exc_info=True)
        
        self._logger.info("🏁 Процедура закрытия всех сервисов SDB завершена.")
    
    @property
    def config(self) -> 'AppSettings':
        return self._settings

    @property
    def logger(self):
        return global_logger 

    @property
    def db(self) -> 'DBManager':
        if self._db_manager is None:
            msg = "DBManager не инициализирован! Обращение к БД невозможно."
            self._logger.critical(msg)
            raise RuntimeError(msg)
        return self._db_manager

    @property
    def rbac(self) -> 'RBACService':
        if self._rbac_service is None:
            msg = "RBACService не инициализирован! Функции RBAC будут недоступны."
            self._logger.error(msg) 
            raise AttributeError(msg) 
        return self._rbac_service
    
    @property
    def user_service(self) -> 'UserService':
        if self._user_service is None:
            msg = "UserService не инициализирован! Функции управления пользователями будут недоступны."
            self._logger.error(msg)
            raise AttributeError(msg)
        return self._user_service

    @property
    def cache(self) -> 'CacheManager':
        if self._cache_manager is None or not self._cache_manager.is_available():
            # msg = "CacheManager не инициализирован или кэш недоступен!" # Закомментировано чтобы не спамить, если кэш опционален
            # self._logger.warning(msg)
            raise AttributeError("CacheManager не инициализирован или кэш недоступен! Попытка использовать недоступный кэш.")
        return self._cache_manager

    @property
    def http(self) -> 'HTTPClientManager': 
        if self._http_client_manager is None or not self._http_client_manager.is_available():
            raise AttributeError("HTTPClientManager не инициализирован или HTTP-клиент недоступен! Попытка использовать недоступный HTTP-клиент.")
        return self._http_client_manager

    @property
    def modules(self) -> 'ModuleLoader': 
        if self._module_loader is None:
            msg = "ModuleLoader не инициализирован!" 
            self._logger.critical(msg)
            raise RuntimeError(msg)
        return self._module_loader

    @property
    def events(self) -> 'EventDispatcher':
        if self._event_dispatcher is None:
            msg = "EventDispatcher не инициализирован!"
            self._logger.error(msg) 
            raise AttributeError(msg)
        return self._event_dispatcher
    
    @property
    def ui_registry(self) -> 'UIRegistry':
        if self._ui_registry is None:
            msg = "UIRegistry не инициализирован!"
            self._logger.error(msg)
            raise AttributeError(msg)
        return self._ui_registry


======================================================================

------------------------------ FILE: core/module_loader.py ------------------------------
# core/module_loader.py

import importlib
import importlib.util
import json
import sys
import asyncio
import shutil 
import re 
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Type, Callable, Any, TYPE_CHECKING

import yaml # type: ignore
from aiogram import Dispatcher, Bot
from loguru import logger
from pydantic import ValidationError, BaseModel as PydanticBaseModel

# Добавляем PermissionManifest в импорты
from .schemas.module_manifest import ModuleManifest, SettingManifest, PermissionManifest 

if TYPE_CHECKING:
    from .app_settings import AppSettings, CoreAppSettings
    from .services_provider import BotServicesProvider

MANIFEST_YAML_NAME = "manifest.yaml"
MANIFEST_JSON_NAME = "manifest.json"
MODULE_ENTRY_POINT_FILENAME = "__init__.py"
SETUP_FUNCTION_NAME = "setup_module"
USER_MODULES_SETTINGS_DIR_NAME = "modules_settings"
MODULE_DEFAULT_SETTINGS_FILENAME = "module_settings.yaml" 


class ModuleInfo:
    def __init__(self, name: str, path: Path, manifest: Optional[ModuleManifest] = None, is_enabled: bool = False, error: Optional[str] = None, is_system_module: bool = False):
        self.name: str = name
        self.path: Path = path
        self.manifest: Optional[ModuleManifest] = manifest
        self.is_enabled: bool = is_enabled
        self.is_loaded_successfully: bool = False
        self.error: Optional[str] = error
        self.imported_py_module: Optional[Any] = None
        self.is_system_module: bool = is_system_module
        self.current_settings: Dict[str, Any] = {} 

    def __repr__(self) -> str:
        status_parts = []
        if self.is_system_module: status_parts.append("system")
        if self.is_enabled or self.is_system_module: status_parts.append("active_target")
        if self.is_loaded_successfully: status_parts.append("loaded")
        if self.current_settings: status_parts.append("settings_loaded")
        if self.error: status_parts.append(f"error='{self.error[:30]}...'")
        status_str = ", ".join(status_parts) if status_parts else "discovered"
        return f"<ModuleInfo name='{self.name}' ({status_str})>"

class ModuleLoader:
    def __init__(self, settings: 'AppSettings', services_provider: 'BotServicesProvider'):
        self._settings: 'AppSettings' = settings
        self._services: 'BotServicesProvider' = services_provider
        self._core_settings: 'CoreAppSettings' = self._settings.core
        
        self.plugins_root_dir: Path = settings.core.project_data_path.parent / "modules"
        self.core_sys_modules_root_dir: Path = settings.core.project_data_path.parent / "core" / "sys_modules"
        
        self.user_module_settings_base_path: Path = self._core_settings.project_data_path / "Config" / USER_MODULES_SETTINGS_DIR_NAME
        self.user_module_settings_base_path.mkdir(parents=True, exist_ok=True)

        self.available_modules: Dict[str, ModuleInfo] = {}
        self.enabled_plugin_names: List[str] = []

        self._logger = logger.bind(service="ModuleLoader")
        self._logger.info(f"ModuleLoader инициализирован. "
                          f"Плагины: {self.plugins_root_dir.resolve()}, "
                          f"Системные модули: {self.core_sys_modules_root_dir.resolve()}, "
                          f"Пользовательские настройки модулей: {self.user_module_settings_base_path.resolve()}")

    def _parse_manifest_file(self, module_path: Path, module_name_override: Optional[str] = None) -> Optional[ModuleManifest]:
        yaml_manifest_path = module_path / MANIFEST_YAML_NAME
        json_manifest_path = module_path / MANIFEST_JSON_NAME
        manifest_file_to_parse: Optional[Path] = None
        parser_type: Optional[str] = None

        if yaml_manifest_path.is_file():
            manifest_file_to_parse = yaml_manifest_path
            parser_type = "yaml"
            if json_manifest_path.is_file():
                self._logger.warning(f"В модуле '{module_path.name}' найдены и YAML, и JSON манифесты. Используется YAML.")
        elif json_manifest_path.is_file():
            manifest_file_to_parse = json_manifest_path
            parser_type = "json"
        
        if not manifest_file_to_parse:
            is_plugin = not (module_path.parent.name == "sys_modules" and module_path.parent.parent.name == "core")
            log_func = self._logger.warning if is_plugin else self._logger.debug
            log_func(f"Манифест не найден для модуля '{module_path.name}'.")
            return None
        try:
            with open(manifest_file_to_parse, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f) if parser_type == "yaml" else json.load(f)
            if not data:
                self._logger.error(f"Манифест {manifest_file_to_parse.name} в модуле {module_path.name} пуст."); return None
            
            if module_name_override and 'name' not in data:
                data['name'] = module_name_override
            elif 'name' in data and module_name_override and data['name'] != module_name_override:
                 self._logger.warning(f"Имя модуля в манифесте ('{data['name']}') отличается от имени папки ('{module_name_override}') "
                                      f"для {manifest_file_to_parse.name}. Используется имя из манифеста: '{data['name']}'.")
            
            manifest = ModuleManifest(**data) 
            return manifest
        except Exception as e:
            self._logger.error(f"Ошибка парсинга/валидации манифеста {manifest_file_to_parse.name} в {module_path.name}: {e}", exc_info=True)
        return None

    def _scan_directory_for_modules(self, directory: Path, is_system_dir: bool) -> None:
        if not directory.is_dir():
            self._logger.warning(f"Директория {'системных модулей' if is_system_dir else 'плагинов'} {directory} не найдена.")
            return

        for module_dir_path in directory.iterdir():
            if module_dir_path.is_dir() and not module_dir_path.name.startswith(('.', '_')):
                module_name_from_path = module_dir_path.name
                manifest = self._parse_manifest_file(module_dir_path, module_name_override=module_name_from_path if is_system_dir else None)
                
                actual_module_name = manifest.name if manifest and manifest.name else module_name_from_path
                
                if actual_module_name in self.available_modules:
                    self._logger.warning(f"Дублирующееся имя модуля '{actual_module_name}' (из папки '{module_dir_path.name}', "
                                         f"тип: {'системный' if is_system_dir else 'плагин'}). "
                                         f"Предыдущий модуль с таким именем будет перезаписан в списке доступных.")
                
                module_info = ModuleInfo(
                    name=actual_module_name,
                    path=module_dir_path,
                    manifest=manifest,
                    is_system_module=is_system_dir,
                    is_enabled=is_system_dir 
                )
                
                if manifest and manifest.settings: 
                    self._load_and_validate_module_settings(module_info)

                self.available_modules[actual_module_name] = module_info
                log_msg_type = "системный модуль" if is_system_dir else "плагин"
                log_msg_details = f"v{manifest.version}" if manifest and manifest.version else "без манифеста/версии"
                self._logger.info(f"Найден {log_msg_type} '{actual_module_name}' ({log_msg_details}) в '{module_dir_path.name}'.")

    def _load_and_validate_module_settings(self, module_info: ModuleInfo) -> None:
        module_name = module_info.name
        manifest = module_info.manifest 
        module_info.current_settings = {} 
        
        if not manifest or not manifest.settings: 
            return

        module_default_config_file = module_info.path / MODULE_DEFAULT_SETTINGS_FILENAME 
        user_module_config_file = self.user_module_settings_base_path / f"{module_name}.yaml"

        final_settings: Dict[str, Any] = {}
        for key, setting_mft_def in manifest.settings.items():
            final_settings[key] = setting_mft_def.default

        module_defaults_from_file: Dict[str, Any] = {}
        if module_default_config_file.is_file():
            try:
                with open(module_default_config_file, 'r', encoding='utf-8') as f:
                    module_defaults_from_file = yaml.safe_load(f) or {}
                final_settings.update(module_defaults_from_file)
                self._logger.trace(f"Загружены настройки по умолчанию из файла модуля '{module_name}': {module_default_config_file}")
            except Exception as e:
                self._logger.warning(f"Ошибка чтения файла '{module_default_config_file}' для модуля '{module_name}': {e}.")
        
        if not user_module_config_file.exists():
            self._logger.info(f"Файл пользовательских настроек для модуля '{module_name}' не найден ({user_module_config_file}).")
            source_for_user_config = final_settings.copy() 
            
            if source_for_user_config:
                try:
                    user_module_config_file.parent.mkdir(parents=True, exist_ok=True)
                    with open(user_module_config_file, 'w', encoding='utf-8') as f:
                        yaml.dump(source_for_user_config, f, indent=2, sort_keys=False, allow_unicode=True)
                    self._logger.info(f"Создан файл пользовательских настроек для '{module_name}' на основе дефолтов: {user_module_config_file}")
                except Exception as e_create_user_cfg:
                    self._logger.error(f"Не удалось создать файл пользовательских настроек для '{module_name}': {e_create_user_cfg}.")
            else:
                 self._logger.info(f"Для модуля '{module_name}' нет дефолтных значений для генерации пользовательского файла. Файл не создан.")
        else: 
            try:
                with open(user_module_config_file, 'r', encoding='utf-8') as f:
                    user_settings_from_file = yaml.safe_load(f) or {}
                self._logger.info(f"Загружены пользовательские настройки для модуля '{module_name}' из: {user_module_config_file}")
                final_settings.update(user_settings_from_file)
            except Exception as e_load_user:
                self._logger.error(f"Ошибка загрузки пользовательского файла настроек '{user_module_config_file}' для '{module_name}': {e_load_user}.")
        
        validated_settings: Dict[str, Any] = {}
        validation_errors: List[str] = []

        for key, setting_mft_def in manifest.settings.items():
            value_to_validate = final_settings.get(key) 

            if value_to_validate is None:
                if setting_mft_def.required:
                    validation_errors.append(f"Отсутствует значение для обязательной настройки '{setting_mft_def.label}' ({key}) модуля '{module_name}'.")
                    continue
                else:
                    validated_settings[key] = None
                    continue
            
            try:
                validated_value = value_to_validate
                if setting_mft_def.type == "bool":
                    if isinstance(value_to_validate, str):
                        validated_value = value_to_validate.lower() in ['true', '1', 'yes', 'on', 't']
                    else:
                        validated_value = bool(value_to_validate)
                elif setting_mft_def.type == "int": validated_value = int(value_to_validate)
                elif setting_mft_def.type == "float": validated_value = float(value_to_validate)
                elif setting_mft_def.type in ["string", "text"]: validated_value = str(value_to_validate)
                
                key_specific_errors = False
                if setting_mft_def.type == "string" and setting_mft_def.regex_validator:
                    if not re.fullmatch(setting_mft_def.regex_validator, str(validated_value)):
                        validation_errors.append(f"Значение '{validated_value}' для '{key}' не соответствует regex: {setting_mft_def.regex_validator}"); key_specific_errors = True
                if setting_mft_def.type in ["int", "float"]:
                    if setting_mft_def.min_value is not None and validated_value < setting_mft_def.min_value: # type: ignore
                        validation_errors.append(f"Значение {validated_value} для '{key}' < min ({setting_mft_def.min_value})"); key_specific_errors = True
                    if setting_mft_def.max_value is not None and validated_value > setting_mft_def.max_value: # type: ignore
                        validation_errors.append(f"Значение {validated_value} для '{key}' > max ({setting_mft_def.max_value})"); key_specific_errors = True
                if setting_mft_def.type == "choice" and setting_mft_def.options:
                    option_values = [opt.value if isinstance(opt, PydanticBaseModel) else opt for opt in setting_mft_def.options]
                    if validated_value not in option_values:
                        validation_errors.append(f"Значение '{validated_value}' для '{key}' не является допустимым вариантом ({option_values})."); key_specific_errors = True
                
                if not key_specific_errors:
                    validated_settings[key] = validated_value

            except (ValueError, TypeError) as e_val:
                validation_errors.append(f"Ошибка типа/значения для '{key}' ('{value_to_validate}'): ожидался {setting_mft_def.type}. {e_val}")
            except Exception as e_unknown_val:
                 validation_errors.append(f"Неизвестная ошибка валидации для '{key}': {e_unknown_val}")

        if validation_errors:
            error_message = f"Ошибки валидации настроек модуля '{module_name}': {'; '.join(validation_errors)}"
            if module_info.error: module_info.error += f"; {error_message}"
            else: module_info.error = error_message
            self._logger.error(error_message)
        
        module_info.current_settings = validated_settings
        if validated_settings or not manifest.settings:
            self._logger.info(f"Актуальные настройки для модуля '{module_name}' загружены и провалидированы.")
            if validated_settings: self._logger.debug(f"Итоговые настройки модуля '{module_name}': {validated_settings}")
        else:
            self._logger.warning(f"Для модуля '{module_name}' не удалось загрузить/провалидировать ни одной настройки, хотя они описаны в манифесте.")

    def scan_all_available_modules(self) -> None:
        self.available_modules.clear()
        self._logger.info("Начало сканирования всех модулей...")
        self._scan_directory_for_modules(self.plugins_root_dir, is_system_dir=False)
        self._scan_directory_for_modules(self.core_sys_modules_root_dir, is_system_dir=True)
        self._logger.info(f"Сканирование всех модулей завершено. Всего найдено: {len(self.available_modules)}")

    def _load_enabled_plugin_names(self) -> None:
        config_file = self._core_settings.enabled_modules_config_path
        self.enabled_plugin_names.clear()
        if config_file.is_file():
            try:
                with open(config_file, 'r', encoding='utf-8') as f: data = json.load(f)
                if isinstance(data, list):
                    self.enabled_plugin_names = [m_name for m_name in data if isinstance(m_name, str)]
                elif isinstance(data, dict) and "active_modules" in data and isinstance(data["active_modules"], list):
                     self.enabled_plugin_names = [m_name for m_name in data["active_modules"] if isinstance(m_name, str)]
                else:
                    self._logger.error(f"Неверный формат файла {config_file}. Ожидался список или {{'active_modules': [...]}}.")
                
                for name, module_info in self.available_modules.items():
                    if not module_info.is_system_module:
                        module_info.is_enabled = name in self.enabled_plugin_names
                self._logger.info(f"Загружен список активных плагинов из {config_file}: {self.enabled_plugin_names}")
            except Exception as e:
                self._logger.error(f"Ошибка загрузки списка активных плагинов из {config_file}: {e}", exc_info=True)
        else:
            self._logger.warning(f"Файл со списком активных плагинов {config_file} не найден.")

    def _check_module_dependencies(self, module_info: ModuleInfo) -> bool:
        if not module_info.manifest: return True 
        if module_info.manifest.metadata and module_info.manifest.metadata.min_sdb_core_version:
            from packaging.version import parse as parse_version
            current_sdb_version_str = self._settings.core.sdb_version
            try:
                if parse_version(current_sdb_version_str) < parse_version(module_info.manifest.metadata.min_sdb_core_version):
                    module_info.error = (f"Требуется ядро SDB v >= {module_info.manifest.metadata.min_sdb_core_version}, "
                                         f"текущая: {current_sdb_version_str}.")
                    self._logger.error(f"Модуль '{module_info.name}': {module_info.error}")
                    return False
            except Exception as e_ver:
                self._logger.error(f"Ошибка сравнения версий ядра для '{module_info.name}': {e_ver}")
                module_info.error = "Ошибка формата версии ядра."
                return False
        
        if module_info.manifest.sdb_module_dependencies:
            for dep_name in module_info.manifest.sdb_module_dependencies:
                dep_info = self.available_modules.get(dep_name)
                if not dep_info or not (dep_info.is_enabled or dep_info.is_system_module) or not dep_info.is_loaded_successfully:
                    new_error_msg = f"Требуется активный и успешно загруженный модуль-зависимость '{dep_name}'."
                    module_info.error = (module_info.error + "; " if module_info.error else "") + new_error_msg
                    self._logger.error(f"Модуль '{module_info.name}': {new_error_msg}")
                    return False
        return True

    async def _setup_single_module(self, module_info: ModuleInfo, dp: Dispatcher, bot: Bot, import_base_path: str) -> None:
        if not module_info.manifest and not module_info.is_system_module: 
            module_info.error = "Манифест отсутствует."; self._logger.error(f"Плагин '{module_info.name}': {module_info.error}"); return
        
        if module_info.error: 
            self._logger.error(f"Модуль '{module_info.name}' не будет загружен из-за предыдущей ошибки: {module_info.error}")
            return

        if not self._check_module_dependencies(module_info): return
        
        entry_point_py_file = module_info.path / MODULE_ENTRY_POINT_FILENAME
        if not entry_point_py_file.is_file():
            module_info.error = f"Файл точки входа '{MODULE_ENTRY_POINT_FILENAME}' не найден."; self._logger.error(f"Модуль '{module_info.name}': {module_info.error}"); return
        try:
            import_path_str = f"{import_base_path}.{module_info.path.name}"
            self._logger.debug(f"Импорт модуля '{module_info.name}' через '{import_path_str}'...")
            loaded_py_module = importlib.import_module(import_path_str)
            module_info.imported_py_module = loaded_py_module
            if not hasattr(loaded_py_module, SETUP_FUNCTION_NAME):
                module_info.error = f"Функция '{SETUP_FUNCTION_NAME}' не найдена."; self._logger.error(f"Модуль '{module_info.name}': {module_info.error}"); return
            
            setup_function: Callable = getattr(loaded_py_module, SETUP_FUNCTION_NAME)
            self._logger.info(f"Вызов {SETUP_FUNCTION_NAME}() для модуля '{module_info.name}'...")
            if asyncio.iscoroutinefunction(setup_function): await setup_function(dp=dp, bot=bot, services=self._services)
            else: setup_function(dp=dp, bot=bot, services=self._services)
            module_info.is_loaded_successfully = True
            self._logger.success(f"✅ Модуль '{module_info.name}' успешно загружен и настроен.")
        except Exception as e:
            module_info.error = f"Ошибка загрузки/настройки: {e}"; self._logger.error(f"Модуль '{module_info.name}': {module_info.error}", exc_info=True)

    async def initialize_and_setup_modules(self, dp: Dispatcher, bot: Bot) -> None:
        self.scan_all_available_modules() 
        self._load_enabled_plugin_names()
        
        # Сначала настраиваем системные модули ядра
        self._logger.info("Настройка системных модулей ядра...")
        for module_name, module_info in self.available_modules.items():
            if module_info.is_system_module:
                if module_info.error:
                    self._logger.error(f"Системный модуль '{module_name}' не будет настроен из-за предыдущей ошибки: {module_info.error}")
                    continue
                await self._setup_single_module(module_info, dp, bot, import_base_path=self.core_sys_modules_root_dir.parent.name + "." + self.core_sys_modules_root_dir.name)
        self._logger.info("Настройка системных модулей ядра завершена.")
        
        if not self.enabled_plugin_names: self._logger.info("Нет активных плагинов для настройки.")
        else:
            self._logger.info(f"Настройка {len(self.enabled_plugin_names)} активных плагинов...")
            for plugin_name in self.enabled_plugin_names:
                module_info = self.available_modules.get(plugin_name)
                if not module_info: self._logger.error(f"Активный плагин '{plugin_name}' не найден. Пропуск."); continue
                if module_info.is_system_module: self._logger.warning(f"Модуль '{plugin_name}' системный, но в списке плагинов. Пропуск."); continue
                if module_info.error: 
                    self._logger.error(f"Модуль '{plugin_name}' не будет настроен из-за предыдущей ошибки: {module_info.error}")
                    continue
                await self._setup_single_module(module_info, dp, bot, import_base_path=self.plugins_root_dir.name)
            self._logger.info("Настройка активных плагинов завершена.")

    def get_module_info(self, module_name: str) -> Optional[ModuleInfo]:
        return self.available_modules.get(module_name)

    def get_all_modules_info(self) -> List[ModuleInfo]:
        return list(self.available_modules.values())

    def get_loaded_modules_info(self, include_system: bool = True, include_plugins: bool = True) -> List[ModuleInfo]:
        loaded = []
        for info in self.available_modules.values():
            if info.is_loaded_successfully:
                if (info.is_system_module and include_system) or \
                   (not info.is_system_module and include_plugins):
                    loaded.append(info)
        return loaded
    
    def get_module_settings(self, module_name: str) -> Optional[Dict[str, Any]]:
        module_info = self.get_module_info(module_name)
        if module_info : 
            if module_info.current_settings:
                 return module_info.current_settings
            elif module_info.manifest and module_info.manifest.settings:
                 manifest_defaults = {
                     k: v.default for k, v in module_info.manifest.settings.items() 
                     if v.default is not None 
                 }
                 if manifest_defaults:
                    self._logger.debug(f"current_settings для модуля '{module_name}' пусты, возвращаем дефолты из манифеста.")
                    return manifest_defaults
                 else: 
                    self._logger.debug(f"Модуль '{module_name}' не имеет актуальных или дефолтных настроек в манифесте.")
                    return {} # Возвращаем пустой словарь, если нет ни current_settings, ни дефолтов в манифесте
            else: 
                self._logger.debug(f"Модуль '{module_name}' не имеет описания настроек в манифесте.")
                return {} # Возвращаем пустой словарь
        self._logger.warning(f"Попытка получить настройки для неизвестного модуля '{module_name}'.")
        return None

    def get_all_declared_permissions_from_active_modules(self) -> List[PermissionManifest]:
        """
        Собирает все разрешения, объявленные в манифестах активных
        (enabled) плагинов, а также системных модулей.
        Учитываются только модули без ошибок загрузки манифеста.
        """
        all_perms: Dict[str, PermissionManifest] = {} 

        modules_to_check: List[ModuleInfo] = []
        # Добавляем активные плагины
        for module_name in self.enabled_plugin_names:
            module_info = self.available_modules.get(module_name)
            if module_info and not module_info.is_system_module and not module_info.error:
                modules_to_check.append(module_info)
        
        # Добавляем системные модули
        for module_info in self.available_modules.values():
            if module_info.is_system_module and not module_info.error:
                if module_info not in modules_to_check: # Избегаем дублирования, если системный модуль как-то попал в enabled_plugin_names
                    modules_to_check.append(module_info)

        for module_info in modules_to_check:
            if module_info.manifest and module_info.manifest.declared_permissions:
                for perm_mft in module_info.manifest.declared_permissions:
                    if perm_mft.name not in all_perms:
                        all_perms[perm_mft.name] = perm_mft
                    else:
                        self._logger.warning(f"Дублирующееся объявление разрешения '{perm_mft.name}' "
                                             f"обнаружено (модуль: '{module_info.name}'). Будет использовано первое встреченное.")
                                             
        num_perms = len(all_perms)
        if num_perms > 0:
            self._logger.info(f"Собрано {num_perms} уникальных разрешений, объявленных активными/системными модулями.")
        else:
            self._logger.info("Не найдено разрешений, объявленных в активных/системных модулях.")
        return list(all_perms.values())


======================================================================

------------------------------ FILE: core/logging_manager.py ------------------------------
# core/logging_manager.py
import asyncio
import shutil
from pathlib import Path
from datetime import datetime, timedelta, timezone
from typing import Optional, Any, TYPE_CHECKING

from loguru import logger as global_logger 
import parsedatetime as pdt 
from apscheduler.schedulers.asyncio import AsyncIOScheduler 
from apscheduler.triggers.cron import CronTrigger

if TYPE_CHECKING:
    from core.app_settings import AppSettings

class LoggingManager:
    def __init__(self, app_settings: 'AppSettings'):
        self._settings = app_settings.core
        self._app_settings_ref = app_settings 
        self._current_log_handler_id: Optional[int] = None
        self._current_log_file_path: Optional[Path] = None
        self._scheduler: Optional[AsyncIOScheduler] = None
        self._is_initialized = False

        self._logger = global_logger.bind(service="LoggingManager")
        self._logger.info("LoggingManager инициализирован.")

    def _get_log_file_path_for_current_hour(self) -> Path:
        """Генерирует путь к лог-файлу на основе текущего времени."""
        now = datetime.now(timezone.utc)
        year_str = now.strftime("%Y")
        month_num_str = now.strftime("%m")
        month_name_str = now.strftime("%B") # Имя месяца зависит от локали системы
        day_str = now.strftime("%d")
        hour_str = now.strftime("%H")

        base_logs_dir = self._app_settings_ref.core.project_data_path / self._settings.log_structured_dir
        
        target_dir = base_logs_dir / year_str / f"{month_num_str}-{month_name_str}" / day_str
        target_dir.mkdir(parents=True, exist_ok=True)
        
        return target_dir / f"{hour_str}_sdb.log"

    def _setup_loguru_file_sink(self) -> None: 
        """Настраивает (или перенастраивает) файловый sink для Loguru."""
        if self._current_log_handler_id is not None:
            try:
                global_logger.remove(self._current_log_handler_id)
                self._logger.trace(f"Предыдущий файловый хендлер (ID: {self._current_log_handler_id}) удален.")
            except ValueError:
                self._logger.warning(f"Не удалось удалить предыдущий файловый хендлер ID: {self._current_log_handler_id} (возможно, уже удален).")
            self._current_log_handler_id = None
            self._current_log_file_path = None

        if not self._settings.log_to_file:
            self._logger.info("Запись логов в файл отключена в настройках.")
            return

        new_log_file_path = self._get_log_file_path_for_current_hour()
        
        # --- ЖЕСТКО УСТАНАВЛИВАЕМ УРОВЕНЬ ДЛЯ ФАЙЛОВОГО ЛОГА ---
        log_level_for_file = "DEBUG"  # Используем DEBUG для файлов по умолчанию
        # Если нужен TRACE, измени здесь:
        # log_level_for_file = "TRACE" 
        # ---------------------------------------------------------
        
        try:
            handler_id = global_logger.add(
                sink=str(new_log_file_path),
                level=log_level_for_file, 
                rotation=self._settings.log_rotation_size, 
                compression="zip",
                format="{time:YYYY-MM-DD HH:mm:ss.SSS} | {level: <8} | {name}:{function}:{line} - {message}",
                encoding="utf-8",
                enqueue=True,
                backtrace=True,
                diagnose=True 
            )
            self._current_log_handler_id = handler_id
            self._current_log_file_path = new_log_file_path
            self._logger.success(f"Файловый логгер настроен. Уровень: {log_level_for_file}. Файл: {new_log_file_path}")
        except Exception as e:
            self._logger.error(f"Ошибка при настройке файлового логгера для '{new_log_file_path}': {e}", exc_info=True)
            self._current_log_handler_id = None
            self._current_log_file_path = None

    async def _hourly_log_rotation_check(self) -> None:
        """Проверяет, нужно ли ротировать лог-файл (начался новый час)."""
        self._logger.trace("Выполняется ежечасная проверка ротации логов...")
        if not self._is_initialized or not self._settings.log_to_file:
            self._logger.trace("Проверка ротации пропущена: менеджер не инициализирован или логирование в файл отключено.")
            return

        expected_log_file = self._get_log_file_path_for_current_hour()
        if self._current_log_file_path != expected_log_file:
            self._logger.info(f"Начался новый час. Перенастройка файлового логгера на: {expected_log_file}")
            self._setup_loguru_file_sink() 
        else:
            self._logger.trace(f"Ротация лог-файла не требуется, текущий файл: {self._current_log_file_path}")

    async def _cleanup_old_logs(self) -> None:
        """Удаляет старые директории логов на основе log_retention_period_structured."""
        self._logger.info("Запуск задачи очистки старых логов...")
        if not self._settings.log_to_file:
            self._logger.info("Очистка старых логов пропущена: логирование в файл отключено.")
            return

        retention_str = self._settings.log_retention_period_structured
        cal = pdt.Calendar()
        
        now_dt = datetime.now(timezone.utc)
        past_target_dt, parse_status = cal.parseDT(f"{retention_str} ago", sourceTime=now_dt) # type: ignore
        
        if parse_status == 0 or not past_target_dt:
            self._logger.error(f"Не удалось распарсить период хранения логов: '{retention_str}'. Очистка отменена.")
            return
        
        cutoff_date = past_target_dt 
        self._logger.info(f"Очистка логов старше {cutoff_date.strftime('%Y-%m-%d %H:%M:%S %Z')} (период: '{retention_str}').")

        structured_logs_root = self._app_settings_ref.core.project_data_path / self._settings.log_structured_dir
        if not structured_logs_root.is_dir():
            return

        deleted_dirs_count = 0
        for year_dir in structured_logs_root.iterdir():
            if year_dir.is_dir() and year_dir.name.isdigit():
                if int(year_dir.name) < cutoff_date.year:
                    try:
                        shutil.rmtree(year_dir)
                        self._logger.info(f"Удалена директория старых логов (год): {year_dir}")
                        deleted_dirs_count += 1
                    except Exception as e_rm_year:
                        self._logger.error(f"Ошибка удаления директории логов '{year_dir}': {e_rm_year}")
                    continue 

                if int(year_dir.name) == cutoff_date.year:
                    for month_dir in year_dir.iterdir():
                        if month_dir.is_dir() and "-" in month_dir.name:
                            try:
                                month_num_str = month_dir.name.split("-")[0]
                                if month_num_str.isdigit() and int(month_num_str) < cutoff_date.month:
                                    shutil.rmtree(month_dir)
                                    self._logger.info(f"Удалена директория старых логов (месяц): {month_dir}")
                                    deleted_dirs_count +=1
                                    continue
                                
                                if int(month_num_str) == cutoff_date.month:
                                    for day_dir in month_dir.iterdir():
                                        if day_dir.is_dir() and day_dir.name.isdigit():
                                            if int(day_dir.name) < cutoff_date.day:
                                                shutil.rmtree(day_dir)
                                                self._logger.info(f"Удалена директория старых логов (день): {day_dir}")
                                                deleted_dirs_count += 1
                            except Exception as e_rm_month_day:
                                self._logger.error(f"Ошибка удаления директории логов '{month_dir}' или ее поддиректории: {e_rm_month_day}")
        if deleted_dirs_count > 0:
            self._logger.success(f"Очистка старых логов завершена. Удалено директорий: {deleted_dirs_count}.")
        else:
            self._logger.info("Очистка старых логов завершена. Не найдено директорий для удаления.")


    async def initialize_logging(self) -> None: 
        """Инициализирует систему логирования, включая файловый sink и задачи по расписанию."""
        if self._is_initialized:
            self._logger.info("LoggingManager уже инициализирован.")
            return

        self._logger.info("Начало инициализации LoggingManager...")
        
        self._setup_loguru_file_sink() 
        
        self._scheduler = AsyncIOScheduler(timezone=str(timezone.utc))
        self._scheduler.add_job(self._hourly_log_rotation_check, CronTrigger(minute=0)) 
        self._logger.info("Задача _hourly_log_rotation_check добавлена в планировщик (ежечасно).")
        self._scheduler.add_job(self._cleanup_old_logs, CronTrigger(hour=3, minute=30)) 
        self._logger.info("Задача _cleanup_old_logs добавлена в планировщик (ежедневно в 03:30 UTC).")
        
        try:
            self._scheduler.start()
            self._logger.success("Планировщик задач LoggingManager успешно запущен.")
        except Exception as e_scheduler_start:
            self._logger.error(f"Не удалось запустить планировщик задач LoggingManager: {e_scheduler_start}", exc_info=True)
            self._scheduler = None 

        self._is_initialized = True
        self._logger.info("LoggingManager успешно инициализирован.")

    async def shutdown_logging(self) -> None:
        """Останавливает планировщик и корректно завершает работу."""
        self._logger.info("Начало процедуры остановки LoggingManager...")
        if self._scheduler and self._scheduler.running:
            try:
                self._scheduler.shutdown(wait=False) 
                self._logger.info("Планировщик задач LoggingManager остановлен.")
            except Exception as e_scheduler_shutdown:
                self._logger.error(f"Ошибка при остановке планировщика LoggingManager: {e_scheduler_shutdown}", exc_info=True)
        
        if self._current_log_handler_id is not None:
            try:
                global_logger.remove(self._current_log_handler_id)
                self._logger.info(f"Файловый хендлер (ID: {self._current_log_handler_id}) удален при остановке.")
            except ValueError:
                pass 
        
        self._is_initialized = False
        self._logger.info("LoggingManager остановлен.")


======================================================================

------------------------------ FILE: core/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/app_settings.py ------------------------------
# core/app_settings.py

import os
import sys
import yaml
from pathlib import Path
from typing import List, Optional, Literal, Any, Dict 
from pydantic import BaseModel, Field, field_validator, HttpUrl, ValidationInfo, AliasChoices

try:
    from loguru import logger as global_logger 
except ImportError:
    import logging
    global_logger = logging.getLogger("sdb_app_settings_fallback")
    global_logger.warning("Loguru не найден, используется стандартный logging. Пожалуйста, установите Loguru.")

from dotenv import load_dotenv, find_dotenv
from pydantic.networks import PostgresDsn, MySQLDsn, AnyUrl 
from pydantic_settings import BaseSettings, SettingsConfigDict

PROJECT_ROOT_DIR = Path(__file__).resolve().parent.parent
ENV_FILENAME = ".env"
DEFAULT_PROJECT_DATA_DIR_NAME = "project_data" 
USER_CONFIG_DIR_NAME = "Config" 
USER_CONFIG_FILENAME = "core_settings.yaml"
ENABLED_MODULES_FILENAME = "enabled_modules.json" 
ROOT_CONFIG_TEMPLATE_FILENAME = "config.yaml" 
STRUCTURED_LOGS_ROOT_DIR_NAME = "Logs" 

env_file_path_for_dotenv = find_dotenv(filename=ENV_FILENAME, usecwd=True, raise_error_if_not_found=False)
BOT_TOKEN_FROM_DOTENV: Optional[str] = None
if env_file_path_for_dotenv and Path(env_file_path_for_dotenv).exists():
    global_logger.info(f"Найден .env файл для python-dotenv: {env_file_path_for_dotenv}")
    load_dotenv(dotenv_path=env_file_path_for_dotenv, override=True)
    BOT_TOKEN_FROM_DOTENV = os.getenv("BOT_TOKEN")
    if BOT_TOKEN_FROM_DOTENV:
        global_logger.info(f"BOT_TOKEN ('****{BOT_TOKEN_FROM_DOTENV[-4:]}') предварительно загружен из .env файла.")
    else:
        global_logger.warning(f"BOT_TOKEN не найден в {env_file_path_for_dotenv} при чтении через python-dotenv/os.getenv.")
else:
    env_file_at_root = PROJECT_ROOT_DIR / ENV_FILENAME
    if env_file_at_root.exists() and env_file_at_root.is_file():
        global_logger.info(f"Найден .env файл для python-dotenv (вторая попытка в корне проекта): {env_file_at_root}")
        load_dotenv(dotenv_path=env_file_at_root, override=True)
        BOT_TOKEN_FROM_DOTENV = os.getenv("BOT_TOKEN")
        if BOT_TOKEN_FROM_DOTENV:
            global_logger.info(f"BOT_TOKEN ('****{BOT_TOKEN_FROM_DOTENV[-4:]}') успешно загружен (вторая попытка).")
        else:
            global_logger.warning(f"BOT_TOKEN не найден в {env_file_at_root} (вторая попытка).")
    else:
        global_logger.warning(f".env файл не найден python-dotenv. BOT_TOKEN будет искаться в YAML или системных переменных.")

class DBSettings(BaseModel):
    type: Literal["sqlite", "postgresql", "mysql"] = Field(default="sqlite", description="Тип используемой базы данных.")
    sqlite_path: str = Field(
        default=f"Database_files/swiftdevbot.db", 
        description="Относительный путь к файлу SQLite (от корня проекта или project_data_path)."
    )
    pg_dsn: Optional[PostgresDsn] = Field(default=None, description="DSN для PostgreSQL.")
    mysql_dsn: Optional[MySQLDsn] = Field(default=None, description="DSN для MySQL.")
    echo_sql: bool = Field(default=False, description="Логировать SQL-запросы SQLAlchemy (уровень DEBUG).")

    @field_validator('pg_dsn', mode='before')
    @classmethod
    def check_pg_dsn(cls, v: Optional[PostgresDsn], info: ValidationInfo) -> Optional[PostgresDsn]:
        if info.data.get('type') == "postgresql" and not v:
            raise ValueError("pg_dsn должен быть указан для типа БД 'postgresql'.")
        return v

    @field_validator('mysql_dsn', mode='before')
    @classmethod
    def check_mysql_dsn(cls, v: Optional[MySQLDsn], info: ValidationInfo) -> Optional[MySQLDsn]:
        if info.data.get('type') == "mysql" and not v:
            raise ValueError("mysql_dsn должен быть указан для типа БД 'mysql'.")
        return v

class CacheSettings(BaseModel):
    type: Literal["memory", "redis"] = Field(default="memory", description="Тип кэша.")
    redis_url: Optional[str] = Field(default="redis://localhost:6379/0", description="URL для Redis.")

    @field_validator('redis_url', mode='before')
    @classmethod
    def check_redis_url(cls, v: Optional[str], info: ValidationInfo) -> Optional[str]:
        cache_type = info.data.get('type') if info.data else None
        if cache_type == "redis" and not v:
            raise ValueError("redis_url должен быть указан для типа кэша 'redis'.")
        return v

class TelegramSettings(BaseModel):
    token: str = Field(description="Токен Telegram бота (рекомендуется указывать в .env).")
    polling_timeout: int = Field(default=30, ge=1, description="Таймаут long polling (секунды).")

class ModuleRepoSettings(BaseModel):
    index_url: Optional[HttpUrl] = Field(
        default=HttpUrl("https://raw.githubusercontent.com/soverxos/SwiftDevBot-Modules/main/modules_index.json"),
        description="URL к JSON-индексу официальных модулей SDB."
    )

class I18nSettings(BaseModel):
    locales_dir: Path = Field(default=PROJECT_ROOT_DIR / "locales", description="Путь к директории с файлами переводов.")
    domain: str = Field(default="bot", description="Имя домена для gettext.")
    default_locale: str = Field(default="en", description="Язык по умолчанию.")
    available_locales: List[str] = Field(default_factory=lambda: ["en", "ua"], description="Список доступных языков.")

class CoreAppSettings(BaseModel):
    project_data_path: Path = Field(
        default=PROJECT_ROOT_DIR / DEFAULT_PROJECT_DATA_DIR_NAME,
        description="Путь к директории данных проекта."
    )
    super_admins: List[int] = Field(default_factory=list, description="Список Telegram ID супер-администраторов.")
    enabled_modules_config_path: Path = Field(
        default=Path(f"{USER_CONFIG_DIR_NAME}/{ENABLED_MODULES_FILENAME}"), 
        description="Путь к файлу со списком активных модулей (относительно директории данных)."
    )
    
    log_level: Literal["TRACE", "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"] = Field(default="INFO")
    log_to_file: bool = Field(default=True)
    log_structured_dir: str = Field(
        default=STRUCTURED_LOGS_ROOT_DIR_NAME, 
        description="Базовая директория для структурированных лог-файлов (относительно project_data_path)."
    )
    log_rotation_size: str = Field(
        default="100 MB", 
        description="Максимальный размер одного часового лог-файла перед ротацией (e.g., '100 MB')."
    ) 
    log_retention_period_structured: str = Field(
        default="3 months", 
        description="Как долго хранить структурированные логи (например, '30 days', '3 months', '1 year'). "
                    "Реализуется отдельной задачей очистки."
    )
    
    sdb_version: str = Field(default="0.1.0", pattern=r"^\d+\.\d+\.\d+([\w.-]*[\w])?(\+[\w.-]+)?$",
                             description="Версия ядра SwiftDevBot (SemVer-совместимая).")
    
    setup_bot_commands_on_startup: bool = Field(default=True, description="Устанавливать команды бота при старте.")
    i18n: I18nSettings = Field(default_factory=I18nSettings)

class EnvironmentSettings(BaseSettings):
    CORE_PROJECT_DATA_PATH: Optional[Path] = Field(default=None, validation_alias=AliasChoices('SDB_CORE_PROJECT_DATA_PATH', 'CORE_PROJECT_DATA_PATH'))
    CORE_SUPER_ADMINS: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_CORE_SUPER_ADMINS', 'CORE_SUPER_ADMINS'))
    CORE_ENABLED_MODULES_CONFIG_PATH: Optional[Path] = Field(default=None, validation_alias=AliasChoices('SDB_CORE_ENABLED_MODULES_CONFIG_PATH', 'CORE_ENABLED_MODULES_CONFIG_PATH'))
    CORE_LOG_LEVEL: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_CORE_LOG_LEVEL', 'CORE_LOG_LEVEL'))
    CORE_LOG_TO_FILE: Optional[bool] = Field(default=None, validation_alias=AliasChoices('SDB_CORE_LOG_TO_FILE', 'CORE_LOG_TO_FILE'))
    
    SDB_CORE_LOG_STRUCTURED_DIR: Optional[str] = Field(default=None)
    SDB_CORE_LOG_ROTATION_SIZE: Optional[str] = Field(default=None)
    SDB_CORE_LOG_RETENTION_PERIOD_STRUCTURED: Optional[str] = Field(default=None)

    CORE_SDB_VERSION: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_CORE_SDB_VERSION', 'CORE_SDB_VERSION'))
    
    DB_TYPE: Optional[Literal["sqlite", "postgresql", "mysql"]] = Field(default=None, validation_alias=AliasChoices('SDB_DB_TYPE', 'DB_TYPE'))
    DB_SQLITE_PATH: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_DB_SQLITE_PATH', 'DB_SQLITE_PATH'))
    DB_PG_DSN: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_DB_PG_DSN', 'DB_PG_DSN')) 
    DB_MYSQL_DSN: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_DB_MYSQL_DSN', 'DB_MYSQL_DSN')) 
    DB_ECHO_SQL: Optional[bool] = Field(default=None, validation_alias=AliasChoices('SDB_DB_ECHO_SQL', 'DB_ECHO_SQL'))

    CACHE_TYPE: Optional[Literal["memory", "redis"]] = Field(default=None, validation_alias=AliasChoices('SDB_CACHE_TYPE', 'CACHE_TYPE'))
    CACHE_REDIS_URL: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_CACHE_REDIS_URL', 'CACHE_REDIS_URL'))
    
    TELEGRAM_POLLING_TIMEOUT: Optional[int] = Field(default=None, validation_alias=AliasChoices('SDB_TELEGRAM_POLLING_TIMEOUT', 'TELEGRAM_POLLING_TIMEOUT'))
    MODULE_REPO_INDEX_URL: Optional[HttpUrl] = Field(default=None, validation_alias=AliasChoices('SDB_MODULE_REPO_INDEX_URL', 'MODULE_REPO_INDEX_URL'))

    SDB_I18N_LOCALES_DIR: Optional[Path] = Field(default=None, validation_alias=AliasChoices('SDB_I18N_LOCALES_DIR', 'I18N_LOCALES_DIR'))
    SDB_I18N_DOMAIN: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_I18N_DOMAIN', 'I18N_DOMAIN'))
    SDB_I18N_DEFAULT_LOCALE: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_I18N_DEFAULT_LOCALE', 'I18N_DEFAULT_LOCALE'))
    SDB_I18N_AVAILABLE_LOCALES: Optional[str] = Field(default=None, validation_alias=AliasChoices('SDB_I18N_AVAILABLE_LOCALES', 'I18N_AVAILABLE_LOCALES'))

    model_config = SettingsConfigDict(
        env_file=None, 
        extra='ignore',
    )

class AppSettings(BaseModel):
    db: DBSettings = Field(default_factory=DBSettings)
    cache: CacheSettings = Field(default_factory=CacheSettings)
    telegram: TelegramSettings
    module_repo: ModuleRepoSettings = Field(default_factory=ModuleRepoSettings)
    core: CoreAppSettings = Field(default_factory=CoreAppSettings)
    model_config = {"validate_assignment": True}

_loaded_settings_cache: Optional[AppSettings] = None
_loguru_console_configured_flag = False

def load_app_settings() -> AppSettings:
    global _loaded_settings_cache, _loguru_console_configured_flag
    if _loaded_settings_cache is not None:
        return _loaded_settings_cache

    global_logger.debug(f"Инициализация загрузки конфигурации SDB. Корень проекта: {PROJECT_ROOT_DIR}")
    
    env_s = EnvironmentSettings()
    
    if BOT_TOKEN_FROM_DOTENV:
        global_logger.info(f"BOT_TOKEN ('****{BOT_TOKEN_FROM_DOTENV[-4:]}') был предварительно загружен.")
    else:
        global_logger.warning("BOT_TOKEN не был найден при предварительной загрузке из .env. Будет искаться в YAML.")
    
    pdp_val_from_env = env_s.CORE_PROJECT_DATA_PATH
    core_app_defaults = CoreAppSettings.model_fields
    
    if pdp_val_from_env:
        effective_project_data_path = Path(pdp_val_from_env)
        if not effective_project_data_path.is_absolute():
            effective_project_data_path = (PROJECT_ROOT_DIR / effective_project_data_path).resolve()
    else: 
        default_pdp_model = core_app_defaults["project_data_path"].default
        effective_project_data_path = Path(default_pdp_model) if default_pdp_model else (PROJECT_ROOT_DIR / DEFAULT_PROJECT_DATA_DIR_NAME)
        if not effective_project_data_path.is_absolute():
             effective_project_data_path = (PROJECT_ROOT_DIR / effective_project_data_path).resolve()

    user_config_file_path = effective_project_data_path / USER_CONFIG_DIR_NAME / USER_CONFIG_FILENAME
    yaml_data: Dict[str, Any] = {}
    if user_config_file_path.is_file():
        try:
            with open(user_config_file_path, 'r', encoding='utf-8') as f: yaml_data = yaml.safe_load(f) or {}
            global_logger.info(f"Загружена конфигурация из пользовательского YAML: {user_config_file_path}")
        except Exception as e_yaml: global_logger.error(f"Ошибка загрузки YAML из {user_config_file_path}: {e_yaml}.")
    else:
        global_logger.info(f"Пользовательский YAML конфиг {user_config_file_path} не найден. Используются дефолты и .env.")

    tg_token_from_yaml = yaml_data.get("telegram", {}).get("token")
    final_tg_token = BOT_TOKEN_FROM_DOTENV or tg_token_from_yaml
    if not final_tg_token:
        raise ValueError(f"КРИТИЧНО: BOT_TOKEN не найден! Проверьте .env и YAML ({user_config_file_path}).")
    
    telegram_s = TelegramSettings(
        token=final_tg_token,
        polling_timeout=env_s.TELEGRAM_POLLING_TIMEOUT or \
                        yaml_data.get("telegram", {}).get("polling_timeout", TelegramSettings.model_fields["polling_timeout"].default)
    )

    db_yaml = yaml_data.get("db", {})
    db_s = DBSettings(
        type=env_s.DB_TYPE or db_yaml.get("type", DBSettings.model_fields["type"].default),
        sqlite_path=env_s.DB_SQLITE_PATH or db_yaml.get("sqlite_path", DBSettings.model_fields["sqlite_path"].default),
        pg_dsn=env_s.DB_PG_DSN or db_yaml.get("pg_dsn"),
        mysql_dsn=env_s.DB_MYSQL_DSN or db_yaml.get("mysql_dsn"),
        echo_sql=env_s.DB_ECHO_SQL if env_s.DB_ECHO_SQL is not None else \
                 db_yaml.get("echo_sql", DBSettings.model_fields["echo_sql"].default)
    )

    cache_yaml = yaml_data.get("cache", {})
    cache_s = CacheSettings(
        type=env_s.CACHE_TYPE or cache_yaml.get("type", CacheSettings.model_fields["type"].default),
        redis_url=env_s.CACHE_REDIS_URL or cache_yaml.get("redis_url", CacheSettings.model_fields["redis_url"].default)
    )

    module_repo_yaml = yaml_data.get("module_repo", {})
    module_repo_s = ModuleRepoSettings(
        index_url=env_s.MODULE_REPO_INDEX_URL or \
                  HttpUrl(str(module_repo_yaml.get("index_url") or ModuleRepoSettings.model_fields["index_url"].default))
    )
    
    core_yaml = yaml_data.get("core", {})
    
    s_admins_str_env = env_s.CORE_SUPER_ADMINS
    s_admins_list_yaml = core_yaml.get("super_admins")
    s_admins_final_list: List[int] = []
    if s_admins_str_env:
        try: s_admins_final_list = [int(x.strip()) for x in s_admins_str_env.split(',') if x.strip().isdigit()]
        except ValueError: global_logger.error(f"Ошибка парсинга CORE_SUPER_ADMINS из env: '{s_admins_str_env}'")
    elif isinstance(s_admins_list_yaml, list):
        s_admins_final_list = [int(x) for x in s_admins_list_yaml if isinstance(x, (int, str)) and str(x).isdigit()]

    emcp_from_env_val = env_s.CORE_ENABLED_MODULES_CONFIG_PATH
    emcp_from_yaml_val = core_yaml.get("enabled_modules_config_path")
    emcp_default_relative = CoreAppSettings.model_fields["enabled_modules_config_path"].default 
    
    emcp_to_resolve = emcp_from_env_val or (Path(emcp_from_yaml_val) if emcp_from_yaml_val else emcp_default_relative)
    emcp_path_resolved = (effective_project_data_path / emcp_to_resolve).resolve() if not Path(emcp_to_resolve).is_absolute() else Path(emcp_to_resolve).resolve()

    log_structured_dir_final = env_s.SDB_CORE_LOG_STRUCTURED_DIR or core_yaml.get("log_structured_dir", CoreAppSettings.model_fields["log_structured_dir"].default)
    log_rotation_size_final = env_s.SDB_CORE_LOG_ROTATION_SIZE or core_yaml.get("log_rotation_size", CoreAppSettings.model_fields["log_rotation_size"].default)
    log_retention_period_structured_final = env_s.SDB_CORE_LOG_RETENTION_PERIOD_STRUCTURED or core_yaml.get("log_retention_period_structured", CoreAppSettings.model_fields["log_retention_period_structured"].default)

    i18n_yaml = core_yaml.get("i18n", {})
    i18n_model_defaults = I18nSettings.model_fields
    
    available_locales_env_str = env_s.SDB_I18N_AVAILABLE_LOCALES
    available_locales_yaml = i18n_yaml.get("available_locales")
    final_available_locales: List[str]
    if available_locales_env_str:
        final_available_locales = [loc.strip() for loc in available_locales_env_str.split(',')]
    elif isinstance(available_locales_yaml, list):
        final_available_locales = available_locales_yaml
    else:
        final_available_locales = i18n_model_defaults["available_locales"].default_factory() # type: ignore

    locales_dir_env = env_s.SDB_I18N_LOCALES_DIR
    locales_dir_yaml = i18n_yaml.get("locales_dir")
    locales_dir_default = i18n_model_defaults["locales_dir"].default
    
    locales_dir_to_resolve = locales_dir_env or (Path(locales_dir_yaml) if locales_dir_yaml else locales_dir_default)
    resolved_locales_dir = Path(locales_dir_to_resolve)
    if not resolved_locales_dir.is_absolute():
        resolved_locales_dir = (PROJECT_ROOT_DIR / resolved_locales_dir).resolve()

    i18n_s = I18nSettings(
        locales_dir=resolved_locales_dir,
        domain=env_s.SDB_I18N_DOMAIN or i18n_yaml.get("domain", i18n_model_defaults["domain"].default),
        default_locale=env_s.SDB_I18N_DEFAULT_LOCALE or i18n_yaml.get("default_locale", i18n_model_defaults["default_locale"].default),
        available_locales=final_available_locales
    )

    core_s = CoreAppSettings(
        project_data_path=effective_project_data_path,
        super_admins=s_admins_final_list,
        enabled_modules_config_path=emcp_path_resolved,
        log_level=(env_s.CORE_LOG_LEVEL or core_yaml.get("log_level", CoreAppSettings.model_fields["log_level"].default)).upper(), # type: ignore
        log_to_file=env_s.CORE_LOG_TO_FILE if env_s.CORE_LOG_TO_FILE is not None \
                    else core_yaml.get("log_to_file", CoreAppSettings.model_fields["log_to_file"].default),
        log_structured_dir=log_structured_dir_final,
        log_rotation_size=log_rotation_size_final,
        log_retention_period_structured=log_retention_period_structured_final,
        sdb_version=env_s.CORE_SDB_VERSION or core_yaml.get("sdb_version", CoreAppSettings.model_fields["sdb_version"].default),
        setup_bot_commands_on_startup=core_yaml.get("setup_bot_commands_on_startup", CoreAppSettings.model_fields["setup_bot_commands_on_startup"].default), # type: ignore
        i18n=i18n_s
    )
    
    final_settings = AppSettings(db=db_s, cache=cache_s, telegram=telegram_s, module_repo=module_repo_s, core=core_s)

    final_settings.core.project_data_path.mkdir(parents=True, exist_ok=True)
    final_settings.core.enabled_modules_config_path.parent.mkdir(parents=True, exist_ok=True)
    
    structured_logs_root_abs_path = final_settings.core.project_data_path / final_settings.core.log_structured_dir
    structured_logs_root_abs_path.mkdir(parents=True, exist_ok=True)
    
    final_settings.core.i18n.locales_dir.mkdir(parents=True, exist_ok=True)
    
    if final_settings.db.type == "sqlite":
        sqlite_file_abs = Path(final_settings.db.sqlite_path)
        if not sqlite_file_abs.is_absolute():
            if DEFAULT_PROJECT_DATA_DIR_NAME in sqlite_file_abs.parts:
                 sqlite_file_abs = (PROJECT_ROOT_DIR / sqlite_file_abs).resolve()
            else:
                 sqlite_file_abs = (final_settings.core.project_data_path / sqlite_file_abs).resolve()
        final_settings.db.sqlite_path = str(sqlite_file_abs)
        sqlite_file_abs.parent.mkdir(parents=True, exist_ok=True)

    if not _loguru_console_configured_flag:
        try:
            if hasattr(global_logger, '_core') and global_logger._core.handlers:
                for handler_id_to_remove in list(global_logger._core.handlers.keys()):
                    try: global_logger.remove(handler_id_to_remove)
                    except ValueError: pass
            
            log_format_console = ("<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> | "
                                  "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>")
            
            console_log_level_str = final_settings.core.log_level.upper()
            
            cli_debug_env_var = os.environ.get("SDB_CLI_DEBUG_MODE_FOR_LOGGING", "false").lower()
            if cli_debug_env_var == "true":
                console_log_level_str = "DEBUG"
                global_logger.info("Loguru (app_settings): Уровень консольного лога принудительно DEBUG из-за SDB_CLI_DEBUG_MODE_FOR_LOGGING.")

            global_logger.add(sys.stderr, level=console_log_level_str, format=log_format_console, colorize=True)
            global_logger.info(f"Loguru (app_settings): Консольный логгер настроен. Уровень: {console_log_level_str}")
            _loguru_console_configured_flag = True
        except Exception as e_log_setup_console:
            print(f"CRITICAL ERROR in app_settings during Loguru console setup: {e_log_setup_console}", file=sys.stderr)

    global_logger.success("Настройки SDB успешно загружены и провалидированы!")
    _loaded_settings_cache = final_settings
    return final_settings

try:
    settings: AppSettings = load_app_settings()
except (ImportError, ValueError) as e: 
    print(f"CRITICAL ERROR during SDB settings load/validation: {e}", file=sys.stderr)
    if hasattr(global_logger, 'opt') and callable(global_logger.opt): 
        global_logger.opt(exception=True).critical(f"КРИТИЧЕСКАЯ ОШИБКА Pydantic/SDB при валидации или загрузке настроек: {e}")
    sys.exit(1)
except Exception as e:
    print(f"UNEXPECTED CRITICAL ERROR during initial settings load: {e}", file=sys.stderr)
    if hasattr(global_logger, 'opt') and callable(global_logger.opt):
        global_logger.opt(exception=True).critical(f"НЕПРЕДВИДЕННАЯ КРИТИЧЕСКАЯ ОШИБКА при первоначальной загрузке настроек: {e}")
    sys.exit(1)


======================================================================

------------------------------ FILE: core/bot_entrypoint.py ------------------------------
# core/bot_entrypoint.py

import asyncio
import sys
import os
from pathlib import Path
from typing import Optional, Union, List, Dict, Any, TYPE_CHECKING
from datetime import datetime, timezone

from loguru import logger as global_logger

if not (hasattr(global_logger, '_core') and hasattr(global_logger._core, 'handlers') and global_logger._core.handlers):
    try:
        global_logger.remove()
        global_logger.add(sys.stderr, level="DEBUG")
        print("!!! [SDB bot_entrypoint WARNING] Loguru handlers был пуст или недоступен, добавлен stderr по умолчанию. !!!", file=sys.stderr)
    except Exception as e_loguru_init_fallback_entry:
        print(f"!!! [SDB bot_entrypoint CRITICAL] Loguru handlers пуст и не удалось добавить stderr: {e_loguru_init_fallback_entry} !!!", file=sys.stderr)


from aiogram import Bot, Dispatcher, __version__ as aiogram_version
from aiogram.types import BotCommand
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.fsm.storage.memory import MemoryStorage
# <--- ИЗМЕНЕНИЕ: УДАЛЕН ИМПОРТ RedisStorage ОТСЮДА ---
# from aiogram.fsm.storage.redis import RedisStorage
from aiogram.exceptions import TelegramRetryAfter

from core.app_settings import settings
from core.services_provider import BotServicesProvider
from core.module_loader import ModuleLoader
from core.ui.handlers_core_ui import core_ui_router
from core.i18n.middleware import I18nMiddleware
from core.i18n.translator import Translator
from core.users.middleware import UserStatusMiddleware
from core.logging_manager import LoggingManager

if TYPE_CHECKING:
    from aiogram.fsm.storage.redis import RedisStorage # <--- ИЗМЕНЕНИЕ: Импорт для type hinting

PID_FILENAME = "sdb_bot.pid"
CORE_COMMANDS_DESCRIPTIONS = {
    "start": "🚀 Запустить бота / Показать главное меню",
    "help": "❓ Помощь и список команд бота",
}

try:
    from core.admin import admin_router
    ADMIN_ROUTER_AVAILABLE = True
    global_logger.info("Главный админ-роутер (core.admin.admin_router) успешно импортирован.")
except ImportError:
    admin_router = None
    ADMIN_ROUTER_AVAILABLE = False
    global_logger.info("Главный админ-роутер не найден или не может быть импортирован. Админ-панель будет неактивна.")


async def _setup_bot_commands(bot: Bot, services: 'BotServicesProvider', admin_router_available: bool):
    module_name_for_log = "CoreBotSetup"
    global_logger.debug(f"[{module_name_for_log}] Начало установки команд бота в Telegram...")

    final_commands_dict: Dict[str, str] = {}

    for cmd_name, cmd_desc in CORE_COMMANDS_DESCRIPTIONS.items():
        if cmd_name not in final_commands_dict:
            final_commands_dict[cmd_name] = cmd_desc
    global_logger.trace(f"[{module_name_for_log}] Добавлены базовые команды ядра: {list(CORE_COMMANDS_DESCRIPTIONS.keys())}")

    all_loaded_plugin_modules_info = services.modules.get_loaded_modules_info(include_system=False, include_plugins=True)
    for module_info in all_loaded_plugin_modules_info:
        if module_info.manifest and module_info.manifest.commands:
            global_logger.trace(f"[{module_name_for_log}] Проверка команд для плагина: {module_info.name}")
            for cmd_manifest in module_info.manifest.commands:
                if not cmd_manifest.admin_only:
                    if cmd_manifest.command not in final_commands_dict:
                        final_commands_dict[cmd_manifest.command] = cmd_manifest.description

    if admin_router_available:
        admin_panel_commands = {"admin": "🛠 Открыть панель администратора"}

        for cmd_name, cmd_desc in admin_panel_commands.items():
            if cmd_name not in final_commands_dict:
                 final_commands_dict[cmd_name] = cmd_desc
        global_logger.trace(f"[{module_name_for_log}] Добавлены команды админ-панели: {list(admin_panel_commands.keys())}")

    final_bot_commands = [
        BotCommand(command=name, description=desc) for name, desc in final_commands_dict.items()
    ]

    if final_bot_commands:
        try:
            await bot.set_my_commands(final_bot_commands)
            global_logger.success(f"[{module_name_for_log}] Установлено {len(final_bot_commands)} команд бота в Telegram: "
                                  f"{[cmd.command for cmd in final_bot_commands]}")
        except Exception as e:
            global_logger.error(f"[{module_name_for_log}] Ошибка при установке команд бота: {e}", exc_info=True)
    else:
        global_logger.warning(f"[{module_name_for_log}] Нет команд для установки в Telegram.")


async def run_sdb_bot() -> int:
    current_process_start_time = datetime.now(timezone.utc)
    sdb_version = settings.core.sdb_version

    logging_manager = LoggingManager(app_settings=settings)
    await logging_manager.initialize_logging()

    global_logger.info(f"Система логирования инициализирована. "
                       f"Уровень консольного лога: {settings.core.log_level.upper()} (может быть переопределен SDB_CLI_DEBUG_MODE_FOR_LOGGING). "
                       f"Уровень файлового лога всегда DEBUG (или TRACE, если так задано в LoggingManager).")

    global_logger.info(f"🚀 Запуск SwiftDevBot (SDB) v{sdb_version} в {current_process_start_time.strftime('%Y-%m-%d %H:%M:%S %Z')}...")
    global_logger.info(f"🐍 Используется Python v{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}")
    global_logger.info(f"🤖 Используется Aiogram v{aiogram_version}")
    global_logger.debug(f"Каталог запуска (CWD): {Path.cwd()}")
    global_logger.debug(f"Корень проекта: {settings.core.project_data_path.parent}")
    global_logger.debug(f"Директория данных проекта: {settings.core.project_data_path}")

    pid_file_actual_path = settings.core.project_data_path / PID_FILENAME
    bot: Optional[Bot] = None
    services: Optional[BotServicesProvider] = None
    exit_code_internal = 1

    if pid_file_actual_path.exists():
        try:
            old_pid = int(pid_file_actual_path.read_text().strip())
            if sys.platform != "win32":
                os.kill(old_pid, 0)
                global_logger.error(f"Обнаружен активный PID-файл ({pid_file_actual_path}) для работающего процесса PID {old_pid}. "
                                   f"Новый запуск SDB (PID: {os.getpid()}) не может быть выполнен. Остановите предыдущий экземпляр.")
                if logging_manager: await logging_manager.shutdown_logging()
                return 1
        except (OSError, ValueError):
            global_logger.info(f"Удаление устаревшего или некорректного PID-файла: {pid_file_actual_path}")
            pid_file_actual_path.unlink(missing_ok=True)
        except Exception as e_pid_precheck:
             global_logger.warning(f"Ошибка при предварительной проверке PID-файла: {e_pid_precheck}")

    try:
        pid_file_actual_path.parent.mkdir(parents=True, exist_ok=True)
        with open(pid_file_actual_path, "w") as f:
            f.write(str(os.getpid()))
        global_logger.info(f"PID {os.getpid()} записан в {pid_file_actual_path}")
    except Exception as e_pid_write:
        global_logger.error(f"Не удалось создать/записать PID-файл {pid_file_actual_path}: {e_pid_write}. "
                           "Бот продолжит работу, но управление через PID-файл может быть нарушено.")
    try:
        services = BotServicesProvider(settings=settings)
        await services.setup_services()
        global_logger.success("✅ BotServicesProvider и все его базовые сервисы успешно инициализированы.")

        bot = Bot(
            token=services.config.telegram.token,
            default=DefaultBotProperties(parse_mode=ParseMode.HTML)
        )
        me = await bot.get_me()
        global_logger.info(f"🤖 Экземпляр Telegram Bot успешно создан: @{me.username} (ID: {me.id})")

        # <--- ИЗМЕНЕНИЕ: УСЛОВНЫЙ ИМПОРТ И СОЗДАНИЕ ХРАНИЛИЩА ---
        storage: Union[MemoryStorage, "RedisStorage"]

        if services.config.cache.type == "redis" and services.cache.is_available():
            try:
                # Импортируем RedisStorage только здесь
                from aiogram.fsm.storage.redis import RedisStorage
                
                redis_client_instance = await services.cache.get_redis_client_instance()
                if redis_client_instance:
                    storage = RedisStorage(redis=redis_client_instance)
                    global_logger.info("FSM Storage: используется RedisStorage.")
                else:
                    global_logger.warning("Redis сконфигурирован, но клиент Redis недоступен для FSM. Используется MemoryStorage.")
                    storage = MemoryStorage()
            except ImportError:
                global_logger.critical("Выбран тип кэша/FSM 'redis', но библиотека 'redis' не установлена! Установите ее: pip install redis")
                global_logger.warning("FSM Storage: Фоллбэк на MemoryStorage из-за отсутствия библиотеки redis.")
                storage = MemoryStorage()
        else:
            storage = MemoryStorage()
            if services.config.cache.type == "redis":
                global_logger.warning("Redis был выбран для кэша, но CacheManager недоступен. Используется MemoryStorage для FSM.")
            global_logger.info("FSM Storage: используется MemoryStorage.")
        # <--- КОНЕЦ ИЗМЕНЕНИЯ ---

        dp = Dispatcher(storage=storage, services_provider=services)
        global_logger.info("🚦 Dispatcher и FSM Storage инициализированы.")

        translator = Translator(
            locales_dir=settings.core.i18n.locales_dir,
            domain=settings.core.i18n.domain,
            default_locale=settings.core.i18n.default_locale,
            available_locales=settings.core.i18n.available_locales
        )
        dp.update.outer_middleware(I18nMiddleware(translator))
        global_logger.info("I18nMiddleware зарегистрирован для всех Update.")

        dp.update.outer_middleware(UserStatusMiddleware())
        global_logger.info("UserStatusMiddleware зарегистрирован для всех Update.")

        dp.include_router(core_ui_router)
        global_logger.info(f"Базовый UI-роутер ядра '{core_ui_router.name}' зарегистрирован.")

        if ADMIN_ROUTER_AVAILABLE and admin_router:
            try:
                dp.include_router(admin_router)
                global_logger.critical(f"✅ Главный админ-роутер '{admin_router.name}' успешно зарегистрирован")
            except Exception as e:
                global_logger.critical(f"❌ Ошибка при регистрации админ-роутера: {e}", exc_info=True)
        else:
            global_logger.critical(f"❌ Админ-роутер не зарегистрирован: ADMIN_ROUTER_AVAILABLE={ADMIN_ROUTER_AVAILABLE}, admin_router={'существует' if admin_router else 'отсутствует'}")

        module_loader: ModuleLoader = services.modules
        await module_loader.initialize_and_setup_modules(dp=dp, bot=bot)

        num_enabled_plugins = len(module_loader.enabled_plugin_names)
        num_loaded_plugins = sum(1 for mi in module_loader.get_loaded_modules_info(include_system=False, include_plugins=True) if mi.is_enabled)

        global_logger.info(
            f"🧩 Загрузка плагинов из 'modules/': {num_loaded_plugins} из {num_enabled_plugins} активных успешно загружено."
        )
        if num_loaded_plugins < num_enabled_plugins:
            global_logger.warning("⚠️ Не все активные плагины были успешно загружены. Смотрите логи выше.")

        global_logger.debug("Все роутеры (ядра, системные, плагины) зарегистрированы в Dispatcher.")

        if settings.core.setup_bot_commands_on_startup:
            await _setup_bot_commands(bot, services, admin_router_available=ADMIN_ROUTER_AVAILABLE)
        else:
            global_logger.info("Автоматическая установка команд бота отключена в настройках.")

        @dp.startup()
        async def on_bot_startup():
            nonlocal sdb_version
            bot_info = await bot.get_me()
            services.logger.info(f"⚡ Событие startup для Dispatcher (бот: @{bot_info.username})...")
            try:
                await bot.delete_webhook(drop_pending_updates=True)
                services.logger.info("Webhook удален, ожидающие обновления сброшены.")
            except Exception as e_startup_hook:
                services.logger.error(f"Ошибка на этапе startup диспетчера: {e_startup_hook}", exc_info=True)

            services.logger.success(f"✅ Бот SDB @{bot_info.username} успешно запущен и готов к работе!")
            if services.config.core.super_admins:
                for admin_id in services.config.core.super_admins:
                    try:
                        await bot.send_message(admin_id, f"🚀 Бот SDB @{bot_info.username} (v{sdb_version}) успешно запущен!")
                    except Exception as e_send:
                        services.logger.warning(f"Не удалось отправить уведомление о запуске админу {admin_id}: {e_send}")

        @dp.shutdown()
        async def on_bot_shutdown():
            nonlocal logging_manager
            bot_info = await bot.get_me()
            services.logger.info(f"⏳ Событие shutdown для Dispatcher. Начало остановки бота @{bot_info.username}...")

            if services and services.config.core.super_admins:
                for admin_id in services.config.core.super_admins:
                    try:
                        await bot.send_message(admin_id, f"🛑 Бот SDB @{bot_info.username} останавливается...")
                    except Exception as e_send:
                         services.logger.warning(f"Не удалось отправить уведомление об остановке админу {admin_id}: {e_send}")

            if logging_manager:
                await logging_manager.shutdown_logging()

            if pid_file_actual_path.exists():
                try:
                    pid_in_file = int(pid_file_actual_path.read_text().strip())
                    if pid_in_file == os.getpid():
                        pid_file_actual_path.unlink(missing_ok=True)
                        global_logger.info(f"PID-файл {pid_file_actual_path} удален при штатной остановке (on_bot_shutdown).")
                    else:
                         global_logger.info(f"PID-файл {pid_file_actual_path} (PID: {pid_in_file}) не принадлежит текущему процессу (PID: {os.getpid()}). Удаление пропущено в on_bot_shutdown.")
                except Exception as e_unlink_pid_shutdown:
                    global_logger.error(f"Не удалось удалить PID-файл {pid_file_actual_path} в on_bot_shutdown: {e_unlink_pid_shutdown}")

            global_logger.info(f"🏁 Процедура остановки бота @{bot_info.username} почти завершена (сервисы будут закрыты в finally).")

        bot_username_for_log = (await bot.get_me()).username
        global_logger.info(f"📡 Запуск Telegram Bot Polling для @{bot_username_for_log}...")

        await dp.start_polling(bot)
        exit_code_internal = 0

    except (KeyboardInterrupt, SystemExit) as e_exit:
        global_logger.info(f"🚨 Получен сигнал остановки ({type(e_exit).__name__}). Поллинг прерывается...")
        exit_code_internal = 0
    except Exception as e_main_run:
        global_logger.critical(f"❌ КРИТИЧЕСКАЯ ОШИБКА в основной функции run_sdb_bot: {e_main_run}", exc_info=True)
        exit_code_internal = 1
    finally:
        global_logger.info("Блок finally в run_sdb_bot.")

        if bot:
            try:
                global_logger.info("Закрытие сессии бота будет обработано Aiogram при завершении Dispatcher.start_polling.")
            except TelegramRetryAfter as e_retry:
                global_logger.warning(f"TelegramRetryAfter при попытке закрыть сессию бота (или уже во время ее закрытия Aiogram): {e_retry}")
            except Exception as e_bot_close:
                global_logger.warning(f"Предупреждение при операциях с объектом бота в finally: {type(e_bot_close).__name__} - {e_bot_close}", exc_info=True)

        if services:
            try:
                await services.close_services()
                global_logger.info("Все сервисы BotServicesProvider корректно остановлены в блоке finally.")
            except Exception as e_services_close:
                global_logger.error(f"Ошибка при закрытии сервисов в блоке finally: {e_services_close}", exc_info=True)

        if logging_manager and logging_manager._is_initialized:
            await logging_manager.shutdown_logging()

        if pid_file_actual_path.exists():
            try:
                pid_in_file = int(pid_file_actual_path.read_text().strip())
                if pid_in_file == os.getpid():
                    pid_file_actual_path.unlink(missing_ok=True)
                    global_logger.info(f"PID-файл {pid_file_actual_path} удален/проверен в блоке finally.")
            except Exception as e_final_pid_unlink:
                global_logger.warning(f"Не удалось окончательно удалить/проверить PID-файл {pid_file_actual_path}: {e_final_pid_unlink}")

        bot_name_display = getattr(bot, 'id', 'N/A') if bot else 'N/A'
        if bot and hasattr(bot, 'username') and bot.username:
            bot_name_display = f"@{bot.username} (ID: {bot.id})"

        global_logger.info(f"🏁 Работа бота ({bot_name_display}) завершена. Внутренний код выхода: {exit_code_internal}")
        return exit_code_internal


======================================================================

------------------------------ FILE: alembic_migrations/script.py.mako ------------------------------
# alembic_migrations/script.py.mako
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op # type: ignore
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "    pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "    pass"}


======================================================================

------------------------------ FILE: alembic_migrations/env.py ------------------------------
# alembic_migrations/env.py

import asyncio
from logging.config import fileConfig
import os
import sys
from pathlib import Path
import importlib
from typing import List, Optional

# --- Настройка путей ---
ALEMBIC_DIR = Path(__file__).resolve().parent
SDB_PROJECT_ROOT = ALEMBIC_DIR.parent

if str(SDB_PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(SDB_PROJECT_ROOT))
    print(f"[Alembic Env] Корень проекта SDB ({SDB_PROJECT_ROOT}) добавлен в sys.path.")
else:
    sys.path.remove(str(SDB_PROJECT_ROOT))
    sys.path.insert(0, str(SDB_PROJECT_ROOT))
    print(f"[Alembic Env] Корень проекта SDB ({SDB_PROJECT_ROOT}) установлен на первую позицию в sys.path.")


from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import create_async_engine, AsyncEngine

from alembic import context # type: ignore

try:
    from core.app_settings import settings as sdb_settings
    from core.database.base import SDBBaseModel
    from core.database.manager import DBManager
    from core.module_loader import ModuleLoader, ModuleInfo
    from core.services_provider import BotServicesProvider
    from core.database import core_models # noqa: F401
    print("[Alembic Env] Основные компоненты SDB успешно импортированы.")
except ImportError as e_imp:
    print(f"[ALEMBIC ENV ERROR] Критическая ошибка импорта компонентов SDB: {e_imp}")
    print(f"Текущий sys.path при ошибке: {sys.path}")
    sys.exit(1)

target_metadata = SDBBaseModel.metadata

try:
    print("[Alembic Env] Начало динамического импорта моделей активных модулей...")
    temp_bsp_for_alembic = BotServicesProvider(settings=sdb_settings)
    module_loader_for_alembic = ModuleLoader(
        settings=sdb_settings,
        services_provider=temp_bsp_for_alembic # Передаем созданный BSP
    )
    module_loader_for_alembic.scan_all_available_modules()
    module_loader_for_alembic._load_enabled_plugin_names() # Используем _load_enabled_plugin_names

    # Для Alembic нам нужны модели всех АКТИВНЫХ ПЛАГИНОВ
    active_plugin_module_infos: List[ModuleInfo] = [
        info for name, info in module_loader_for_alembic.available_modules.items()
        # ИЗМЕНЕНИЕ ЗДЕСЬ: используем enabled_plugin_names
        if not info.is_system_module and name in module_loader_for_alembic.enabled_plugin_names and info.manifest and info.path
    ]

    if active_plugin_module_infos:
        print(f"[Alembic Env] Найдено {len(active_plugin_module_infos)} активных плагинов для проверки моделей.")
        for module_info in active_plugin_module_infos:
            print(f"[Alembic Env] Проверка плагина: {module_info.name}")
            module_models_file = module_info.path / "models.py"
            module_models_pkg_init = module_info.path / "models" / "__init__.py"
            
            imported_this_module = False
            if module_models_file.is_file():
                # Для плагинов базовый путь импорта "modules"
                import_target = f"modules.{module_info.path.name}.models"
                print(f"[Alembic Env] Попытка импорта моделей из файла: {import_target}")
                try:
                    importlib.import_module(import_target)
                    print(f"[Alembic Env] > Успешно импортированы модели из файла: {import_target}")
                    imported_this_module = True
                except ImportError as e_imp_f:
                    print(f"[Alembic Env] > Ошибка импорта моделей из файла {import_target}: {e_imp_f}")
                except Exception as e_f:
                    print(f"[Alembic Env] > Неожиданная ошибка при импорте моделей из файла {import_target}: {type(e_f).__name__} - {e_f}")
            
            if not imported_this_module and module_models_pkg_init.is_file():
                import_target = f"modules.{module_info.path.name}.models" 
                print(f"[Alembic Env] Попытка импорта моделей из пакета: {import_target}")
                try:
                    importlib.import_module(import_target)
                    print(f"[Alembic Env] > Успешно импортирован пакет моделей: {import_target}")
                except ImportError as e_imp_p:
                    print(f"[Alembic Env] > Ошибка импорта пакета моделей {import_target}: {e_imp_p}")
                except Exception as e_p:
                    print(f"[Alembic Env] > Неожиданная ошибка при импорте пакета моделей {import_target}: {type(e_p).__name__} - {e_p}")
            elif not imported_this_module and not module_models_file.is_file():
                 print(f"[Alembic Env] > Для плагина '{module_info.name}' не найден ни файл models.py, ни пакет models/__init__.py.")
    else:
        print("[Alembic Env] Активных плагинов для импорта моделей не найдено.")
    
    # Если у вас есть системные модули в core/sys_modules/ с моделями,
    # и они не импортируются автоматически (например, через core.database.core_models),
    # их нужно будет импортировать здесь явно или добавить механизм их обнаружения.
    # Пример:
    # print("[Alembic Env] Проверка системных модулей ядра...")
    # sys_module_path = SDB_PROJECT_ROOT / "core" / "sys_modules" / "my_sys_module_with_models"
    # if (sys_module_path / "models.py").is_file():
    #    importlib.import_module("core.sys_modules.my_sys_module_with_models.models")
    #    print("[Alembic Env] Модели из 'my_sys_module_with_models' импортированы.")

    print(f"[Alembic Env] Динамический импорт моделей завершен. Количество таблиц в target_metadata: {len(target_metadata.tables)}")

except Exception as e_load_mod_env:
    print(f"[ALEMBIC ENV ERROR] Ошибка при загрузке или импорте моделей модулей в env.py: {e_load_mod_env}")
    import traceback
    traceback.print_exc()
    print("[ALEMBIC ENV WARNING] Из-за ошибки выше, Alembic может не видеть модели некоторых или всех модулей.")

config = context.config
try:
    temp_db_manager_for_url = DBManager(db_settings=sdb_settings.db, app_settings=sdb_settings)
    db_connection_url = temp_db_manager_for_url._build_db_url()
    config.set_main_option("sqlalchemy.url", db_connection_url)
    print(f"[Alembic Env] sqlalchemy.url установлен из настроек SDB: {db_connection_url[:db_connection_url.find('://')+3]}...")
except Exception as e_db_url_env:
    print(f"[ALEMBIC ENV ERROR] Ошибка получения URL БД из настроек SDB: {e_db_url_env}")
    sys.exit(1)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

def _get_dialect_name_from_configured_context() -> Optional[str]:
    try:
        migration_context = context.get_context()
        if migration_context and migration_context.dialect:
            return migration_context.dialect.name.lower()
    except Exception: pass
    return None

def include_object(object, name, type_, reflected, compare_to):
    if type_ == "table" and object.metadata != target_metadata:
        return False
    return True

def compare_type(alem_context, inspected_column, metadata_column, inspected_type, metadata_type):
    dialect_name = _get_dialect_name_from_configured_context()
    if not dialect_name and alem_context.dialect:
        dialect_name = alem_context.dialect.name.lower()

    if dialect_name == 'sqlite':
        inspected_type_str = str(inspected_type).upper()
        metadata_type_str = str(metadata_type).upper()
        if metadata_type_str == 'BIGINTEGER' and inspected_type_str == 'INTEGER': return False
        if metadata_type_str == 'BOOLEAN' and inspected_type_str == 'INTEGER': return False
        if 'DATETIME' in metadata_type_str and 'TIMESTAMP' in inspected_type_str: return False
        if 'TIMESTAMP' in metadata_type_str and 'DATETIME' in inspected_type_str: return False
    elif dialect_name == 'mysql':
        if str(metadata_type).upper() == 'BOOLEAN' and str(inspected_type).upper() == 'TINYINT(1)': return False
    return None

def render_item(type_, obj, autogen_context):
    dialect_name = _get_dialect_name_from_configured_context()
    if not dialect_name and autogen_context.dialect:
         dialect_name = autogen_context.dialect.name.lower()
         
    if dialect_name == 'sqlite':
        if type_ == "table_comment" or type_ == "column_comment":
            return None 
    return False

def run_migrations_offline() -> None:
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=target_metadata, literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        include_object=include_object,
        compare_type=compare_type,
        compare_server_default=True,
        render_item=render_item
    )
    with context.begin_transaction():
        context.run_migrations()

def do_run_migrations(connection: Connection) -> None:
    context.configure(
        connection=connection, target_metadata=target_metadata,
        include_object=include_object,
        compare_type=compare_type,
        compare_server_default=True,
        render_item=render_item
    )
    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online() -> None:
    db_url_for_engine = config.get_main_option("sqlalchemy.url")
    if not db_url_for_engine:
        raise RuntimeError("sqlalchemy.url не найден в конфигурации Alembic для online режима!")

    connectable_engine: AsyncEngine = create_async_engine(
        db_url_for_engine,
        poolclass=pool.NullPool,
    )
    
    async with connectable_engine.connect() as connection:
        await connection.run_sync(do_run_migrations)
    await connectable_engine.dispose()

if context.is_offline_mode():
    print("[Alembic Env] Запуск миграций в offline режиме...")
    run_migrations_offline()
else:
    print("[Alembic Env] Запуск миграций в online режиме...")
    asyncio.run(run_migrations_online())


======================================================================

------------------------------ FILE: scripts/commands.txt ------------------------------
find core/admin -name "*.py" -exec echo "--- START OF FILE {} ---" \; -exec cat {} \; -exec echo "\n--- END OF FILE {} ---" \; > admin.txt 


======================================================================

------------------------------ FILE: scripts/replace_uk_to_ua.py ------------------------------
# SwiftDevBot/scripts/replace_uk_to_ua.py
import os
from pathlib import Path
import re

# --- Настройки ---
PROJECT_ROOT = Path(".")  # Запускать из корня проекта SwiftDevBot
FILE_EXTENSIONS_TO_PROCESS = {".py", ".yaml", ".yml", ".json", ".md", ".env", ".po", ".pot", ".example", ".ini"}
EXCLUDE_DIRS_SCRIPT = {".git", ".venv", "__pycache__", "docs", "site", "build", "dist", "project_snapshot.txt"} 
DRY_RUN = False # Если True, скрипт только покажет, что он бы заменил, но не будет изменять файлы

REPLACEMENT_PATTERNS = {
    r"(['\"])uk\1": r"\1ua\1",
    r"(\buk\b)(?=[/\s,\]\}])": r"ua",
    r"Language: ua": r"Language: ua",
    r'(available_locales:\s*\[[^\]]*?)(\buk\b)([^\]]*?\])': r'\1ua\3', 
    r'(default_locale:\s*[\'"])uk([\'"])': r'\1ua\2', 
    r'(SDB_I18N_AVAILABLE_LOCALES\s*=\s*[\'"])([^\'"]*?)(\buk\b)([^\'"]*)([\'"])': r'\1\2ua\4\5', 
    r'(SDB_I18N_DEFAULT_LOCALE\s*=\s*[\'"])uk([\'"])': r'\1ua\2', 
}

RENAME_PATTERNS = {
    lambda p: p.is_dir() and p.name == "ua" and p.parent.name == "locales" and p.parent.parent == PROJECT_ROOT.resolve(): lambda p: p.with_name("ua"),
}

changed_content_files = set()
renamed_paths_log = []


def process_file_content(file_path: Path, dry_run: bool) -> int:
    global changed_content_files
    changes_count = 0
    try:
        content = file_path.read_text(encoding="utf-8")
        # original_content = content # Не используется, можно убрать
        
        file_actually_changed_by_script = False
        current_content_for_file = content # Работаем с этой переменной

        for pattern, replacement in REPLACEMENT_PATTERNS.items():
            # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
            # re.subn(pattern, replacement, string, ...)
            new_content_after_sub, num_subs = re.subn(pattern, replacement, current_content_for_file, flags=re.IGNORECASE)
            # --- КОНЕЦ ИСПРАВЛЕНИЯ ---
            if num_subs > 0:
                current_content_for_file = new_content_after_sub # Применяем изменение для следующего паттерна
                changes_count += num_subs
                file_actually_changed_by_script = True
                if dry_run:
                    # Для DRY_RUN просто сообщаем о потенциальном изменении, не меняя 'content' для записи
                    print(f"[DRY RUN] Would change content in {file_path} (pattern: '{pattern}') - {num_subs} occurrences")
                else:
                    print(f"Changed content in {file_path} (pattern: '{pattern}') - {num_subs} occurrences")
        
        if file_actually_changed_by_script: 
            changed_content_files.add(file_path.relative_to(PROJECT_ROOT)) 
            if not dry_run:
                # Записываем финальный измененный контент
                file_path.write_text(current_content_for_file, encoding="utf-8")
            
    except Exception as e:
        print(f"Error processing file content {file_path}: {e}")
    return changes_count

def rename_paths_script(root_path: Path, dry_run: bool):
    global renamed_paths_log
    local_renamed_paths_log = [] 

    paths_to_rename_candidates = []
    for path_obj in root_path.rglob("*"): 
        if any(excluded_dir in path_obj.parts for excluded_dir in EXCLUDE_DIRS_SCRIPT):
            continue
        for matcher_func, new_name_func in RENAME_PATTERNS.items():
            if matcher_func(path_obj):
                new_path = new_name_func(path_obj)
                if new_path != path_obj:
                     paths_to_rename_candidates.append((path_obj, new_path))
                break 

    paths_to_rename_candidates.sort(key=lambda x: len(x[0].parts), reverse=True)

    for old_path, new_path in paths_to_rename_candidates:
        if old_path.exists(): 
            log_entry = f"{old_path.relative_to(PROJECT_ROOT)} -> {new_path.relative_to(PROJECT_ROOT)}"
            if dry_run:
                print(f"[DRY RUN] Would rename: {log_entry}")
                local_renamed_paths_log.append(log_entry)
            else:
                try:
                    if new_path.exists():
                        print(f"Warning: Target path {new_path} already exists. Skipping rename of {old_path}")
                        continue
                    old_path.rename(new_path)
                    print(f"Renamed: {log_entry}")
                    local_renamed_paths_log.append(log_entry)
                except Exception as e:
                    print(f"Error renaming {old_path} to {new_path}: {e}")
    
    renamed_paths_log.extend(local_renamed_paths_log) 
    return bool(local_renamed_paths_log)


def main():
    global changed_content_files, renamed_paths_log
    total_files_processed = 0
    total_changes_made = 0

    print(f"Starting replacement process in {PROJECT_ROOT.resolve()}")
    if DRY_RUN:
        print("DRY RUN mode: No files will be modified.")

    print("\n--- Renaming paths ---")
    renamed_anything_paths = rename_paths_script(PROJECT_ROOT, DRY_RUN)
    if not DRY_RUN and renamed_anything_paths:
        print("Some paths were renamed. Content processing will use new paths if applicable.")
    elif not renamed_anything_paths:
        print("No paths matched renaming patterns.")

    print("\n--- Processing file content ---")
    for root_str, dirs, files in os.walk(PROJECT_ROOT, topdown=True):
        root_path = Path(root_str)
        
        if any(excluded_dir in root_path.relative_to(PROJECT_ROOT).parts for excluded_dir in EXCLUDE_DIRS_SCRIPT):
            dirs[:] = [] 
            continue

        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS_SCRIPT]
        
        for filename in files:
            file_path = root_path / filename
            if file_path.suffix.lower() in FILE_EXTENSIONS_TO_PROCESS:
                if any(excluded_dir in file_path.relative_to(PROJECT_ROOT).parts for excluded_dir in EXCLUDE_DIRS_SCRIPT):
                    continue
                
                changes = process_file_content(file_path, DRY_RUN)
                if changes > 0:
                    total_changes_made += changes
                total_files_processed += 1
    
    print("\n" + "="*20 + " SCRIPT EXECUTION SUMMARY " + "="*20)
    if DRY_RUN:
        print("\n⚠️  THIS WAS A DRY RUN. NO ACTUAL CHANGES WERE MADE TO FILES OR PATHS. ⚠️")

    print(f"\nTotal unique files with content changes: {len(changed_content_files)}")
    if changed_content_files:
        print("Files with content changes (relative to project root):")
        for f_path in sorted(list(changed_content_files)):
            print(f"  - {f_path}")
    
    print(f"\nTotal paths renamed: {len(renamed_paths_log)}")
    if renamed_paths_log:
        print("Renamed paths:")
        for entry in renamed_paths_log:
            print(f"  - {entry}")
            
    print(f"\nTotal individual text replacements made: {total_changes_made}")
    print(f"Total files scanned for content processing: {total_files_processed}")
    
    if not DRY_RUN and (changed_content_files or renamed_paths_log):
        print("\nRECOMMENDATION: Review all changes with 'git diff' before committing!")
    elif not DRY_RUN:
        print("No changes were made to file contents or paths.")

if __name__ == "__main__":
    if not DRY_RUN:
        confirm = input(
            "This script will attempt to modify project files and rename paths to replace 'ua' with 'ua'.\n"
            "🔥 MAKE SURE YOU HAVE A RELIABLE BACKUP (e.g., committed to Git). 🔥\n"
            "This operation can have unintended consequences if patterns are not precise.\n"
            "It's highly recommended to run with DRY_RUN=True first and review the output.\n\n"
            "Type 'YES_I_AM_ABSOLUTELY_SURE' to proceed with actual changes: "
        )
        if confirm != "YES_I_AM_ABSOLUTELY_SURE":
            print("Aborted by user.")
            exit()
    main()


======================================================================

------------------------------ FILE: scripts/test_db_support.py ------------------------------
#!/usr/bin/env python3
"""
Скрипт для тестирования поддержки разных типов БД.
"""
import sys
import os
from pathlib import Path

# Добавляем корень проекта в путь
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from sqlalchemy import create_engine, text
from core.database.db_utils import DatabaseDialectHandler, get_db_info_query


def test_sqlite():
    """Тестирует SQLite"""
    print("\n=== Тестирование SQLite ===")
    engine = create_engine("sqlite:///:memory:")
    
    features = DatabaseDialectHandler.get_dialect_features(engine)
    types = DatabaseDialectHandler.get_recommended_types(engine)
    
    print(f"Поддерживаемые функции: {features}")
    print(f"Рекомендуемые типы: {types}")
    
    with engine.connect() as conn:
        result = conn.execute(text("SELECT sqlite_version()"))
        version = result.scalar()
        print(f"Версия SQLite: {version}")
    
    return True


def test_mysql():
    """Тестирует MySQL (если доступен)"""
    print("\n=== Тестирование MySQL ===")
    # Пример URL - замените на реальный
    mysql_url = "mysql+pymysql://root:Sova3568@192.168.31.3:33066/sdb_mysql_db?charset=utf8mb4"

    try:
        engine = create_engine(mysql_url)
        features = DatabaseDialectHandler.get_dialect_features(engine)
        types = DatabaseDialectHandler.get_recommended_types(engine)
        
        print(f"Поддерживаемые функции: {features}")
        print(f"Рекомендуемые типы: {types}")
        
        with engine.connect() as conn:
            result = conn.execute(text("SELECT VERSION()"))
            version = result.scalar()
            print(f"Версия MySQL: {version}")
        
        return True
    except Exception as e:
        print(f"MySQL недоступен: {e}")
        return False


def test_postgresql():
    """Тестирует PostgreSQL (если доступен)"""
    print("\n=== Тестирование PostgreSQL ===")
    # Пример URL - замените на реальный
    pg_url = "postgresql+psycopg://soverx:Sova3568@192.168.31.3:2345/sdb_database"
    
    try:
        engine = create_engine(pg_url)
        features = DatabaseDialectHandler.get_dialect_features(engine)
        types = DatabaseDialectHandler.get_recommended_types(engine)
        
        print(f"Поддерживаемые функции: {features}")
        print(f"Рекомендуемые типы: {types}")
        
        with engine.connect() as conn:
            result = conn.execute(text("SELECT version()"))
            version = result.scalar()
            print(f"Версия PostgreSQL: {version}")
        
        return True
    except Exception as e:
        print(f"PostgreSQL недоступен: {e}")
        return False


if __name__ == "__main__":
    print("Тестирование поддержки баз данных...")
    
    results = {
        'SQLite': test_sqlite(),
        'MySQL': test_mysql(),
        'PostgreSQL': test_postgresql(),
    }
    
    print("\n=== Результаты тестирования ===")
    for db_name, success in results.items():
        status = "✅ Работает" if success else "❌ Недоступен"
        print(f"{db_name}: {status}")


======================================================================

------------------------------ FILE: scripts/reset_alembic.py ------------------------------
#!/usr/bin/env python3
"""
Скрипт для очистки состояния Alembic в MySQL базе данных.
Читает параметры подключения из переменной окружения SDB_DB_MYSQL_DSN.
"""
import asyncio
import os
import sys
from urllib.parse import urlparse, parse_qs
from pathlib import Path

# Добавляем корень проекта в путь, чтобы можно было импортировать python-dotenv, если он в venv
project_root = Path(__file__).resolve().parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

try:
    import aiomysql
    from dotenv import load_dotenv, find_dotenv
except ImportError as e:
    print(f"✗ Ошибка импорта необходимых библиотек: {e}")
    print("Пожалуйста, установите aiomysql и python-dotenv: pip install aiomysql python-dotenv")
    sys.exit(1)

# Загрузка переменных окружения из .env файла
env_file = find_dotenv(filename=".env", usecwd=True, raise_error_if_not_found=False)
if env_file:
    print(f"ℹ️ Загрузка переменных окружения из: {env_file}")
    load_dotenv(env_file)
else:
    print("⚠️  .env файл не найден. Скрипт будет полагаться на системные переменные окружения.")

async def reset_alembic_state():
    """Очищает таблицу alembic_version из MySQL"""
    
    mysql_dsn = os.getenv("SDB_DB_MYSQL_DSN")
    
    if not mysql_dsn:
        print("✗ Ошибка: Переменная окружения SDB_DB_MYSQL_DSN не установлена.")
        print("  Пожалуйста, установите ее в вашем .env файле или системных переменных.")
        print("  Пример: SDB_DB_MYSQL_DSN=\"mysql+aiomysql://user:pass@host:port/dbname?charset=utf8mb4\"")
        return

    print(f"ℹ️ Используется DSN из SDB_DB_MYSQL_DSN: mysql+aiomysql://<user>:<pass>@<host>:<port>/<dbname>...")

    try:
        # Парсинг DSN для aiomysql.connect, так как он не всегда принимает DSN напрямую
        # (хотя SQLAlchemy create_engine его парсит).
        # Формат DSN для SQLAlchemy: mysql+driver://user:password@host:port/database?params
        # Нам нужно извлечь user, password, host, port, database.
        
        # Убираем схему и драйвер, если они есть, для urlparse
        parsed_url_str = mysql_dsn
        if parsed_url_str.startswith("mysql+aiomysql://"):
            parsed_url_str = parsed_url_str[len("mysql+aiomysql://"):]
        elif parsed_url_str.startswith("mysql://"): # На случай, если кто-то укажет без драйвера
             parsed_url_str = parsed_url_str[len("mysql://"):]

        # Добавляем временную схему, если ее нет, чтобы urlparse корректно работал
        if "://" not in parsed_url_str:
            parsed_url_str = f"temp://{parsed_url_str}"

        parsed_url = urlparse(parsed_url_str)
        
        db_user = parsed_url.username
        db_password = parsed_url.password
        db_host = parsed_url.hostname
        db_port = parsed_url.port or 3306 # Стандартный порт MySQL
        db_name = parsed_url.path.lstrip('/') if parsed_url.path else None
        
        query_params = parse_qs(parsed_url.query)
        db_charset = query_params.get('charset', ['utf8mb4'])[0] # Дефолт utf8mb4

        if not all([db_user, db_host, db_name]):
            print("✗ Ошибка: Не удалось корректно распарсить DSN. Убедитесь, что он содержит user, host и имя базы данных.")
            print(f"  Распарсено: user='{db_user}', host='{db_host}', port='{db_port}', dbname='{db_name}'")
            return

        connection_params = {
            'host': db_host,
            'port': int(db_port),
            'user': db_user,
            'db': db_name,
            'charset': db_charset
        }
        if db_password: # Пароль может отсутствовать
            connection_params['password'] = db_password
        
        print(f"ℹ️ Подключение к MySQL: host={db_host}, port={db_port}, user={db_user}, db={db_name}, charset={db_charset}")

        connection = await aiomysql.connect(**connection_params) # type: ignore
        
        async with connection.cursor() as cursor:
            # Удаляем таблицу alembic_version если она существует
            await cursor.execute("DROP TABLE IF EXISTS alembic_version")
            print("✓ Таблица alembic_version удалена из MySQL.")
            
        # await connection.commit() # DROP TABLE обычно автокоммитится в MySQL, но для явности можно оставить
        connection.close()
        print("✓ Состояние Alembic для MySQL сброшено.")
        
    except aiomysql.Error as e_mysql: # Ловим специфичные ошибки aiomysql
        print(f"✗ Ошибка aiomysql: Код {e_mysql.args[0]}, Сообщение: {e_mysql.args[1] if len(e_mysql.args) > 1 else str(e_mysql)}")
    except Exception as e:
        print(f"✗ Непредвиденная ошибка при сбросе состояния MySQL: {type(e).__name__} - {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(reset_alembic_state())


======================================================================

------------------------------ FILE: scripts/snapshot_generator.py ------------------------------
import os
from pathlib import Path

# --- Настройки ---
OUTPUT_FILENAME = "project_snapshot.txt"
EXCLUDE_DIRS = {
    ".venv", "venv", "__pycache__", ".git", ".idea", ".vscode",
    "build", "dist", "*.egg-info", "node_modules",
    "Data/Cache", "Data/LogsBot", "Data/Temp", "Data/Uploads", # Из твоей структуры Data/
    "logs" # Общая папка логов, если есть
    "modules", # Папка с модулями, если есть
}
EXCLUDE_FILES = {
    OUTPUT_FILENAME,  # Не включать сам файл вывода
    ".DS_Store",
    "*.pyc",
    "*.swp",
    "*.swo",
    # Добавь сюда файлы, которые не нужно включать, например, большие бинарники
    "project_snapshot.txt"
    "TEST.md"
}
EXCLUDE_EXTENSIONS = {
    ".sqlite", ".db", ".db-journal", # Файлы баз данных (могут быть большими)
    ".log", # Уже покрывается EXCLUDE_DIRS, но на всякий случай
    # Добавь расширения, которые не нужно включать
    # ".zip", ".tar.gz"
}
MAX_FILE_SIZE_MB = 2  # Максимальный размер файла для включения его содержимого (в МБ)
MAX_TOTAL_OUTPUT_SIZE_MB = 50 # Примерный лимит на общий размер выходного файла (чтобы не был гигантским)

# Кодировка для чтения файлов
FILE_ENCODING = "utf-8"
# --- Конец настроек ---

def should_exclude_dir(dir_name, exclude_set):
    return dir_name in exclude_set

def should_exclude_file(file_name, file_path, exclude_files_set, exclude_ext_set):
    if file_name in exclude_files_set:
        return True
    if file_path.suffix.lower() in exclude_ext_set:
        return True
    # Можно добавить проверку по маске, если нужно
    # import fnmatch
    # for pattern in exclude_files_set:
    #     if fnmatch.fnmatch(file_name, pattern):
    #         return True
    return False

def get_dir_tree(start_path, indent_char="    ", max_depth=10):
    tree_lines = []
    # Ограничение на глубину рекурсии для предотвращения зацикливания или слишком большого дерева
    if max_depth < 0:
        return ["... (Max depth reached)"]

    try:
        items = sorted(list(start_path.iterdir()), key=lambda p: (p.is_file(), p.name.lower()))
    except PermissionError:
        return [f"... (Permission denied: {start_path})"]
    except FileNotFoundError:
        return [f"... (Not found: {start_path})"]


    for i, item in enumerate(items):
        is_last = i == (len(items) - 1)
        prefix = indent_char + ("└── " if is_last else "├── ")

        if item.is_dir():
            if should_exclude_dir(item.name, EXCLUDE_DIRS):
                tree_lines.append(f"{prefix}{item.name}/ [EXCLUDED_DIR]")
                continue
            tree_lines.append(f"{prefix}{item.name}/")
            # Рекурсивно добавляем поддиректорию
            # Уменьшаем max_depth для каждой итерации
            sub_indent = indent_char + ("    " if is_last else "│   ")
            tree_lines.extend([sub_indent + line for line in get_dir_tree(item, indent_char, max_depth -1)])
        else:
            if should_exclude_file(item.name, item, EXCLUDE_FILES, EXCLUDE_EXTENSIONS):
                tree_lines.append(f"{prefix}{item.name} [EXCLUDED_FILE]")
                continue
            tree_lines.append(f"{prefix}{item.name}")
            
    return tree_lines


def main():
    project_root = Path(".") # Запускать из корня проекта
    snapshot_content = []
    current_total_size = 0
    max_total_bytes = MAX_TOTAL_OUTPUT_SIZE_MB * 1024 * 1024

    # 1. Структура проекта
    snapshot_content.append("=" * 30 + " PROJECT STRUCTURE " + "=" * 30)
    snapshot_content.append(f"{project_root.resolve().name}/")
    tree_str = "\n".join(get_dir_tree(project_root))
    snapshot_content.append(tree_str)
    snapshot_content.append("\n" + "=" * 70 + "\n")
    current_total_size += len(tree_str.encode(FILE_ENCODING, errors='ignore'))


    # 2. Содержимое файлов
    for item_path in project_root.rglob("*"): # Рекурсивный обход всех файлов и папок
        if current_total_size > max_total_bytes:
            snapshot_content.append("\n... (Total output size limit reached, stopping file content inclusion) ...\n")
            print(f"Warning: Total output size limit ({MAX_TOTAL_OUTPUT_SIZE_MB}MB) reached. Some file contents might be omitted.")
            break

        # Проверка на исключение директорий на уровне rglob
        is_in_excluded_dir = False
        for part in item_path.relative_to(project_root).parts:
            if part in EXCLUDE_DIRS:
                is_in_excluded_dir = True
                break
        if is_in_excluded_dir and item_path.is_dir(): # Если сама папка исключена, пропускаем ее rglob
            continue
        if item_path.is_dir(): # Если это директория, пропускаем (уже обработали в дереве)
            if item_path.name in EXCLUDE_DIRS: # Доп. проверка
                 continue
            continue


        relative_path_str = str(item_path.relative_to(project_root))

        # Проверяем, не находится ли файл внутри исключенной директории
        # Это нужно, т.к. rglob может дать файлы из поддиректорий, которые мы хотим исключить целиком
        parent_excluded = False
        for parent in item_path.parents:
            if parent.name in EXCLUDE_DIRS:
                parent_excluded = True
                break
        if parent_excluded:
            # print(f"Skipping (parent excluded): {relative_path_str}")
            continue
            
        if item_path.name in EXCLUDE_DIRS: # Если сам файл - это имя исключенной директории (маловероятно, но для полноты)
            # print(f"Skipping (matches excluded dir name): {relative_path_str}")
            continue

        if should_exclude_file(item_path.name, item_path, EXCLUDE_FILES, EXCLUDE_EXTENSIONS):
            # print(f"Skipping (excluded file/ext): {relative_path_str}")
            continue
        
        snapshot_content.append("-" * 30 + f" FILE: {relative_path_str} " + "-" * 30)
        try:
            file_size = item_path.stat().st_size
            if file_size > MAX_FILE_SIZE_MB * 1024 * 1024:
                snapshot_content.append(f"[CONTENT OMITTED - File size ({file_size / (1024*1024):.2f} MB) > {MAX_FILE_SIZE_MB} MB]\n")
                print(f"Skipping content of large file: {relative_path_str}")
            else:
                with open(item_path, "r", encoding=FILE_ENCODING, errors="ignore") as f:
                    content = f.read()
                snapshot_content.append(content + "\n")
                current_total_size += len(content.encode(FILE_ENCODING, errors='ignore'))

        except Exception as e:
            snapshot_content.append(f"[ERROR READING FILE: {e}]\n")
            print(f"Error reading file {relative_path_str}: {e}")
        snapshot_content.append("\n" + "=" * 70 + "\n")


    # 3. Запись в файл
    try:
        with open(OUTPUT_FILENAME, "w", encoding=FILE_ENCODING) as f:
            f.write("\n".join(snapshot_content))
        print(f"Project snapshot saved to: {OUTPUT_FILENAME}")
        print(f"Approximate total output size: {current_total_size / (1024*1024):.2f} MB")

    except Exception as e:
        print(f"Error writing snapshot file: {e}")

if __name__ == "__main__":
    main()


======================================================================

------------------------------ FILE: scripts/create_project_structure.py ------------------------------
from pathlib import Path

# Имя корневой папки проекта (если скрипт внутри нее, то ".")
PROJECT_ROOT_NAME = "." # Если скрипт в корне SwiftDevBot
# Если скрипт снаружи, то PROJECT_ROOT_NAME = "SwiftDevBot"

def create_dir(path: Path):
    path.mkdir(parents=True, exist_ok=True)
    print(f"Создана директория: {path}")

def create_file(path: Path, content: str = ""):
    path.touch(exist_ok=True)
    if content:
        path.write_text(content, encoding='utf-8')
    print(f"Создан файл: {path}")

def main():
    project_root = Path(PROJECT_ROOT_NAME).resolve()
    
    if PROJECT_ROOT_NAME != ".": # Если скрипт не в корне, создаем корень
        create_dir(project_root)

    print(f"Создание структуры для проекта: {project_root}")

    # 1. Файлы и папки в корне проекта
    create_file(project_root / ".env")
    create_file(project_root / "run_bot.py")
    create_file(project_root / "sdb.py") # Или sdb без расширения, если потом сделаешь исполняемым
    create_file(project_root / "requirements.txt")
    create_file(project_root / "requirements-dev.txt")
    create_file(project_root / "alembic.ini")
    create_file(project_root / "config.yaml", "# Шаблон/дефолтный конфиг")
    
    # 2. Директория ядра core/
    core_path = project_root / "core"
    core_subdirs = ["database", "cache", "http_client", "ui", "rbac", "utils_core", "i18n", "events"]
    for subdir in core_subdirs:
        create_dir(core_path / subdir)
        create_file(core_path / subdir / "__init__.py")

    create_file(core_path / "__init__.py")
    create_file(core_path / "app_settings.py")
    create_file(core_path / "services_provider.py")
    create_file(core_path / "bot_entrypoint.py")
    create_file(core_path / "module_loader.py")

    create_file(core_path / "database" / "base.py")
    create_file(core_path / "database" / "manager.py")
    create_file(core_path / "database" / "core_models.py")

    create_file(core_path / "cache" / "manager.py")
    create_file(core_path / "http_client" / "manager.py")

    create_file(core_path / "ui" / "keyboards_core.py")
    create_file(core_path / "ui" / "navigation_core.py")
    create_file(core_path / "ui" / "registry_ui.py")
    # create_file(core_path / "ui" / "callback_data_factories.py")

    create_file(core_path / "i18n" / "middleware.py")
    create_file(core_path / "i18n" / "translator.py")

    create_file(core_path / "events" / "dispatcher.py")
    
    create_file(core_path / "rbac" / "service.py")
    create_file(core_path / "utils_core" / "__init__.py") # Уже создан выше, но для полноты
    # create_file(core_path / "utils_core" / "command_utils.py")

    # 3. Директория модулей modules/
    modules_path = project_root / "modules"
    create_dir(modules_path)
    create_file(modules_path / "__init__.py")
    create_file(modules_path / ".gitkeep")

    system_module_path = modules_path / "system_base_module"
    create_dir(system_module_path)
    create_file(system_module_path / "__init__.py")
    create_file(system_module_path / "handlers_system.py")
    create_file(system_module_path / "keyboards_system.py")
    create_file(system_module_path / "manifest.yaml") # или .json

    example_module_path = modules_path / "example_module"
    create_dir(example_module_path)
    create_file(example_module_path / "__init__.py")
    create_file(example_module_path / "handlers_example.py")
    create_file(example_module_path / "keyboards_example.py")
    create_file(example_module_path / "models_example.py")
    create_file(example_module_path / "manifest.yaml") # или .json

    # 4. Директория для логики CLI команд cli_commands/
    cli_commands_path = project_root / "cli_commands"
    create_dir(cli_commands_path)
    create_file(cli_commands_path / "__init__.py")
    create_file(cli_commands_path / "setup_cmd.py")
    create_file(cli_commands_path / "db_cmd.py")
    create_file(cli_commands_path / "module_cmd.py")
    create_file(cli_commands_path / "user_cmd.py")
    create_file(cli_commands_path / "backup_cmd.py")
    create_file(cli_commands_path / "system_cmd.py")
    create_file(cli_commands_path / "cli_utils.py")

    # 5. Директория для миграций Alembic alembic_migrations/
    alembic_path = project_root / "alembic_migrations"
    create_dir(alembic_path / "versions") # versions создается alembic init
    create_file(alembic_path / "versions" / ".gitkeep") # Чтобы versions папка была
    # Для env.py и script.py.mako лучше, чтобы их создал alembic init
    # Но можно создать пустые заглушки, если alembic init не запускать сразу
    create_file(alembic_path / "env.py", "# Alembic env.py - настройте для SDB") 
    create_file(alembic_path / "script.py.mako", '"""${message} ..."""\n# ... (стандартный шаблон)')


    # 6. Директория для данных проекта project_data/
    project_data_path = project_root / "project_data"
    data_subdirs = ["Config", "Logs", "Cache_data", "Database_files", "module_backups", "core_backups"]
    for subdir in data_subdirs:
        create_dir(project_data_path / subdir)
        create_file(project_data_path / subdir / ".gitkeep")
    
    create_file(project_data_path / ".gitignore", "*\n!.gitignore\n!*/\n!.gitkeep\n")
    # create_file(project_data_path / "Config" / "core_settings.yaml") # Создастся через sdb setup
    # create_file(project_data_path / "Config" / "enabled_modules.json")

    # 7. Папка для локализации locales/
    locales_path = project_root / "locales"
    create_dir(locales_path / "en" / "LC_MESSAGES")
    create_dir(locales_path / "ua" / "LC_MESSAGES")
    create_file(locales_path / "bot.pot")
    create_file(locales_path / "en" / "LC_MESSAGES" / "bot.po")
    create_file(locales_path / "ua" / "LC_MESSAGES" / "bot.po")
    
    # 8. Папка для тестов tests/ (опционально)
    # tests_path = project_root / "tests"
    # tests_subdirs = ["core_tests", "module_tests", "cli_tests"]
    # create_dir(tests_path)
    # create_file(tests_path / "__init__.py")
    # for subdir in tests_subdirs:
    #     create_dir(tests_path / subdir)
    #     create_file(tests_path / subdir / "__init__.py")
    # create_file(tests_path / "smoke_test_cli.py")

    print("\nСтруктура проекта SwiftDevBot создана с использованием Python скрипта!")
    print("Рекомендации:")
    print("1. Выполните 'alembic init alembic_migrations' в корне проекта, если хотите, чтобы Alembic сам создал env.py и script.py.mako.")
    print("   (перед этим удалите alembic_migrations/env.py и alembic_migrations/script.py.mako, если они были созданы этим скриптом).")
    print("2. Не забудьте настроить alembic.ini (script_location = alembic_migrations) и сам alembic_migrations/env.py.")
    print("3. Настройте .gitignore в корне проекта.")

if __name__ == "__main__":
    main()


======================================================================

------------------------------ FILE: scripts/clean_cache.py ------------------------------
import os
import shutil
from pathlib import Path

def clean_pycache(start_path: str = "."):
    """Удаляет все директории __pycache__ и .pyc файлы."""
    
    counter = {"dirs": 0, "files": 0}
    
    for root, dirs, files in os.walk(start_path):
        # Пропускаем директорию .venv если она существует
        if ".venv" in root:
            continue
            
        # Удаляем __pycache__ директории
        if "__pycache__" in dirs:
            cache_path = Path(root) / "__pycache__"
            shutil.rmtree(cache_path)
            print(f"🗑️  Удалена директория: {cache_path}")
            counter["dirs"] += 1
            
        # Удаляем .pyc файлы
        for file in files:
            if file.endswith(".pyc"):
                file_path = Path(root) / file
                os.remove(file_path)
                print(f"🗑️  Удален файл: {file_path}")
                counter["files"] += 1
    
    return counter

if __name__ == "__main__":
    # Изменяем эту строку, чтобы получить корневую директорию проекта
    project_root = str(Path(__file__).parent.parent)
    print(f"🔍 Начинаем поиск в директории: {project_root}")
    results = clean_pycache(project_root)
    
    print("\n📊 Статистика очистки:")
    print(f"- Удалено директорий __pycache__: {results['dirs']}")
    print(f"- Удалено .pyc файлов: {results['files']}")


======================================================================

------------------------------ FILE: modules/example_module/permissions.py ------------------------------
# modules/example_module/permissions.py

MODULE_NAME = "example_module" # Важно, чтобы совпадало с именем модуля/папки

# Базовый доступ к пользовательскому интерфейсу модуля
PERM_ACCESS_USER_FEATURES = f"{MODULE_NAME}.access_user_features"

# Просмотр информации
PERM_VIEW_MODULE_SETTINGS = f"{MODULE_NAME}.view_module_settings" # Переименовал для ясности
PERM_VIEW_SECRET_INFO = f"{MODULE_NAME}.view_secret_info"

# Выполнение действий
PERM_PERFORM_BASIC_ACTION = f"{MODULE_NAME}.perform_basic_action" # Старое "do_magic"
PERM_PERFORM_ADVANCED_ACTION = f"{MODULE_NAME}.perform_advanced_action"

# Работа с заметками (CRUD)
PERM_MANAGE_OWN_NOTES = f"{MODULE_NAME}.manage_own_notes" # Общее право на свои заметки

# Административные права для модуля
PERM_ADMIN_VIEW_ALL_NOTES = f"{MODULE_NAME}.admin_view_all_notes"
PERM_ADMIN_MANAGE_MODULE = f"{MODULE_NAME}.admin_manage_module" # Общее админское право для модуля


======================================================================

------------------------------ FILE: modules/example_module/handlers_example.py ------------------------------
# modules/example_module/handlers_example.py
from aiogram import Router, types, F, Bot
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.utils.markdown import hbold, hcode, hitalic
from aiogram.exceptions import TelegramBadRequest 
from loguru import logger
from sqlalchemy import select, delete as sql_delete, func 

from .keyboards_example import (
    get_example_module_main_menu_keyboard,
    get_my_notes_keyboard,
    get_note_details_keyboard
)
from .callback_data_factories_example import ExampleModuleAction
from core.ui.callback_data_factories import ModuleMenuEntry, CoreMenuNavigate 
from .permissions import ( 
    MODULE_NAME, 
    PERM_ACCESS_USER_FEATURES,
    PERM_VIEW_MODULE_SETTINGS,
    PERM_VIEW_SECRET_INFO,
    PERM_PERFORM_BASIC_ACTION,
    PERM_PERFORM_ADVANCED_ACTION,
    PERM_MANAGE_OWN_NOTES,
    PERM_ADMIN_VIEW_ALL_NOTES,
    PERM_ADMIN_MANAGE_MODULE 
)
from .models import UserNote 

from typing import TYPE_CHECKING, Any, List, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession

example_module_router = Router(name="sdb_example_module_handlers")

class FSMExampleDialog(StatesGroup):
    waiting_for_name = State()
    waiting_for_age = State()

class FSMAddNote(StatesGroup):
    waiting_for_note_text = State()

async def check_permission(
    user_id: int, 
    permission_name: str, 
    services: 'BotServicesProvider', 
    session: 'AsyncSession'
) -> bool:
    has_perm = await services.rbac.user_has_permission(session, user_id, permission_name)
    if not has_perm:
        logger.warning(f"[{MODULE_NAME}] Пользователь {user_id} попытался получить доступ к функции, требующей права '{permission_name}', но не имеет его.")
    return has_perm

@example_module_router.message(Command("example"))
async def handle_example_command(
    message: types.Message, 
    services_provider: 'BotServicesProvider'
):
    user_id = message.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} вызвал команду /example.")
    
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_ACCESS_USER_FEATURES, services_provider, session):
            await message.answer("У вас нет доступа к этому модулю.")
            return

    module_info = services_provider.modules.get_module_info(MODULE_NAME)
    display_name = module_info.manifest.display_name if module_info and module_info.manifest else MODULE_NAME
    
    text = (f"Добро пожаловать в {hbold(display_name)}!\n"
            f"Выберите действие:")
    async with services_provider.db.get_session() as session: 
        keyboard = await get_example_module_main_menu_keyboard(services_provider, user_id, session)
    await message.answer(text, reply_markup=keyboard)

@example_module_router.callback_query(ModuleMenuEntry.filter(F.module_name == MODULE_NAME))
async def cq_show_example_module_main_menu(
    query: types.CallbackQuery, 
    callback_data: ModuleMenuEntry, 
    services_provider: 'BotServicesProvider'
):
    user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} вошел в главное меню модуля.")

    async with services_provider.db.get_session() as session: 
        if not await check_permission(user_id, PERM_ACCESS_USER_FEATURES, services_provider, session):
            await query.answer("У вас нет доступа к этому меню.", show_alert=True)
            return

        module_info = services_provider.modules.get_module_info(MODULE_NAME)
        display_name = module_info.manifest.display_name if module_info and module_info.manifest else MODULE_NAME

        text = (f"Добро пожаловать в {hbold(display_name)}!\n"
                f"Выберите действие:")
        keyboard = await get_example_module_main_menu_keyboard(services_provider, user_id, session)
    
        if query.message:
            try:
                if query.message.text != text or query.message.reply_markup != keyboard:
                    await query.message.edit_text(text, reply_markup=keyboard)
                await query.answer()
            except TelegramBadRequest as e: # Используем импортированный TelegramBadRequest
                if "message is not modified" in str(e).lower(): await query.answer()
                else: logger.warning(f"[{MODULE_NAME}] Ошибка edit_text в меню модуля: {e}")
            except Exception as e: 
                logger.error(f"[{MODULE_NAME}] Ошибка в cq_show_example_module_main_menu: {e}", exc_info=True)
                await query.answer("Произошла ошибка.", show_alert=True)
        else:
            await query.answer()

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "show_module_settings"))
async def cq_action_show_module_settings(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider'
):
    user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} запросил показать глобальные настройки модуля.")
    
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_VIEW_MODULE_SETTINGS, services_provider, session):
            await query.answer("У вас нет прав для просмотра этой информации.", show_alert=True)
            return

        actual_module_settings = services_provider.modules.get_module_settings(MODULE_NAME)
        settings_text_parts = [f"⚙️ {hbold('Глобальные настройки модуля')} {hcode(MODULE_NAME)}:"]
        if actual_module_settings:
            for key, value in actual_module_settings.items():
                settings_text_parts.append(f"  ▫️ {hcode(key)}: {hcode(str(value))}")
        else:
            settings_text_parts.append("Настройки не найдены или не загружены.")
        
        text = "\n".join(settings_text_parts)
        keyboard = await get_example_module_main_menu_keyboard(services_provider, user_id, session)
    
        if query.message:
            try:
                if query.message.text != text: await query.message.edit_text(text, reply_markup=keyboard)
                await query.answer()
            except TelegramBadRequest as e: # Используем импортированный TelegramBadRequest
                if "message is not modified" not in str(e).lower(): logger.warning(f"[{MODULE_NAME}] Ошибка edit_text (настройки): {e}")
                await query.answer()
            except Exception as e:
                logger.error(f"[{MODULE_NAME}] Ошибка в cq_action_show_module_settings: {e}", exc_info=True)
                await query.answer("Произошла ошибка.", show_alert=True)

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "show_secret_info"))
async def cq_action_show_secret_info(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_VIEW_SECRET_INFO, services_provider, session):
            await query.answer("🤫 Это секретная информация, доступ ограничен!", show_alert=True)
            return
    await query.answer("🎉 Поздравляю! У вас есть доступ к этой супер-секретной информации! 🎉", show_alert=True)

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "do_basic_action"))
async def cq_action_do_basic_action(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_PERFORM_BASIC_ACTION, services_provider, session):
            await query.answer("Действие недоступно.", show_alert=True)
            return
    await query.answer("✅ Базовое действие выполнено!", show_alert=True)

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "do_advanced_action"))
async def cq_action_do_advanced_action(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_PERFORM_ADVANCED_ACTION, services_provider, session):
            await query.answer("🚀 Это действие требует особых прав!", show_alert=True)
            return
    await query.answer("💥 Продвинутое действие успешно выполнено! 💥", show_alert=True)

@example_module_router.message(Command("fsm_example"))
async def cmd_fsm_start(message: types.Message, state: FSMContext, services_provider: 'BotServicesProvider'):
    user_id = message.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} начал FSM-диалог (/fsm_example).")
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_ACCESS_USER_FEATURES, services_provider, session): 
            await message.answer("У вас нет доступа к этой функции.")
            return
    await state.set_state(FSMExampleDialog.waiting_for_name)
    await message.answer("Как тебя зовут в этом FSM-диалоге?")

@example_module_router.message(StateFilter(FSMExampleDialog.waiting_for_name))
async def process_fsm_name(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not message.text:
        await message.answer("Пожалуйста, введи свое имя текстом.")
        return
    await state.update_data(name=message.text)
    await state.set_state(FSMExampleDialog.waiting_for_age)
    logger.info(f"[{MODULE_NAME}] FSM: Пользователь {user_id} ввел имя: {message.text}")
    await message.answer(f"Приятно, {hitalic(message.text)}! А сколько тебе лет (FSM)?")

@example_module_router.message(StateFilter(FSMExampleDialog.waiting_for_age))
async def process_fsm_age(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if not message.text or not message.text.isdigit():
        await message.answer("Пожалуйста, введи свой возраст цифрами.")
        return
    age = int(message.text)
    if not (0 < age < 120):
        await message.answer("Необычный возраст. Попробуй еще раз.")
        return
    user_data = await state.get_data()
    name = user_data.get("name", "Незнакомец")
    logger.info(f"[{MODULE_NAME}] FSM: Пользователь {user_id} (имя: {name}) ввел возраст: {age}")
    await message.answer(
        f"Запомнил, {hitalic(name)} ({age} лет)!\n"
        f"FSM диалог завершен. Состояние сброшено."
    )
    await state.clear() 

@example_module_router.message(Command("cancel_fsm"), StateFilter(FSMExampleDialog)) 
async def cancel_fsm_dialog(message: types.Message, state: FSMContext):
    current_state = await state.get_state()
    logger.info(f"[{MODULE_NAME}] Пользователь {message.from_user.id} отменил FSM диалог из состояния {current_state}")
    await state.clear()
    await message.answer("FSM диалог отменен.")

@example_module_router.message(Command("my_notes"))
async def cmd_my_notes(message: types.Message, services_provider: 'BotServicesProvider'):
    user_id = message.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} запросил свои заметки (/my_notes).")
    
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_MANAGE_OWN_NOTES, services_provider, session):
            await message.answer("У вас нет прав для управления заметками.")
            return

        stmt = select(UserNote).where(UserNote.user_telegram_id == user_id).order_by(UserNote.created_at.desc())
        result = await session.execute(stmt)
        notes: List[UserNote] = list(result.scalars().all())
        
        text = f"📝 {hbold('Ваши заметки')}:"
        if not notes:
            text += "\nУ вас пока нет заметок. Можете добавить новую."
            
        keyboard = await get_my_notes_keyboard(notes, services_provider, user_id, session)
        await message.answer(text, reply_markup=keyboard)

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "my_notes_list"))
async def cq_my_notes_list(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME}] Пользователь {user_id} запросил список своих заметок (callback).")
    
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_MANAGE_OWN_NOTES, services_provider, session):
            await query.answer("У вас нет прав для управления заметками.", show_alert=True)
            return

        stmt = select(UserNote).where(UserNote.user_telegram_id == user_id).order_by(UserNote.created_at.desc())
        result = await session.execute(stmt)
        notes: List[UserNote] = list(result.scalars().all())
        
        text = f"📝 {hbold('Ваши заметки')}:"
        if not notes:
            text += "\nУ вас пока нет заметок. Можете добавить новую."
            
        keyboard = await get_my_notes_keyboard(notes, services_provider, user_id, session)
        if query.message:
            try:
                if query.message.text != text or query.message.reply_markup != keyboard:
                    await query.message.edit_text(text, reply_markup=keyboard)
                await query.answer()
            except TelegramBadRequest as e: # Используем импортированный TelegramBadRequest
                if "message is not modified" not in str(e).lower(): logger.warning(f"Ошибка edit_text в cq_my_notes_list: {e}")
                await query.answer()
            except Exception as e:
                logger.error(f"Ошибка в cq_my_notes_list: {e}", exc_info=True)
                await query.answer("Ошибка.", show_alert=True)

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "add_note_start"))
async def cq_add_note_start(query: types.CallbackQuery, state: FSMContext, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_MANAGE_OWN_NOTES, services_provider, session):
            await query.answer("У вас нет прав для добавления заметок.", show_alert=True)
            return
    
    module_settings = services_provider.modules.get_module_settings(MODULE_NAME)
    max_notes = module_settings.get("max_notes_per_user", 5) if module_settings else 5
    
    async with services_provider.db.get_session() as session: 
        count_stmt = select(func.count(UserNote.id)).where(UserNote.user_telegram_id == user_id)
        notes_count_res = await session.execute(count_stmt)
        notes_count = notes_count_res.scalar_one_or_none() or 0

    if notes_count >= max_notes:
        await query.answer(f"Достигнут лимит заметок ({max_notes} шт.). Удалите старые, чтобы добавить новые.", show_alert=True)
        return

    await state.set_state(FSMAddNote.waiting_for_note_text)
    await query.message.answer("Введите текст вашей новой заметки:") # type: ignore
    await query.answer()

@example_module_router.message(StateFilter(FSMAddNote.waiting_for_note_text))
async def process_add_note_text(message: types.Message, state: FSMContext, services_provider: 'BotServicesProvider'):
    user_id = message.from_user.id
    if not message.text:
        await message.answer("Текст заметки не может быть пустым. Попробуйте еще раз или введите /cancel_note.")
        return

    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_MANAGE_OWN_NOTES, services_provider, session):
            await message.answer("У вас нет прав для добавления заметок.")
            await state.clear()
            return
        
        new_note = UserNote(user_telegram_id=user_id, note_text=message.text)
        session.add(new_note)
        try:
            await session.commit()
            logger.info(f"[{MODULE_NAME}] Пользователь {user_id} добавил новую заметку: '{message.text[:30]}...'")
            await message.answer(f"✅ Заметка добавлена!\nИспользуйте /my_notes для просмотра.")
        except Exception as e:
            await session.rollback()
            logger.error(f"Ошибка сохранения заметки для {user_id}: {e}", exc_info=True)
            await message.answer("Не удалось сохранить заметку. Попробуйте позже.")
        finally:
            await state.clear()

@example_module_router.message(Command("cancel_note"), StateFilter(FSMAddNote))
async def cancel_add_note_fsm(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer("Добавление заметки отменено.")

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "view_note_details"))
async def cq_view_note_details(query: types.CallbackQuery, callback_data: ExampleModuleAction, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    note_id = callback_data.item_id
    if note_id is None:
        await query.answer("Ошибка: ID заметки не указан.", show_alert=True); return

    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_MANAGE_OWN_NOTES, services_provider, session):
            await query.answer("У вас нет прав для просмотра этой заметки.", show_alert=True); return
        
        note = await session.get(UserNote, note_id)
        if not note or note.user_telegram_id != user_id:
            await query.answer("Заметка не найдена или у вас нет к ней доступа.", show_alert=True); return
            
        text = f"📝 {hbold('Детали заметки:')}\n\n{hitalic(note.note_text)}\n\nСтатус: {'✅ Выполнено' if note.is_done else '🔘 В процессе'}"
        keyboard = await get_note_details_keyboard(note, services_provider, user_id, session)
        if query.message:
            try:
                await query.message.edit_text(text, reply_markup=keyboard)
                await query.answer()
            except Exception as e: logger.error(f"Ошибка в cq_view_note_details: {e}")

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "toggle_note_done"))
async def cq_toggle_note_done(query: types.CallbackQuery, callback_data: ExampleModuleAction, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    note_id = callback_data.item_id
    if note_id is None: await query.answer("Ошибка ID.", show_alert=True); return

    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_MANAGE_OWN_NOTES, services_provider, session):
            await query.answer("Нет прав.", show_alert=True); return
        
        note = await session.get(UserNote, note_id)
        if not note or note.user_telegram_id != user_id:
            await query.answer("Заметка не найдена/нет доступа.", show_alert=True); return
            
        note.is_done = not note.is_done
        session.add(note)
        alert_text = ""
        try:
            await session.commit()
            alert_text = "Статус заметки изменен."
            logger.info(f"Статус заметки ID {note.id} изменен на {note.is_done} пользователем {user_id}.")
            text = f"📝 {hbold('Детали заметки:')}\n\n{hitalic(note.note_text)}\n\nСтатус: {'✅ Выполнено' if note.is_done else '🔘 В процессе'}"
            keyboard = await get_note_details_keyboard(note, services_provider, user_id, session)
            if query.message: await query.message.edit_text(text, reply_markup=keyboard)
        except Exception as e:
            await session.rollback()
            alert_text = "Ошибка сохранения."
            logger.error(f"Ошибка toggle_note_done: {e}")
        await query.answer(alert_text)

@example_module_router.callback_query(ExampleModuleAction.filter(F.action == "delete_note_confirm"))
async def cq_delete_note_confirm(query: types.CallbackQuery, callback_data: ExampleModuleAction, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    note_id = callback_data.item_id
    if note_id is None: await query.answer("Ошибка ID.", show_alert=True); return

    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_MANAGE_OWN_NOTES, services_provider, session):
            await query.answer("Нет прав.", show_alert=True); return
        
        stmt = sql_delete(UserNote).where(UserNote.id == note_id, UserNote.user_telegram_id == user_id)
        result = await session.execute(stmt)
        alert_text = ""
        if result.rowcount > 0:
            try:
                await session.commit()
                alert_text = "Заметка удалена."
                logger.info(f"Заметка ID {note_id} удалена пользователем {user_id}.")
                notes_stmt = select(UserNote).where(UserNote.user_telegram_id == user_id).order_by(UserNote.created_at.desc())
                notes_res = await session.execute(notes_stmt)
                notes: List[UserNote] = list(notes_res.scalars().all())
                list_text = f"📝 {hbold('Ваши заметки')}:" + ("\nУ вас пока нет заметок." if not notes else "")
                list_kb = await get_my_notes_keyboard(notes, services_provider, user_id, session)
                if query.message: await query.message.edit_text(list_text, reply_markup=list_kb)
            except Exception as e:
                await session.rollback()
                alert_text = "Ошибка удаления."
                logger.error(f"Ошибка commit при удалении заметки: {e}")
        else:
            alert_text = "Заметка не найдена или уже удалена."
        await query.answer(alert_text)

@example_module_router.message(Command("example_admin"))
async def cmd_example_admin(message: types.Message, services_provider: 'BotServicesProvider'):
    user_id = message.from_user.id
    async with services_provider.db.get_session() as session:
        if not await check_permission(user_id, PERM_ADMIN_MANAGE_MODULE, services_provider, session):
            await message.answer("У вас нет прав для этой команды.")
            return
    await message.answer("Вы выполнили административную команду модуля Example!")


======================================================================

------------------------------ FILE: modules/example_module/callback_data_factories_example.py ------------------------------
# modules/example_module/callback_data_factories_example.py

from aiogram.filters.callback_data import CallbackData
from typing import Optional

EXAMPLE_MODULE_PREFIX = "exmpl" 

class ExampleModuleAction(CallbackData, prefix=EXAMPLE_MODULE_PREFIX):
    action: str 
    # Для общих действий
    item_id: Optional[int] = None # Может быть ID заметки, или чего-то еще

    # Для FSM, если нужно передать какой-то параметр
    param: Optional[str] = None


======================================================================

------------------------------ FILE: modules/example_module/keyboards_example.py ------------------------------
# modules/example_module/keyboards_example.py

from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

# Импортируем фабрику для навигации ядра, чтобы сделать кнопку "Назад"
from core.ui.callback_data_factories import CoreMenuNavigate, ModuleMenuEntry # <--- ДОБАВЛЕН ИМПОРТ ModuleMenuEntry
# Импортируем свою фабрику для этого модуля
from .callback_data_factories_example import ExampleModuleAction 
# Импортируем имена разрешений из нового файла
from .permissions import (
    PERM_VIEW_MODULE_SETTINGS,
    PERM_VIEW_SECRET_INFO,
    PERM_PERFORM_BASIC_ACTION,
    PERM_PERFORM_ADVANCED_ACTION,
    PERM_MANAGE_OWN_NOTES
)
from .models import UserNote # Для отображения заметок

from typing import TYPE_CHECKING, List
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession


async def get_example_module_main_menu_keyboard(
    services: 'BotServicesProvider', 
    user_id: int, 
    session: 'AsyncSession' 
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # Кнопка "Показать настройки модуля"
    if await services.rbac.user_has_permission(session, user_id, PERM_VIEW_MODULE_SETTINGS):
        builder.button(
            text="⚙️ Настройки модуля (глоб.)",
            callback_data=ExampleModuleAction(action="show_module_settings").pack()
        )
    
    # Кнопка "Показать секретную информацию"
    if await services.rbac.user_has_permission(session, user_id, PERM_VIEW_SECRET_INFO):
        builder.button(
            text="🤫 Секретная информация",
            callback_data=ExampleModuleAction(action="show_secret_info").pack()
        )

    # Кнопка "Базовое действие"
    if await services.rbac.user_has_permission(session, user_id, PERM_PERFORM_BASIC_ACTION):
        builder.button(
            text="▶️ Базовое действие",
            callback_data=ExampleModuleAction(action="do_basic_action").pack()
        )

    # Кнопка "Продвинутое действие"
    if await services.rbac.user_has_permission(session, user_id, PERM_PERFORM_ADVANCED_ACTION):
        builder.button(
            text="🚀 Продвинутое действие",
            callback_data=ExampleModuleAction(action="do_advanced_action").pack()
        )
    
    # Кнопка "Мои заметки"
    if await services.rbac.user_has_permission(session, user_id, PERM_MANAGE_OWN_NOTES):
        builder.button(
            text="📝 Мои заметки",
            callback_data=ExampleModuleAction(action="my_notes_list").pack()
        )

    if not builder.export(): 
        builder.button(
            text="🤷‍♂️ Для вас здесь пока нет доступных действий",
            callback_data="example_module:no_actions" 
        )

    builder.button(
        text="⬅️ Назад к списку модулей",
        callback_data=CoreMenuNavigate(target_menu="modules_list", page=1).pack() 
    )
    
    builder.adjust(1) 
    return builder.as_markup()

async def get_my_notes_keyboard(
    notes: List[UserNote], 
    services: 'BotServicesProvider', 
    user_id: int, 
    session: 'AsyncSession'
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()

    if notes:
        for note in notes:
            status_icon = "✅" if note.is_done else "📝"
            note_text_short = note.note_text[:30] + "..." if len(note.note_text) > 30 else note.note_text
            builder.button(
                text=f"{status_icon} {note_text_short}",
                callback_data=ExampleModuleAction(action="view_note_details", item_id=note.id).pack()
            )
        builder.adjust(1)
    else:
        builder.button(text="У вас пока нет заметок.", callback_data="example_module:no_notes_dummy")

    builder.row(
        InlineKeyboardButton(
            text="➕ Добавить заметку",
            callback_data=ExampleModuleAction(action="add_note_start").pack()
        )
    )
    builder.row(
        InlineKeyboardButton(
            text="⬅️ В меню модуля",
            # Здесь используется ModuleMenuEntry, который мы теперь правильно импортируем
            callback_data=ModuleMenuEntry(module_name="example_module").pack() 
        )
    )
    return builder.as_markup()

async def get_note_details_keyboard(
    note: UserNote,
    services: 'BotServicesProvider', 
    user_id: int, 
    session: 'AsyncSession'
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    toggle_done_text = "📝 Снять отметку" if note.is_done else "✅ Отметить как сделано"
    builder.button(
        text=toggle_done_text,
        callback_data=ExampleModuleAction(action="toggle_note_done", item_id=note.id).pack()
    )
    builder.button(
        text="🗑️ Удалить заметку",
        callback_data=ExampleModuleAction(action="delete_note_confirm", item_id=note.id).pack()
    )
    builder.adjust(1)
    builder.row(
        InlineKeyboardButton(
            text="⬅️ К моим заметкам",
            callback_data=ExampleModuleAction(action="my_notes_list").pack()
        )
    )
    return builder.as_markup()


======================================================================

------------------------------ FILE: modules/example_module/manifest.yaml ------------------------------
# modules/example_module/manifest.yaml
name: "example_module"
display_name: "Пример Модуля SDB (Расширенный)"
version: "0.2.0"
description: "Расширенный демонстрационный модуль для платформы SwiftDevBot, показывающий различные уровни доступа, FSM, работу с данными и настройками."
author: "SDB Core Team (Example)"

python_requirements: []
sdb_module_dependencies: []

model_definitions:
  - "modules.example_module.models.ExampleTableOne"
  - "modules.example_module.models.AnotherExampleTable"
  - "modules.example_module.models.UserNote"

commands:
  - command: "example"
    description: "Показать главное меню Примерного Модуля"
    icon: "🌟"
    category: "Примеры"
    admin_only: false
  - command: "fsm_example"
    description: "🗣️ Запустить FSM диалог (пример)"
    icon: "🗣️"
    category: "Примеры"
    admin_only: false
  - command: "my_notes"
    description: "📝 Мои заметки (Примерный Модуль)"
    icon: "📝"
    category: "Примеры"
    admin_only: false

permissions: 
  - name: "example_module.access_user_features"
    description: "Доступ к основному пользовательскому интерфейсу и функциям модуля Example."
  - name: "example_module.view_module_settings"
    description: "Просмотр глобальных настроек модуля Example."
  - name: "example_module.view_secret_info"
    description: "Просмотр секретной информации в модуле Example."
  - name: "example_module.perform_basic_action"
    description: "Выполнение базового действия в модуле Example."
  - name: "example_module.perform_advanced_action"
    description: "Выполнение продвинутого/привилегированного действия в модуле Example."
  - name: "example_module.manage_own_notes"
    description: "Управление (создание, просмотр, удаление) собственными заметками в модуле Example."
  - name: "example_module.admin_view_all_notes"
    description: "[АДМИН] Просмотр всех заметок всех пользователей в модуле Example."
  - name: "example_module.admin_manage_module"
    description: "[АДМИН] Общие административные действия для модуля Example."

settings:
  example_setting_string:
    type: "string"
    label: "Пример строковой настройки"
    description: "Введите сюда какой-нибудь текст для примера."
    default: "Привет из примера!"
    required: false
  example_setting_bool:
    type: "bool"
    label: "Пример булевой настройки"
    description: "Включить или выключить что-то."
    default: true
  max_notes_per_user:
    type: "int"
    label: "Макс. заметок на пользователя"
    description: "Максимальное количество заметок, которое может создать один пользователь."
    default: 5
    min_value: 1
    max_value: 100

metadata:
  min_sdb_core_version: "0.1.0"
  tags: ["example", "demonstration", "tutorial", "fsm", "crud", "permissions"]
  assign_default_access_to_user_role: true


======================================================================

------------------------------ FILE: modules/example_module/module_settings.yaml ------------------------------
# modules/example_module/module_settings.yaml
example_setting_string: "111Дефолтное значение из файла example_module/module_settings.yaml"
example_setting_bool: false
# Добавь сюда другие настройки, если они есть в манифесте example_module


======================================================================

------------------------------ FILE: modules/example_module/__init__.py ------------------------------
# modules/example_module/__init__.py

from aiogram import Dispatcher, Bot, Router
from loguru import logger

# Импортируем роутер и MODULE_NAME
from .handlers_example import example_module_router, MODULE_NAME 
# Импортируем базовое разрешение для доступа к UI модуля
from .permissions import PERM_ACCESS_USER_FEATURES 

from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from core.module_loader import ModuleInfo

async def setup_module(dp: Dispatcher, bot: Bot, services: 'BotServicesProvider'):
    module_info: Optional[ModuleInfo] = services.modules.get_module_info(MODULE_NAME)
    
    if not module_info or not module_info.manifest:
        logger.error(f"Не удалось получить информацию или манифест для модуля '{MODULE_NAME}'. "
                     "Модуль не будет настроен.")
        return

    display_name = module_info.manifest.display_name
    version = module_info.manifest.version
    logger.info(f"[{MODULE_NAME}] Настройка модуля: {display_name} v{version}...")

    if isinstance(example_module_router, Router):
        dp.include_router(example_module_router)
        logger.info(f"[{MODULE_NAME}] Роутер '{example_module_router.name}' успешно зарегистрирован.")
    else:
        logger.error(f"[{MODULE_NAME}] Ошибка: 'example_module_router' не является экземпляром aiogram.Router.")

    from core.ui.callback_data_factories import ModuleMenuEntry 

    entry_cb_data = ModuleMenuEntry(module_name=MODULE_NAME).pack()
    
    icon = "🌟" # Можно взять из манифеста, если там будет такое поле для UI Entry
    if module_info.manifest.commands: # Попробуем взять иконку из первой команды
        primary_command = next((cmd for cmd in module_info.manifest.commands if cmd.command == "example"), None)
        if primary_command and primary_command.icon:
            icon = primary_command.icon

    description = module_info.manifest.description or f"Модуль {display_name}"

    services.ui_registry.register_module_entry(
        module_name=MODULE_NAME, 
        display_name=display_name,
        entry_callback_data=entry_cb_data, 
        icon=icon,
        description=description,
        order=100,
        required_permission_to_view=PERM_ACCESS_USER_FEATURES # Используем импортированное разрешение
    )
    logger.info(f"[{MODULE_NAME}] UI-точка входа для модуля '{display_name}' зарегистрирована в UIRegistry.")

    logger.success(f"✅ Модуль '{MODULE_NAME}' ({display_name}) успешно настроен.")


======================================================================

------------------------------ FILE: modules/example_module/models.py ------------------------------
# modules/example_module/models.py
from sqlalchemy import String, Integer, ForeignKey, Text, Boolean, BigInteger # <--- Добавил BigInteger
from sqlalchemy.orm import Mapped, mapped_column, relationship
from core.database.base import SDBBaseModel 
from core.database.core_models import SDB_CORE_TABLE_PREFIX # Импортируем префикс для ForeignKey
from typing import Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from core.database.core_models import User # Для type hinting в Mapped

# Оставляем существующие модели
class ExampleTableOne(SDBBaseModel): 
    __tablename__ = "mod_example_table_one"
    name: Mapped[str] = mapped_column(String(100), nullable=False, comment="Пример текстового поля")
    description: Mapped[Optional[str]] = mapped_column(String(255), comment="Описание для примера")
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, server_default="1")

    def __repr__(self):
        return f"<ExampleTableOne(id={self.id}, name='{self.name}')>"

class AnotherExampleTable(SDBBaseModel): 
    __tablename__ = "mod_another_example_table"
    example_one_id: Mapped[Optional[int]] = mapped_column(Integer, ForeignKey('mod_example_table_one.id', ondelete='CASCADE')) 
    value: Mapped[str] = mapped_column(String(200), nullable=False, comment="Пример строкового значения")
    example_one: Mapped[Optional["ExampleTableOne"]] = relationship("ExampleTableOne", backref="another_examples") 

    def __repr__(self):
        return f"<AnotherExampleTable(id={self.id}, value='{self.value}')>"

# Новая модель для заметок пользователя
class UserNote(SDBBaseModel):
    __tablename__ = "mod_example_user_notes"

    # Telegram ID пользователя, которому принадлежит заметка. Используем BigInteger.
    user_telegram_id: Mapped[int] = mapped_column(
        BigInteger, # <--- ИЗМЕНЕНО ЗДЕСЬ
        index=True, 
        nullable=False, 
        comment="Telegram ID пользователя-владельца заметки"
    )
    note_text: Mapped[str] = mapped_column(Text, nullable=False, comment="Текст заметки")
    is_done: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, comment="Отмечена ли заметка как выполненная")

    # Связь с основной таблицей пользователей SDB (если нужна)
    # Внешний ключ на ID пользователя в таблице sdb_users.
    # Это поле опционально, если ты идентифицируешь пользователя только по user_telegram_id.
    # Если используешь, то UserNote.user_id будет ссылаться на User.id из core_models.
    # И user_telegram_id здесь может быть избыточным, если есть user_id.
    # Но если модуль должен работать независимо и не всегда имеет доступ к объекту User из ядра,
    # то хранение user_telegram_id в самой таблице модуля полезно.
    # Для примера оставим оба, но для реального проекта выбери один подход.
    
    # user_db_id: Mapped[int] = mapped_column(ForeignKey(f"{SDB_CORE_TABLE_PREFIX}users.id", ondelete="CASCADE"), index=True)
    # user: Mapped["User"] = relationship(backref="example_module_notes")

    def __repr__(self) -> str:
        return f"<UserNote(id={self.id}, user_tg_id={self.user_telegram_id}, text='{self.note_text[:20]}...', done={self.is_done})>"


======================================================================

------------------------------ FILE: project_data/core_backups/.gitkeep ------------------------------



======================================================================

------------------------------ FILE: project_data/Cache_data/.gitkeep ------------------------------



======================================================================

------------------------------ FILE: project_data/module_backups/.gitkeep ------------------------------



======================================================================

------------------------------ FILE: project_data/Database_files/.gitkeep ------------------------------



======================================================================

------------------------------ FILE: project_data/Logs/.gitkeep ------------------------------



======================================================================

------------------------------ FILE: project_data/Config/modules_settings/example_module.yaml ------------------------------
example_setting_string: 111Дефолтное значение из файла example_module/module_settings.yaml
example_setting_bool: false
max_notes_per_user: 5



======================================================================

------------------------------ FILE: core/sys_modules/__init__.py ------------------------------
# core/sys_modules/__init__.py
# Этот файл делает директорию 'sys_modules' пакетом Python.
# Сюда можно будет помещать внутренние системные модули ядра.

# Пример, если бы здесь был модуль 'internal_logger_viewer':
# from .internal_logger_viewer import setup_module as setup_logger_viewer_module
# from .internal_logger_viewer.handlers import logger_viewer_router

# __all__ = ["setup_logger_viewer_module", "logger_viewer_router"]


======================================================================

------------------------------ FILE: core/rbac/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/rbac/service.py ------------------------------
# core/rbac/service.py
from sqlalchemy.orm import selectinload
from typing import List, Optional, TYPE_CHECKING, Set, Dict, Tuple, Union
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete, func as sql_func 
from loguru import logger

from core.database.core_models import User, Role, UserRole, Permission, RolePermission, UserPermission # Добавлена UserPermission
from core.schemas.module_manifest import PermissionManifest as ModulePermissionManifestSchema


if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider 
    from core.database.manager import DBManager 
    from core.module_loader import ModuleInfo 

# --- Стандартные Роли ---
DEFAULT_ROLE_USER = "User"
DEFAULT_ROLE_MODERATOR = "Moderator"
DEFAULT_ROLE_ADMIN = "Admin"

DEFAULT_ROLES_DEFINITIONS: Dict[str, str] = {
    DEFAULT_ROLE_USER: "Обычный пользователь с базовыми правами доступа.",
    DEFAULT_ROLE_MODERATOR: "Модератор с правами на просмотр информации и базовое управление.",
    DEFAULT_ROLE_ADMIN: "Администратор, имеет расширенные права в определенных областях.",
}

# --- Стандартные Разрешения ЯДРА (Permissions) ---
PERMISSION_CORE_VIEW_ADMIN_PANEL = "core.admin.view_panel"
PERMISSION_CORE_USERS_VIEW_LIST = "core.users.view_list"
PERMISSION_CORE_USERS_VIEW_DETAILS = "core.users.view_details"
PERMISSION_CORE_USERS_EDIT_PROFILE = "core.users.edit_profile"
PERMISSION_CORE_USERS_MANAGE_STATUS = "core.users.manage_status"
PERMISSION_CORE_USERS_ASSIGN_ROLES = "core.users.assign_roles"
PERMISSION_CORE_USERS_DELETE = "core.users.delete"
PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS = "core.users.manage_direct_permissions" # НОВОЕ РАЗРЕШЕНИЕ

PERMISSION_CORE_ROLES_VIEW = "core.roles.view"
PERMISSION_CORE_ROLES_CREATE = "core.roles.create" 
PERMISSION_CORE_ROLES_EDIT = "core.roles.edit" 
PERMISSION_CORE_ROLES_DELETE = "core.roles.delete" 
PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS = "core.roles.assign_permissions"

PERMISSION_CORE_PERMISSIONS_VIEW = "core.permissions.view" 

PERMISSION_CORE_MODULES_VIEW_LIST = "core.modules.view_list"
PERMISSION_CORE_MODULES_TOGGLE_ACTIVATION = "core.modules.toggle_activation"
PERMISSION_CORE_MODULES_MANAGE_SETTINGS = "core.modules.manage_settings"

PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC = "core.system.view_info.basic"
PERMISSION_CORE_SYSTEM_VIEW_INFO_FULL = "core.system.view_info.full"
PERMISSION_CORE_SYSTEM_VIEW_LOGS_BASIC = "core.system.view_logs.basic"
PERMISSION_CORE_SYSTEM_VIEW_LOGS_FULL = "core.system.view_logs.full"
PERMISSION_CORE_SYSTEM_MANAGE_BACKUPS = "core.system.manage_backups"
PERMISSION_CORE_SYSTEM_SEND_BROADCAST = "core.system.send_broadcast"

PERMISSION_CORE_SETTINGS_VIEW = "core.settings.view"
PERMISSION_CORE_SETTINGS_EDIT = "core.settings.edit"


DEFAULT_CORE_PERMISSIONS_DEFINITIONS: Dict[str, str] = {
    PERMISSION_CORE_VIEW_ADMIN_PANEL: "Доступ к административной панели.",
    PERMISSION_CORE_USERS_VIEW_LIST: "Просмотр списка пользователей.",
    PERMISSION_CORE_USERS_VIEW_DETAILS: "Просмотр детальной информации о пользователе.",
    PERMISSION_CORE_USERS_EDIT_PROFILE: "Редактирование профиля пользователя (имя, язык и т.д.).",
    PERMISSION_CORE_USERS_MANAGE_STATUS: "Управление статусом пользователя (активен/заблокирован).",
    PERMISSION_CORE_USERS_ASSIGN_ROLES: "Назначение и снятие ролей с пользователей.",
    PERMISSION_CORE_USERS_DELETE: "Удаление пользователей из системы.",
    PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS: "Управление индивидуальными разрешениями пользователей.", # ОПИСАНИЕ НОВОГО РАЗРЕШЕНИЯ
    PERMISSION_CORE_ROLES_VIEW: "Просмотр ролей и их разрешений.",
    PERMISSION_CORE_ROLES_CREATE: "Создание новых ролей.", 
    PERMISSION_CORE_ROLES_EDIT: "Редактирование существующих ролей (имя, описание).",
    PERMISSION_CORE_ROLES_DELETE: "Удаление ролей.", 
    PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS: "Назначение и снятие разрешений с ролей.",
    PERMISSION_CORE_PERMISSIONS_VIEW: "Просмотр списка всех доступных разрешений.",
    PERMISSION_CORE_MODULES_VIEW_LIST: "Просмотр списка модулей и их статусов.",
    PERMISSION_CORE_MODULES_TOGGLE_ACTIVATION: "Включение и отключение плагинов.",
    PERMISSION_CORE_MODULES_MANAGE_SETTINGS: "Управление настройками модулей.",
    PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC: "Просмотр базовой системной информации.",
    PERMISSION_CORE_SYSTEM_VIEW_INFO_FULL: "Просмотр полной системной информации и отладочных данных.",
    PERMISSION_CORE_SYSTEM_VIEW_LOGS_BASIC: "Просмотр основных логов системы.",
    PERMISSION_CORE_SYSTEM_VIEW_LOGS_FULL: "Просмотр всех логов системы и их скачивание.",
    PERMISSION_CORE_SYSTEM_MANAGE_BACKUPS: "Управление резервными копиями системы.",
    PERMISSION_CORE_SYSTEM_SEND_BROADCAST: "Отправка широковещательных сообщений пользователям.",
    PERMISSION_CORE_SETTINGS_VIEW: "Просмотр настроек ядра SwiftDevBot.",
    PERMISSION_CORE_SETTINGS_EDIT: "Редактирование настроек ядра SwiftDevBot (высокий риск).",
}

DEFAULT_PERMISSIONS_FOR_CORE_MODERATOR_ROLE: Set[str] = {
    PERMISSION_CORE_VIEW_ADMIN_PANEL, 
    PERMISSION_CORE_USERS_VIEW_LIST,
    PERMISSION_CORE_USERS_VIEW_DETAILS,
    PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC,
}

DEFAULT_PERMISSIONS_FOR_CORE_ADMIN_ROLE: Set[str] = {
    *DEFAULT_PERMISSIONS_FOR_CORE_MODERATOR_ROLE, 
    PERMISSION_CORE_USERS_MANAGE_STATUS,
    PERMISSION_CORE_USERS_ASSIGN_ROLES, 
    PERMISSION_CORE_MODULES_VIEW_LIST,
    PERMISSION_CORE_SYSTEM_VIEW_LOGS_BASIC,
    PERMISSION_CORE_ROLES_VIEW, 
    PERMISSION_CORE_PERMISSIONS_VIEW, 
    PERMISSION_CORE_ROLES_CREATE, 
    PERMISSION_CORE_ROLES_EDIT,       
    PERMISSION_CORE_ROLES_DELETE,     
    PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS,
    PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS, # Назначаем роли Admin по умолчанию
}

DEFAULT_PERMISSIONS_FOR_CORE_USER_ROLE: Set[str] = set()


class RBACService:
    def __init__(self, services: Optional['BotServicesProvider'] = None, db_manager: Optional['DBManager'] = None):
        self._services_provider_ref: Optional['BotServicesProvider'] = services
        if db_manager: 
             self._db_manager = db_manager
        elif services and hasattr(services, 'db') and services.db is not None:
            self._db_manager = services.db
        else:
            self._db_manager = None 
            logger.warning("RBACService инициализирован без DBManager. "
                           "Методы ensure_default_... потребуют явной передачи сессии или DBManager.")
            
        self._logger = logger.bind(service="RBACService")
        self._logger.info("RBACService инициализирован.")

    async def _get_role_by_name(self, session: AsyncSession, role_name: str) -> Optional[Role]:
        self._logger.trace(f"Получение роли по имени: '{role_name}'")
        stmt = select(Role).options(selectinload(Role.permissions)).where(Role.name == role_name)
        result = await session.execute(stmt)
        role = result.scalars().first()
        self._logger.trace(f"Роль '{role_name}' найдена: {role is not None} (ID: {getattr(role, 'id', 'N/A')})")
        return role

    async def get_or_create_role(self, session: AsyncSession, role_name: str, description: Optional[str] = None) -> Optional[Role]:
        role = await self._get_role_by_name(session, role_name)
        if not role:
            role_def_desc = DEFAULT_ROLES_DEFINITIONS.get(role_name)
            current_description = description if description is not None else role_def_desc
            
            if role_name in DEFAULT_ROLES_DEFINITIONS and description is None:
                current_description = role_def_desc

            self._logger.info(f"Роль '{role_name}' не найдена, будет создана с описанием: '{current_description or 'отсутствует'}'.")
            role = Role(name=role_name, description=current_description)
            session.add(role)
            try:
                await session.flush([role])
                self._logger.success(f"Роль '{role_name}' создана (сflushed) с ID: {role.id}")
            except Exception as e_flush_role:
                self._logger.error(f"Ошибка при flush для новой роли '{role_name}': {e_flush_role}", exc_info=True)
                return None 
        return role

    async def register_permissions_from_modules(self, session: AsyncSession) -> int:
        if not self._services_provider_ref or not hasattr(self._services_provider_ref, 'modules'):
            self._logger.error("ModuleLoader не доступен через BotServicesProvider. Регистрация разрешений модулей невозможна.")
            return 0
        
        module_loader = self._services_provider_ref.modules
        declared_perms_manifests: List[ModulePermissionManifestSchema] = module_loader.get_all_declared_permissions_from_active_modules()
        
        if not declared_perms_manifests:
            self._logger.info("Не найдено разрешений, объявленных в активных модулях, для регистрации.")
            return 0

        self._logger.info(f"Найдено {len(declared_perms_manifests)} разрешений в манифестах модулей для регистрации/проверки...")
        
        created_count = 0
        
        for perm_mft in declared_perms_manifests:
            existing_perm = await self._get_permission_by_name(session, perm_mft.name)
            if not existing_perm:
                new_perm_obj = await self.get_or_create_permission(session, perm_mft.name, perm_mft.description)
                if new_perm_obj: 
                    created_count +=1 
                else:
                    self._logger.error(f"Не удалось создать/получить разрешение модуля '{perm_mft.name}'.")
            else:
                if existing_perm.description != perm_mft.description:
                     self._logger.info(f"Описание для существующего разрешения модуля '{perm_mft.name}' отличается. "
                                      f"БД: '{existing_perm.description}', Манифест: '{perm_mft.description}'. Описание не обновляется.")
                self._logger.trace(f"Разрешение модуля '{perm_mft.name}' уже существует в БД.")
        
        if created_count > 0 : 
             self._logger.success(f"{created_count} разрешений из модулей были созданы/обработаны (flush был в get_or_create_permission).")
        
        return created_count


    async def ensure_default_entities_exist(self, session: AsyncSession) -> Tuple[int, int, int]:
        self._logger.info("Проверка и создание стандартных сущностей RBAC (роли, разрешения ядра, разрешения модулей)...")
        
        created_core_perms_count = 0
        created_module_perms_count = 0 
        created_roles_count = 0
        initial_session_dirty = bool(session.new or session.dirty or session.deleted)

        self._logger.debug("Этап 1: Создание/получение стандартных разрешений ЯДРА.")
        core_permissions_to_add_objs: List[Permission] = []
        for perm_name, perm_description in DEFAULT_CORE_PERMISSIONS_DEFINITIONS.items(): 
            existing_perm = await self._get_permission_by_name(session, perm_name)
            if not existing_perm:
                new_perm = Permission(name=perm_name, description=perm_description)
                core_permissions_to_add_objs.append(new_perm)
                self._logger.info(f"Разрешение ядра '{perm_name}' подготовлено для добавления.")
                created_core_perms_count += 1
        
        if core_permissions_to_add_objs:
            session.add_all(core_permissions_to_add_objs)
            self._logger.info(f"{created_core_perms_count} разрешений ядра добавлены в сессию.")

        self._logger.debug("Этап 2: Регистрация разрешений из МАНИФЕСТОВ МОДУЛЕЙ.")
        module_perms_result = await self.register_permissions_from_modules(session)
        if module_perms_result == -1: 
            self._logger.error("Критическая ошибка при регистрации разрешений модулей. Дальнейшая инициализация RBAC прервана.")
            return 0, 0, -1 
        created_module_perms_count = module_perms_result
        
        self._logger.debug("Этап 3: Создание/получение стандартных РОЛЕЙ.")
        roles_to_add_objs: List[Role] = []
        for role_name, role_description in DEFAULT_ROLES_DEFINITIONS.items(): 
            existing_role = await self._get_role_by_name(session, role_name) 
            if not existing_role:
                new_role = Role(name=role_name, description=role_description)
                roles_to_add_objs.append(new_role)
                self._logger.info(f"Стандартная роль '{role_name}' подготовлена для добавления.")
                created_roles_count += 1
        
        if roles_to_add_objs:
            session.add_all(roles_to_add_objs)
            self._logger.info(f"{created_roles_count} стандартных ролей добавлены в сессию.")
        
        if core_permissions_to_add_objs or roles_to_add_objs or created_module_perms_count > 0 : 
            try:
                self._logger.debug("Этап 4: Выполняется общий flush для получения ID новых сущностей...")
                await session.flush()
                self._logger.debug("Общий Flush выполнен успешно.")
            except Exception as e_flush_all:
                self._logger.error(f"Ошибка при общем flush ролей/разрешений: {e_flush_all}", exc_info=True)
                await session.rollback() 
                return 0, 0, 0 

        self._logger.debug(f"Этап 5: Назначение разрешений ЯДРА стандартным ролям.")
        assigned_perms_summary: Dict[str, int] = {}
        
        all_permissions_in_db = await self.get_all_permissions(session)
        all_permissions_map_by_name = {p.name: p for p in all_permissions_in_db}

        role_core_permission_map = {
            DEFAULT_ROLE_ADMIN: DEFAULT_PERMISSIONS_FOR_CORE_ADMIN_ROLE,
            DEFAULT_ROLE_MODERATOR: DEFAULT_PERMISSIONS_FOR_CORE_MODERATOR_ROLE,
            DEFAULT_ROLE_USER: DEFAULT_PERMISSIONS_FOR_CORE_USER_ROLE 
        }
        
        changes_in_role_perms_assignment = False
        for role_name_to_setup, core_perm_names_to_assign in role_core_permission_map.items():
            role_obj = await self._get_role_by_name(session, role_name_to_setup) 
            if not role_obj or role_obj.id is None:
                self._logger.error(f"Роль '{role_name_to_setup}' не найдена или не имеет ID после flush. Невозможно назначить разрешения.")
                continue
            
            current_role_assigned_count = 0
            self._logger.info(f"Назначение ядерных разрешений роли '{role_name_to_setup}' (ID: {role_obj.id})...")
            for perm_name in core_perm_names_to_assign:
                perm_obj_to_assign = all_permissions_map_by_name.get(perm_name)
                if not perm_obj_to_assign or perm_obj_to_assign.id is None:
                    self._logger.warning(f"Ядерное разрешение '{perm_name}' для роли '{role_name_to_setup}' не найдено в общем списке или не имеет ID. Пропуск.")
                    continue
                
                if await self._ensure_role_has_permission_link(session, role_obj.id, perm_obj_to_assign.id):
                    if await self.assign_permission_to_role(session, role_obj, perm_obj_to_assign.name, auto_create_perm=False):
                        current_role_assigned_count +=1
                        changes_in_role_perms_assignment = True 
            
            if current_role_assigned_count > 0:
                assigned_perms_summary[role_name_to_setup] = current_role_assigned_count
                self._logger.info(f"{current_role_assigned_count} новых ядерных разрешений были подготовлены/назначены роли '{role_name_to_setup}'.")

        self._logger.debug(f"Этап 5.1: Автоматическое назначение базовых прав модулей роли '{DEFAULT_ROLE_USER}'.")
        role_user_obj = await self._get_role_by_name(session, DEFAULT_ROLE_USER)
        module_loader = self._services_provider_ref.modules if self._services_provider_ref else None
        
        auto_assigned_module_perms_count = 0
        if role_user_obj and role_user_obj.id and module_loader:
            for module_info in module_loader.get_all_modules_info():
                if module_info.manifest and \
                   module_info.manifest.metadata and \
                   module_info.manifest.metadata.assign_default_access_to_user_role:
                    
                    base_access_perm_name = f"{module_info.name}.access_user_features"
                    perm_obj = all_permissions_map_by_name.get(base_access_perm_name)
                    if perm_obj and perm_obj.id:
                        if await self._ensure_role_has_permission_link(session, role_user_obj.id, perm_obj.id):
                            if await self.assign_permission_to_role(session, role_user_obj, perm_obj.name, auto_create_perm=False):
                                self._logger.info(f"Автоматически назначено разрешение '{perm_obj.name}' роли '{DEFAULT_ROLE_USER}'.")
                                auto_assigned_module_perms_count += 1
                                changes_in_role_perms_assignment = True 
                    else:
                        self._logger.warning(f"Не найдено зарегистрированное разрешение '{base_access_perm_name}' для модуля '{module_info.name}', "
                                             "хотя он помечен для авто-назначения роли User.")
        if auto_assigned_module_perms_count > 0:
            if DEFAULT_ROLE_USER in assigned_perms_summary :
                 assigned_perms_summary[DEFAULT_ROLE_USER] += auto_assigned_module_perms_count
            else:
                 assigned_perms_summary[DEFAULT_ROLE_USER] = auto_assigned_module_perms_count


        final_session_dirty = bool(session.new or session.dirty or session.deleted)
        if final_session_dirty or (not initial_session_dirty and (created_roles_count or created_core_perms_count or created_module_perms_count > 0 or any(assigned_perms_summary.values()))):
            self._logger.debug("Этап 6: Попытка коммита всех изменений RBAC...")
            try:
                await session.commit() 
                summary_log_parts = []
                if created_roles_count: summary_log_parts.append(f"{created_roles_count} ролей создано")
                if created_core_perms_count: summary_log_parts.append(f"{created_core_perms_count} разрешений ядра создано")
                if created_module_perms_count > 0: summary_log_parts.append(f"{created_module_perms_count} разрешений модулей создано/зарегистрировано")
                for role_name_sum, count_sum in assigned_perms_summary.items():
                    if count_sum > 0: summary_log_parts.append(f"{count_sum} разрешений назначено {role_name_sum}")
                
                log_msg_commit = (f"Стандартные RBAC сущности успешно созданы/обновлены и закоммичены: "
                                  f"{'; '.join(summary_log_parts) or 'нет явных изменений для логирования после назначения прав.'}.")
                self._logger.success(log_msg_commit)
            except Exception as e:
                self._logger.error(f"Ошибка при коммите стандартных RBAC сущностей: {e}", exc_info=True)
                await session.rollback()
                return 0, 0, 0 
        else:
            self._logger.info("Не было обнаружено фактических изменений в RBAC для коммита.")

        return created_roles_count, created_core_perms_count, created_module_perms_count
    

    async def _ensure_role_has_permission_link(self, session: AsyncSession, role_id: int, permission_id: int) -> bool:
        self._logger.trace(f"[ENSURE_LINK] Проверка связи для RoleID: {role_id}, PermID: {permission_id}")
        link_exists_stmt = select(RolePermission.id).where(
            RolePermission.role_id == role_id,
            RolePermission.permission_id == permission_id
        ).limit(1)
        try:
            link_res = await session.execute(link_exists_stmt)
            scalar_result = link_res.scalar_one_or_none()
            if scalar_result is None:
                self._logger.trace(f"[ENSURE_LINK] Связь для RoleID {role_id}, PermID {permission_id} НЕ найдена (нужно создать).")
                return True 
            else:
                self._logger.trace(f"[ENSURE_LINK] Связь для RoleID {role_id}, PermID {permission_id} уже существует (ID: {scalar_result}).")
                return False 
        except Exception as e_exec_link:
            self._logger.error(f"[ENSURE_LINK] Ошибка при проверке связи RolePermission для RoleID {role_id}, PermID {permission_id}: {e_exec_link}", exc_info=True)
            return False

    async def assign_role_to_user(self, session: AsyncSession, user: User, role_name: str) -> bool:
        if not user or user.id is None: 
            self._logger.error(f"Попытка назначить роль: Пользователь не валиден или не имеет ID (user: {user}).")
            return False
            
        role_obj = await self.get_or_create_role(session, role_name)
        if not role_obj or role_obj.id is None: 
            self._logger.error(f"Не удалось получить или создать роль '{role_name}' (ID: {getattr(role_obj, 'id', 'N/A')}) для назначения пользователю {user.id}.")
            return False

        self._logger.debug(f"[ASSIGN_ROLE_TO_USER] Проверка связи для UserID: {user.id} (тип: {type(user.id)}), RoleID: {role_obj.id} (тип: {type(role_obj.id)})")
        existing_link_stmt = select(UserRole.id).where(UserRole.user_id == user.id, UserRole.role_id == role_obj.id).limit(1)
        try:
            existing_link_res = await session.execute(existing_link_stmt) 
            scalar_res_link = existing_link_res.scalar_one_or_none()
            self._logger.debug(f"[ASSIGN_ROLE_TO_USER] Результат scalar_one_or_none для UserID {user.id}, RoleID {role_obj.id}: {scalar_res_link} (тип: {type(scalar_res_link)})")

            if scalar_res_link is not None:
                self._logger.debug(f"Роль '{role_name}' уже назначена пользователю ID: {user.id}.")
                return True 
            
            new_user_role_link = UserRole(user_id=user.id, role_id=role_obj.id)
            session.add(new_user_role_link)
            self._logger.info(f"Роль '{role_name}' (RoleID: {role_obj.id}) добавлена пользователю UserID: {user.id} (ожидает commit).")
            return True
        except Exception as e_assign:
            self._logger.error(f"Ошибка при назначении роли '{role_name}' пользователю {user.id}: {e_assign}", exc_info=True)
            return False

    async def remove_role_from_user(self, session: AsyncSession, user: User, role_name: str) -> bool:
        if not user or user.id is None:
            self._logger.error("Попытка снять роль с невалидного объекта пользователя (отсутствует ID).")
            return False
            
        role_to_remove = await self._get_role_by_name(session, role_name)
        if not role_to_remove or role_to_remove.id is None: 
            self._logger.warning(f"Попытка снять несуществующую роль '{role_name}' или роль без ID с пользователя {user.id}.")
            return True 

        try:
            stmt_delete = delete(UserRole).where(UserRole.user_id == user.id, UserRole.role_id == role_to_remove.id)
            result = await session.execute(stmt_delete) 
            
            if result.rowcount > 0:
                self._logger.info(f"Роль '{role_name}' снята с пользователя {user.id} (ожидает commit).")
                return True
            else:
                self._logger.debug(f"Роль '{role_name}' не была назначена пользователю {user.id}. Снятие не требуется.")
                return True
        except Exception as e: 
            self._logger.error(f"Ошибка при удалении связи UserRole для пользователя {user.id} и роли '{role_name}': {e}", exc_info=True)
            return False

    def user_has_role(self, user: User, role_name: str) -> bool:
        if not user or not user.roles: return False
        return any(r.name.lower() == role_name.lower() for r in user.roles if r and r.name)

    async def user_has_role_async(self, session: AsyncSession, user_telegram_id: int, role_name: str) -> bool:
        stmt = select(User).options(selectinload(User.roles)).where(User.telegram_id == user_telegram_id)
        result = await session.execute(stmt)
        user_db: Optional[User] = result.scalars().first()
        
        if not user_db:
            self._logger.debug(f"Пользователь с Telegram ID {user_telegram_id} не найден при проверке роли '{role_name}'.")
            return False
        return self.user_has_role(user_db, role_name)

    def get_user_role_names(self, user: User) -> Set[str]:
        if not user or not user.roles: return set()
        return {role.name for role in user.roles if role and role.name}

    async def get_user_roles_async(self, session: AsyncSession, user_telegram_id: int) -> List[Role]:
        stmt = select(User).options(selectinload(User.roles)).where(User.telegram_id == user_telegram_id)
        result = await session.execute(stmt)
        user_db: Optional[User] = result.scalars().first()
        
        if not user_db:
            self._logger.debug(f"Пользователь с Telegram ID {user_telegram_id} не найден при запросе его ролей.")
            return []
        return list(user_db.roles) if user_db.roles else []

    async def get_all_roles(self, session: AsyncSession) -> List[Role]:
        stmt = select(Role).options(selectinload(Role.permissions)).order_by(Role.name)
        result = await session.execute(stmt)
        roles = list(result.scalars().all())
        self._logger.debug(f"Запрошен список всех ролей. Найдено: {len(roles)}.")
        return roles

    async def delete_role(self, session: AsyncSession, role_name_or_id: Union[str, int]) -> bool: 
        self._logger.info(f"Попытка удаления роли: '{role_name_or_id}'...")
        role: Optional[Role] = None
        if isinstance(role_name_or_id, str):
            role = await self._get_role_by_name(session, role_name_or_id)
        elif isinstance(role_name_or_id, int):
            role = await session.get(Role, role_name_or_id)
        
        if not role:
            self._logger.warning(f"Роль '{role_name_or_id}' для удаления не найдена.")
            return False 
        
        if role.name in DEFAULT_ROLES_DEFINITIONS: 
             self._logger.error(f"Попытка удаления стандартной роли '{role.name}'. Операция запрещена.")
             return False
        
        user_role_count_stmt = select(sql_func.count(UserRole.id)).where(UserRole.role_id == role.id)
        user_role_count_res = await session.execute(user_role_count_stmt)
        user_count_with_role = user_role_count_res.scalar_one()
        
        if user_count_with_role > 0:
            self._logger.error(f"Невозможно удалить роль '{role.name}' (ID: {role.id}), так как она назначена {user_count_with_role} пользователю(ям). "
                               "Сначала снимите эту роль со всех пользователей.")
            return False
            
        try:
            await session.execute(delete(RolePermission).where(RolePermission.role_id == role.id))
            await session.delete(role)
            self._logger.warning(f"Роль '{role.name}' (ID: {role.id}) и ее связи с разрешениями помечены для удаления (ожидает commit).")
            return True
        except Exception as e:
            self._logger.error(f"Ошибка при попытке удаления роли '{role.name}': {e}", exc_info=True)
            return False

    async def _get_permission_by_name(self, session: AsyncSession, permission_name: str) -> Optional[Permission]:
        self._logger.trace(f"Получение разрешения по имени: '{permission_name}'")
        stmt = select(Permission).where(Permission.name == permission_name)
        result = await session.execute(stmt)
        perm = result.scalars().first()
        self._logger.trace(f"Разрешение '{permission_name}' найдено: {perm is not None} (ID: {getattr(perm, 'id', 'N/A')})")
        return perm

    async def get_or_create_permission(self, session: AsyncSession, permission_name: str, description: Optional[str] = None) -> Optional[Permission]:
        permission = await self._get_permission_by_name(session, permission_name)
        if not permission:
            perm_def_desc = DEFAULT_CORE_PERMISSIONS_DEFINITIONS.get(permission_name)
            current_description = description if description is not None else perm_def_desc

            if current_description is not None: 
                self._logger.info(f"Разрешение '{permission_name}' не найдено, будет создано с описанием: '{current_description}'.")
                permission = Permission(name=permission_name, description=current_description)
                session.add(permission)
                try:
                    await session.flush([permission]) 
                    self._logger.success(f"Разрешение '{permission_name}' создано (сflushed) с ID: {permission.id}")
                except Exception as e_flush_perm:
                    self._logger.error(f"Ошибка при flush для нового разрешения '{permission_name}': {e_flush_perm}", exc_info=True)
                    return None 
            else:
                self._logger.warning(f"Разрешение '{permission_name}' не найдено и описание не предоставлено. Не будет создано автоматически.")
                return None
        return permission
        
    async def assign_permission_to_role(
        self, 
        session: AsyncSession, 
        role: Role, 
        permission_name: str,
        auto_create_perm: bool = True, 
    ) -> bool:
        if not role or role.id is None:
            self._logger.error(f"Попытка назначить разрешение: Роль не валидна или не имеет ID (role: {role}).")
            return False

        permission_obj: Optional[Permission] = None
        if auto_create_perm:
            permission_obj = await self.get_or_create_permission(session, permission_name, description=None)
        else:
            permission_obj = await self._get_permission_by_name(session, permission_name)
            
        if not permission_obj or permission_obj.id is None:
            log_msg = (f"Не удалось получить" + (" или создать" if auto_create_perm else "") +
                       f" разрешение '{permission_name}' (ID: {getattr(permission_obj, 'id', 'N/A')}) для назначения роли '{role.name}'.")
            self._logger.error(log_msg)
            return False
        
        self._logger.debug(f"[ASSIGN_PERM_TO_ROLE] Проверка/назначение связи для RoleID: {role.id}, PermID: {permission_obj.id}")
        
        if await self._ensure_role_has_permission_link(session, role.id, permission_obj.id): 
            try:
                new_role_perm_link = RolePermission(role_id=role.id, permission_id=permission_obj.id)
                session.add(new_role_perm_link)
                self._logger.info(f"Разрешение '{permission_name}' (PermID: {permission_obj.id}) добавлено роли '{role.name}' (RoleID: {role.id}) (ожидает commit).")
                return True
            except Exception as e_add_link:
                self._logger.error(f"Ошибка при создании объекта RolePermission для RoleID {role.id}, PermID {permission_obj.id}: {e_add_link}", exc_info=True)
                return False
        else: 
            link_exists_stmt = select(RolePermission.id).where(
                RolePermission.role_id == role.id,          
                RolePermission.permission_id == permission_obj.id 
            ).limit(1)
            existing_link_res = await session.execute(link_exists_stmt)
            if existing_link_res.scalar_one_or_none() is not None:
                 self._logger.trace(f"Разрешение '{permission_name}' уже назначено роли '{role.name}' (подтверждено).")
                 return True 
            else: 
                 self._logger.error(f"Не удалось подтвердить или создать связь для разрешения '{permission_name}' и роли '{role.name}'. "
                                     "Возможно, ошибка в _ensure_role_has_permission_link или параллельное изменение.")
                 return False

    async def remove_permission_from_role(self, session: AsyncSession, role: Role, permission_name: str) -> bool:
        if not role or role.id is None: return False
        permission_to_remove = await self._get_permission_by_name(session, permission_name)
        if not permission_to_remove or permission_to_remove.id is None:
            self._logger.warning(f"Попытка снять несуществующее разрешение '{permission_name}' с роли '{role.name}'.")
            return True

        try:
            stmt_delete = delete(RolePermission).where(
                RolePermission.role_id == role.id, 
                RolePermission.permission_id == permission_to_remove.id
            )
            result = await session.execute(stmt_delete)
            if result.rowcount > 0:
                self._logger.info(f"Разрешение '{permission_name}' снято с роли '{role.name}' (ожидает commit).")
                return True
            else:
                self._logger.debug(f"Разрешение '{permission_name}' не было назначено роли '{role.name}'. Снятие не требуется.")
                return True
        except Exception as e_remove_perm:
            self._logger.error(f"Ошибка при снятии разрешения '{permission_name}' с роли '{role.name}': {e_remove_perm}", exc_info=True)
            return False

    async def user_has_permission(self, session: AsyncSession, user_telegram_id: int, permission_name: str) -> bool:
        # 1. Проверка на Владельца (высший приоритет)
        if self._services_provider_ref and self._services_provider_ref.config: 
            if user_telegram_id in self._services_provider_ref.config.core.super_admins:
                self._logger.trace(f"Пользователь TG ID {user_telegram_id} является Владельцем, разрешение '{permission_name}' предоставлено.")
                return True
        
        # Загружаем пользователя с его ролями и прямыми разрешениями
        stmt = (
            select(User)
            .options(
                selectinload(User.roles).selectinload(Role.permissions), # Роли и их разрешения
                selectinload(User.direct_permissions) # Прямые разрешения пользователя
            )
            .where(User.telegram_id == user_telegram_id)
        )
        result = await session.execute(stmt)
        user_db: Optional[User] = result.scalars().first()

        if not user_db:
            self._logger.trace(f"Пользователь TG ID {user_telegram_id} не найден при проверке разрешения '{permission_name}'.")
            return False
        
        perm_name_lower = permission_name.lower()

        # 2. Проверка прямых разрешений пользователя
        if user_db.direct_permissions:
            for perm_obj in user_db.direct_permissions:
                if perm_obj.name.lower() == perm_name_lower:
                    self._logger.trace(f"Пользователь TG ID {user_telegram_id} имеет прямое разрешение '{permission_name}'.")
                    return True
        
        # 3. Проверка разрешений через роли
        if not user_db.roles:
            self._logger.trace(f"Пользователь TG ID {user_telegram_id} не имеет ролей при проверке разрешения '{permission_name}'.")
            # (Если нет прямых прав и нет ролей, то права нет)
            # return False # Это условие уже покрывается следующим return False
        else: # Если есть роли, проверяем их
            for role_obj in user_db.roles:
                if role_obj.permissions: 
                    for perm_obj in role_obj.permissions:
                        if perm_obj.name.lower() == perm_name_lower:
                            self._logger.trace(f"Пользователь TG ID {user_telegram_id} имеет разрешение '{permission_name}' через роль '{role_obj.name}'.")
                            return True
        
        self._logger.trace(f"Пользователь TG ID {user_telegram_id} НЕ имеет разрешения '{permission_name}' (ни прямого, ни через роли).")
        return False

    async def get_all_permissions(self, session: AsyncSession) -> List[Permission]:
        stmt = select(Permission).order_by(Permission.name)
        result = await session.execute(stmt)
        permissions = list(result.scalars().all())
        self._logger.debug(f"Запрошен список всех разрешений. Найдено: {len(permissions)}.")
        return permissions

    async def get_role_permissions(self, session: AsyncSession, role_name: str) -> List[Permission]:
        stmt = select(Role).options(selectinload(Role.permissions)).where(Role.name == role_name)
        result = await session.execute(stmt)
        role_with_perms: Optional[Role] = result.scalars().first()
        
        if not role_with_perms:
            self._logger.warning(f"Запрошены разрешения для несуществующей роли '{role_name}'.")
            return []
            
        return list(role_with_perms.permissions) if role_with_perms.permissions else []

    # --- Новые методы для управления прямыми разрешениями пользователя ---

    async def assign_direct_permission_to_user(
        self, 
        session: AsyncSession, 
        user: User, 
        permission_name: str,
        auto_create_perm: bool = True # Обычно разрешение уже должно существовать
    ) -> bool:
        if not user or user.id is None:
            self._logger.error(f"Попытка назначить прямое разрешение: Пользователь не валиден или не имеет ID (user: {user}).")
            return False

        permission_obj: Optional[Permission]
        if auto_create_perm: # Это больше для тестов или специфических случаев
            permission_obj = await self.get_or_create_permission(session, permission_name)
        else:
            permission_obj = await self._get_permission_by_name(session, permission_name)
            
        if not permission_obj or permission_obj.id is None:
            log_msg = (f"Не удалось получить" + (" или создать" if auto_create_perm else "") +
                       f" разрешение '{permission_name}' для прямого назначения пользователю {user.telegram_id}.")
            self._logger.error(log_msg)
            return False

        # Проверяем, нет ли уже такой связи
        existing_link_stmt = select(UserPermission.id).where(
            UserPermission.user_id == user.id,
            UserPermission.permission_id == permission_obj.id
        ).limit(1)
        existing_link_res = await session.execute(existing_link_stmt)
        if existing_link_res.scalar_one_or_none() is not None:
            self._logger.debug(f"Прямое разрешение '{permission_name}' уже назначено пользователю {user.telegram_id}.")
            return True # Считаем успешным, если уже есть

        # Если мы управляем через user.direct_permissions.append()
        # user.direct_permissions.append(permission_obj)
        # session.add(user)
        # ИЛИ, если управляем связующей таблицей напрямую:
        new_user_perm_link = UserPermission(user_id=user.id, permission_id=permission_obj.id)
        session.add(new_user_perm_link)
        
        self._logger.info(f"Прямое разрешение '{permission_name}' добавлено пользователю {user.telegram_id} (ожидает commit).")
        return True

    async def remove_direct_permission_from_user(
        self, 
        session: AsyncSession, 
        user: User, 
        permission_name: str
    ) -> bool:
        if not user or user.id is None:
            self._logger.error("Попытка снять прямое разрешение с невалидного пользователя.")
            return False
        
        permission_to_remove = await self._get_permission_by_name(session, permission_name)
        if not permission_to_remove or permission_to_remove.id is None:
            self._logger.warning(f"Попытка снять несуществующее прямое разрешение '{permission_name}' с пользователя {user.telegram_id}.")
            return True # Считаем успешным, так как его и не было

        # Если мы управляем через user.direct_permissions.remove()
        # if permission_to_remove in user.direct_permissions: # Нужна загрузка user.direct_permissions
        #     user.direct_permissions.remove(permission_to_remove)
        #     session.add(user)
        #     self._logger.info(f"Прямое разрешение '{permission_name}' снято с пользователя {user.telegram_id} (ожидает commit).")
        #     return True
        # else:
        #     self._logger.debug(f"Прямое разрешение '{permission_name}' не было назначено пользователю {user.telegram_id}. Снятие не требуется.")
        #     return True
        # ИЛИ, если управляем связующей таблицей напрямую:
        stmt_delete = delete(UserPermission).where(
            UserPermission.user_id == user.id,
            UserPermission.permission_id == permission_to_remove.id
        )
        result = await session.execute(stmt_delete)
        if result.rowcount > 0:
            self._logger.info(f"Прямое разрешение '{permission_name}' снято с пользователя {user.telegram_id} (ожидает commit).")
            return True
        else:
            self._logger.debug(f"Прямое разрешение '{permission_name}' не было назначено пользователю {user.telegram_id}. Снятие не требуется.")
            return True


    async def get_user_direct_permissions(self, session: AsyncSession, user_id: int) -> List[Permission]:
        """Получает список прямых разрешений для пользователя (по его DB ID)."""
        user_db = await session.get(User, user_id, options=[selectinload(User.direct_permissions)])
        if not user_db:
            self._logger.warning(f"Запрошены прямые разрешения для несуществующего пользователя (DB ID: {user_id}).")
            return []
        return list(user_db.direct_permissions) if user_db.direct_permissions else []


======================================================================

------------------------------ FILE: core/events/dispatcher.py ------------------------------
# core/events/dispatcher.py

import asyncio
from collections import defaultdict
from typing import Callable, Any, Coroutine, List, Dict, Optional, Union, TYPE_CHECKING # Добавил Optional, Union
from loguru import logger

if TYPE_CHECKING:
    # Более строгий тип для обработчика события, если это необходимо.
    # EventHandler = Callable[..., Coroutine[Any, Any, None]]
    pass


class EventDispatcher:
    """
    Простая асинхронная шина событий для SwiftDevBot.
    Позволяет различным компонентам системы (ядру, модулям) публиковать события
    и подписываться на них, не имея прямых зависимостей друг от друга.
    """

    def __init__(self):
        # Словарь, где ключ - строковое имя (тип) события,
        # значение - список асинхронных функций-обработчиков (корутин).
        self._listeners: Dict[str, List[Callable[..., Coroutine[Any, Any, None]]]] = defaultdict(list)
        self._logger = logger.bind(service="EventDispatcher")
        self._logger.info("EventDispatcher инициализирован.")

    def subscribe(self, event_type: str, handler: Callable[..., Coroutine[Any, Any, None]]) -> None:
        """
        Подписывает асинхронный обработчик на указанный тип события.

        Args:
            event_type: Имя (тип) события, на которое осуществляется подписка.
                        Рекомендуется использовать префиксы (например, "sdb:core:startup", "module_name:user_registered").
            handler: Асинхронная функция-обработчик (корутина), которая будет вызвана при публикации события.
                     Обработчик должен принимать те же позиционные (*args) и именованные (**kwargs) аргументы,
                     что и передаются в метод publish().

        Raises:
            TypeError: Если переданный обработчик не является асинхронной функцией (корутиной).
        """
        if not asyncio.iscoroutinefunction(handler):
            err_msg = (f"Обработчик '{handler.__qualname__}' для события '{event_type}' должен быть "
                       f"асинхронной функцией (определенной с 'async def').")
            self._logger.error(err_msg)
            raise TypeError(err_msg) # Делаем проверку строже

        self._listeners[event_type].append(handler)
        self._logger.debug(f"Обработчик '{handler.__qualname__}' успешно подписан на событие '{event_type}'.")

    def unsubscribe(self, event_type: str, handler: Callable[..., Coroutine[Any, Any, None]]) -> None:
        """
        Отписывает указанный обработчик от указанного типа события.

        Args:
            event_type: Имя (тип) события.
            handler: Функция-обработчик, которую необходимо отписать.
        """
        try:
            self._listeners[event_type].remove(handler)
            self._logger.debug(f"Обработчик '{handler.__qualname__}' успешно отписан от события '{event_type}'.")
        except ValueError: # Обработчик не найден в списке для данного события
            self._logger.warning(f"Попытка отписать необъявленный обработчик '{handler.__qualname__}' "
                                 f"от события '{event_type}'. Обработчик не найден.")
        except KeyError: # Такого типа события вообще нет в _listeners
            self._logger.warning(f"Попытка отписаться от несуществующего типа события '{event_type}'.")

    async def publish(self, event_type: str, *args: Any, **kwargs: Any) -> List[Union[Any, Exception]]:
        """
        Асинхронно публикует событие, вызывая всех подписанных на него обработчиков.

        Обработчики для одного события запускаются конкурентно с использованием `asyncio.gather()`.
        Если какой-либо обработчик вызывает исключение, это исключение будет поймано,
        залогировано, и вместо результата этого обработчика в возвращаемом списке будет объект исключения.
        Остальные обработчики продолжат выполняться.

        Args:
            event_type: Имя (тип) публикуемого события.
            *args: Позиционные аргументы, которые будут переданы каждому обработчику.
            **kwargs: Именованные аргументы, которые будут переданы каждому обработчику.

        Returns:
            Список результатов выполнения каждого обработчика.
            Если обработчик вернул значение, оно будет в списке.
            Если обработчик вызвал исключение, в списке на его месте будет объект этого исключения.
            Если подписчиков на событие нет, возвращается пустой список.
        """
        if event_type not in self._listeners or not self._listeners[event_type]:
            self._logger.trace(f"Нет подписчиков для события '{event_type}'. Публикация пропущена.")
            return []

        handlers_to_call = self._listeners[event_type]
        # Формируем строку с аргументами для лога, чтобы не показывать слишком много данных
        args_repr = f"{len(args)} positional"
        kwargs_repr = f"{len(kwargs)} keyword"
        
        self._logger.info(f"Публикация события '{event_type}' для {len(handlers_to_call)} подписчиков. "
                          f"Аргументы: ({args_repr}), ({kwargs_repr}).")

        # Создаем список корутин для вызова
        tasks = [handler(*args, **kwargs) for handler in handlers_to_call]
        
        # Запускаем все обработчики конкурентно и собираем результаты или исключения
        results: List[Union[Any, Exception]] = await asyncio.gather(*tasks, return_exceptions=True)

        # Логируем ошибки, если они произошли в обработчиках
        for i, result_or_exc in enumerate(results):
            if isinstance(result_or_exc, Exception):
                failed_handler_name = handlers_to_call[i].__qualname__
                self._logger.error(
                    f"Ошибка в обработчике события '{failed_handler_name}' при обработке события '{event_type}': "
                    f"{type(result_or_exc).__name__}('{result_or_exc}')",
                    exc_info=result_or_exc # Для полного трейсбека исключения
                )
        
        return results

    def get_listeners_count(self, event_type: Optional[str] = None) -> Union[int, Dict[str, int]]:
        """
        Возвращает количество подписчиков.
        Если `event_type` указан, возвращает количество для этого события.
        Если `event_type` не указан (None), возвращает словарь {event_type: count} для всех событий.
        """
        if event_type:
            return len(self._listeners.get(event_type, []))
        else:
            return {etype: len(handler_list) for etype, handler_list in self._listeners.items() if handler_list}

    async def dispose(self) -> None: # Сделаем async, если в будущем понадобится асинхронная очистка
        """Очищает всех подписчиков. Полезно при остановке или перезагрузке системы."""
        self._listeners.clear()
        self._logger.info("EventDispatcher очищен (все подписчики и списки событий удалены).")


======================================================================

------------------------------ FILE: core/events/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/http_client/manager.py ------------------------------
# core/http_client/manager.py

import asyncio
from typing import Optional, Dict, Any, Union, TYPE_CHECKING

try:
    import aiohttp
    from aiohttp import ClientSession, ClientTimeout, ClientResponse, ClientResponseError, ClientError
    from aiohttp import ServerTimeoutError as AiohttpTimeoutError
except ImportError:
    aiohttp = None # type: ignore
    ClientSession = Any # type: ignore
    ClientTimeout = Any # type: ignore
    ClientResponse = Any # type: ignore
    ClientResponseError = Any # type: ignore
    ClientError = Any # type: ignore
    AiohttpTimeoutError = Any # type: ignore

from loguru import logger

if TYPE_CHECKING:
    from core.app_settings import AppSettings


class HTTPClientManager:
    def __init__(self, default_timeout_seconds: int = 10, app_settings: Optional['AppSettings'] = None):
        if not aiohttp:
            msg = ("Библиотека aiohttp не установлена. Пожалуйста, установите ее (`pip install aiohttp`). "
                   "HTTPClientManager не будет работать.")
            logger.critical(msg)
            raise ImportError(msg)
            
        self._session: Optional[ClientSession] = None
        self._default_timeout_config = ClientTimeout(total=default_timeout_seconds) 
        self._app_settings: Optional['AppSettings'] = app_settings 
        self._is_initialized_successfully = False
        logger.info(f"HTTPClientManager инициализирован (таймаут по умолчанию: {default_timeout_seconds} сек).")

    async def initialize(self) -> None:
        if self._session is None or self._session.closed:
            try:
                self._session = ClientSession(timeout=self._default_timeout_config)
                self._is_initialized_successfully = True
                logger.success("aiohttp.ClientSession успешно создан и инициализирован.")
            except Exception as e:
                logger.error(f"Ошибка при создании aiohttp.ClientSession: {e}", exc_info=True)
                self._session = None
                self._is_initialized_successfully = False
                raise 
        else:
            logger.debug("aiohttp.ClientSession уже был инициализирован.")

    async def dispose(self) -> None:
        if self._session and not self._session.closed:
            try:
                await self._session.close()
                logger.info("aiohttp.ClientSession успешно закрыт.")
            except Exception as e:
                logger.error(f"Ошибка при закрытии aiohttp.ClientSession: {e}", exc_info=True)
        self._session = None
        self._is_initialized_successfully = False

    def is_available(self) -> bool:
        return self._session is not None and not self._session.closed and self._is_initialized_successfully

    def _get_session(self) -> ClientSession:
        if not self.is_available():
            msg = "HTTPClientManager (aiohttp.ClientSession) не инициализирован или закрыт! Вызовите initialize()."
            logger.critical(msg)
            raise RuntimeError(msg)
        return self._session # type: ignore 

    async def request(
        self,
        method: str,
        url: str,
        params: Optional[Dict[str, Any]] = None,
        data: Optional[Any] = None,
        json_data: Optional[Any] = None,
        headers: Optional[Dict[str, str]] = None,
        timeout_seconds: Optional[int] = None,
        raise_for_status: bool = False 
    ) -> Optional[ClientResponse]:
        session = self._get_session()
        current_timeout_config = ClientTimeout(total=timeout_seconds) if timeout_seconds is not None else self._default_timeout_config
        
        request_kwargs = {
            "params": params, "data": data, "json": json_data,
            "headers": headers, "timeout": current_timeout_config,
        }
        active_request_kwargs = {k: v for k, v in request_kwargs.items() if v is not None}

        log_context = {"method": method.upper(), "url": url, "params": params, "json_body": json_data is not None}
        logger.debug(f"HTTP Request: {method.upper()} {url}", **log_context)
        
        try:
            async with session.request(method, url, **active_request_kwargs) as response:
                logger.debug(f"HTTP Response: Status {response.status} for {url}", 
                             **log_context, status_code=response.status)
                if raise_for_status:
                    response.raise_for_status() 
                return response
        except ClientResponseError as e: 
            logger.warning(f"HTTP ClientResponseError: {e.status} {e.message} for {url}", **log_context)
            raise 
        except (asyncio.TimeoutError, AiohttpTimeoutError) as e:
            logger.warning(f"HTTP TimeoutError for {url} (timeout: {current_timeout_config.total}s): {type(e).__name__}", **log_context)
            raise 
        except ClientError as e: 
            logger.error(f"HTTP ClientError for {url}: {e}", **log_context, exc_info=True)
            raise 
        except Exception as e: 
            logger.error(f"Unexpected HTTP Error during request to {url}: {e}", **log_context, exc_info=True)
            raise


    async def get_json(
        self, url: str, params: Optional[Dict[str, Any]] = None, 
        headers: Optional[Dict[str, str]] = None, timeout_seconds: Optional[int] = None,
        default_on_error: Optional[Any] = None 
    ) -> Optional[Any]:
        response: Optional[ClientResponse] = None
        try:
            response = await self.request("GET", url, params=params, headers=headers, 
                                          timeout_seconds=timeout_seconds, raise_for_status=True)
            if response: 
                return await response.json()
            return default_on_error 
        except (ClientResponseError, asyncio.TimeoutError, AiohttpTimeoutError, ClientError) as e:
            logger.warning(f"HTTP(S) error during get_json for {url}: {type(e).__name__} - {e}")
            if default_on_error is not None: return default_on_error
            raise
        except aiohttp.ContentTypeError as e_json: 
            logger.warning(f"Failed to decode JSON response from {url}: {e_json}")
            if response: logger.trace(f"Response text (JSON error): {(await response.text())[:200]}")
            if default_on_error is not None: return default_on_error
            raise
        except Exception as e_unexp: 
            logger.error(f"Unexpected error in get_json for {url}: {e_unexp}", exc_info=True)
            if default_on_error is not None: return default_on_error
            raise


    async def post_json_response(
        self, url: str, json_data: Optional[Any] = None, params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None, timeout_seconds: Optional[int] = None,
        default_on_error: Optional[Any] = None 
    ) -> Optional[Any]:
        response: Optional[ClientResponse] = None
        try:
            response = await self.request("POST", url, params=params, json_data=json_data, headers=headers,
                                          timeout_seconds=timeout_seconds, raise_for_status=True)
            if response:
                return await response.json()
            return default_on_error
        except (ClientResponseError, asyncio.TimeoutError, AiohttpTimeoutError, ClientError) as e:
            logger.warning(f"HTTP(S) error during post_json for {url}: {type(e).__name__} - {e}")
            if default_on_error is not None: return default_on_error
            raise
        except aiohttp.ContentTypeError as e_json:
            logger.warning(f"Failed to decode JSON response from {url} after POST: {e_json}")
            if response: logger.trace(f"Response text (JSON error): {(await response.text())[:200]}")
            if default_on_error is not None: return default_on_error
            raise
        except Exception as e_unexp:
            logger.error(f"Unexpected error in post_json for {url}: {e_unexp}", exc_info=True)
            if default_on_error is not None: return default_on_error
            raise


======================================================================

------------------------------ FILE: core/http_client/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/schemas/module_manifest.py ------------------------------
# core/schemas/module_manifest.py

from typing import List, Optional, Dict, Any, Union, Literal
from pydantic import BaseModel, Field, field_validator, HttpUrl, ValidationInfo
import re
from loguru import logger 


class CommandManifest(BaseModel):
    command: str = Field(..., description="Сама команда (без '/'). Например, 'weather'.")
    description: str = Field(..., description="Описание команды для пользователя (например, для /help).")
    icon: Optional[str] = Field(default=None, description="Эмодзи-иконка для команды (опционально).")
    category: Optional[str] = Field(default=None, description="Категория для группировки команд (опционально).")
    admin_only: bool = Field(default=False, alias="admin", description="Требует ли команда прав администратора.")

class SettingChoiceOption(BaseModel):
    value: Any
    display_name: str

class SettingManifest(BaseModel):
    type: Literal["string", "int", "float", "bool", "choice", "multichoice", "text"] = Field(
        description="Тип настройки."
    )
    label: str = Field(..., description="Человекочитаемое название настройки (для UI).")
    description: Optional[str] = Field(default=None, description="Подробное описание настройки (для UI).")
    default: Optional[Any] = Field(default=None, description="Значение по умолчанию. Обязательно, если required=True и нет значения в пользовательском конфиге.")
    required: bool = Field(default=False, description="Является ли настройка обязательной.")
    options: Optional[List[Union[str, int, float, SettingChoiceOption]]] = Field(
        default=None,
        description="Список доступных вариантов."
    )
    min_value: Optional[Union[int, float]] = Field(default=None, alias="min", description="Минимальное допустимое значение.")
    max_value: Optional[Union[int, float]] = Field(default=None, alias="max", description="Максимальное допустимое значение.")
    regex_validator: Optional[str] = Field(default=None, description="Регулярное выражение для валидации строки.")

    @field_validator('options', mode='before')
    @classmethod
    def _check_options_for_choice_type(cls, v: Optional[List[Any]], info: ValidationInfo) -> Optional[List[Any]]:
        setting_type = info.data.get('type') if info.data else None
        if setting_type in ["choice", "multichoice"] and (v is None or not v):
            raise ValueError(f"Поле 'options' обязательно для типа настройки '{setting_type}'")
        if setting_type not in ["choice", "multichoice"] and v is not None:
            logger.warning(f"Поле 'options' применимо только для 'choice'/'multichoice', но указано для '{setting_type}'.")
        return v

    @field_validator('min_value', 'max_value', mode='before')
    @classmethod
    def _check_min_max_for_numeric_type(cls, v: Optional[Union[int, float]], info: ValidationInfo) -> Optional[Union[int, float]]:
        setting_type = info.data.get('type') if info.data else None
        field_name = info.field_name 
        if setting_type not in ["int", "float"] and v is not None:
            logger.warning(f"Поле '{field_name}' применимо только для 'int'/'float', но указано для '{setting_type}'.")
        return v

    @field_validator('regex_validator', mode='before')
    @classmethod
    def _check_regex_for_string_type(cls, v: Optional[str], info: ValidationInfo) -> Optional[str]:
        setting_type = info.data.get('type') if info.data else None
        if setting_type != "string" and v is not None:
            logger.warning(f"Поле 'regex_validator' применимо только для 'string', но указано для '{setting_type}'.")
        if v is not None:
            try: re.compile(v)
            except re.error as e: raise ValueError(f"Невалидный regex в 'regex_validator': {e}")
        return v

    @field_validator('default', mode='after') 
    @classmethod
    def _check_default_for_required(cls, v: Optional[Any], info: ValidationInfo) -> Optional[Any]:
        if info.data.get('required') and v is None:
             field_label = info.data.get('label', 'Неизвестная настройка') 
             raise ValueError(f"Для обязательной настройки '{field_label}' (required=True) должно быть указано значение 'default' в манифесте.")
        return v

class PermissionManifest(BaseModel): 
    name: str = Field(..., description="Уникальное имя разрешения (например, 'my_module.can_edit_items'). Должно быть в формате 'module_name.permission_key'.")
    description: str = Field(..., description="Человекочитаемое описание разрешения.")

    @field_validator('name')
    @classmethod
    def _validate_permission_name_format(cls, v: str, info: ValidationInfo) -> str:
        if not re.fullmatch(r"^[a-z0-9_]+(\.[a-z0-9_]+)+$", v.lower()):
            raise ValueError(f"Имя разрешения '{v}' должно быть в формате 'module_name.permission_key' "
                             f"(например, 'example_module.view_data') и содержать только строчные буквы, цифры, '_' и '.'")
        return v.lower() 


class BackgroundTaskManifest(BaseModel):
    entry_point: str = Field(...)
    schedule: Optional[str] = Field(default=None)
    description: Optional[str] = Field(default=None)

class ModuleMetadata(BaseModel):
    homepage: Optional[HttpUrl] = Field(default=None)
    license: Optional[str] = Field(default=None)
    tags: List[str] = Field(default_factory=list)
    min_sdb_core_version: Optional[str] = Field(default=None)
    assign_default_access_to_user_role: bool = Field( # <--- НОВОЕ ПОЛЕ
        default=False, 
        description="Если true, базовое разрешение '{module_name}.access_user_features' будет автоматически назначено роли 'User'."
    )

    @field_validator('min_sdb_core_version', mode='before')
    @classmethod
    def _validate_semver_format(cls, v: Optional[str]) -> Optional[str]:
        if v is not None:
            semver_regex = r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$"
            if not re.fullmatch(semver_regex, v):
                raise ValueError(f"min_sdb_core_version ('{v}') должен быть в формате SemVer")
        return v

class ModuleManifest(BaseModel):
    name: str = Field(..., min_length=3, pattern=r'^[a-z][a-z0-9_]*[a-z0-9]$')
    display_name: str = Field(..., min_length=3)
    version: str = Field(...)
    description: Optional[str] = Field(default=None)
    author: Optional[str] = Field(default=None)
    
    python_requirements: List[str] = Field(default_factory=list)
    sdb_module_dependencies: List[str] = Field(default_factory=list)
    model_definitions: List[str] = Field(default_factory=list)
    commands: List[CommandManifest] = Field(default_factory=list)
    settings: Dict[str, SettingManifest] = Field(default_factory=dict) 
    declared_permissions: List[PermissionManifest] = Field(default_factory=list, alias="permissions")
    background_tasks: Dict[str, BackgroundTaskManifest] = Field(default_factory=dict)
    metadata: ModuleMetadata = Field(default_factory=ModuleMetadata) # <--- ИЗМЕНЕНО: metadata теперь не Optional, чтобы всегда было поле assign_default_access_to_user_role

    @field_validator('version', mode='before')
    @classmethod
    def _validate_module_version_format(cls, v: str) -> str:
        semver_regex = r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$"
        if not re.fullmatch(semver_regex, v):
            raise ValueError(f"Версия модуля ('{v}') должна соответствовать формату SemVer 2.0.0")
        return v

    @field_validator('name', mode='before')
    @classmethod
    def _validate_module_name(cls, v: str) -> str:
        if not v.islower() and "_" not in v: 
            if v.lower() != v: 
                 logger.warning(f"Имя модуля '{v}' содержит заглавные буквы. Рекомендуется snake_case.")
        return v
        
    @field_validator('declared_permissions') 
    @classmethod
    def _validate_permission_names_match_module(cls, v: List[PermissionManifest], info: ValidationInfo) -> List[PermissionManifest]:
        module_name = info.data.get('name') 
        if module_name:
            for perm_manifest in v:
                if not perm_manifest.name.startswith(f"{module_name}."):
                    raise ValueError(
                        f"Имя разрешения '{perm_manifest.name}' в модуле '{module_name}' "
                        f"должно начинаться с префикса '{module_name}.'"
                    )
        return v

    class Config:
        extra = 'forbid' 
        validate_assignment = True
        populate_by_name = True


======================================================================

------------------------------ FILE: core/ui/registry_ui.py ------------------------------
# core/ui/registry_ui.py

from typing import List, Dict, Optional, Callable, Any
from pydantic import BaseModel, Field, field_validator, ValidationError
from loguru import logger


class ModuleUIEntry(BaseModel):
    module_name: str = Field(description="Уникальное имя модуля (должно совпадать с manifest.name)")
    display_name: str = Field(description="Отображаемое имя для кнопки в меню")
    entry_callback_data: str = Field(description="Строка callback_data для кнопки входа в модуль")
    
    icon: Optional[str] = Field(default=None, description="Эмодзи-иконка для кнопки (опционально)")
    description: Optional[str] = Field(
        default=None, 
        description="Краткое описание модуля, может использоваться в UI (например, в списке модулей)"
    )
    order: int = Field(
        default=100, 
        description="Порядок сортировки в меню (меньшее значение означает более высокий приоритет/положение)"
    )
    # Новое поле для указания разрешения, необходимого для отображения этой кнопки в общем меню
    required_permission_to_view: Optional[str] = Field(
        default=None,
        description="Имя разрешения, необходимое для того, чтобы эта точка входа была видна пользователю."
    )

    @field_validator('module_name', 'display_name', 'entry_callback_data')
    @classmethod 
    def names_must_not_be_empty(cls, v: str) -> str: 
        if not v or not v.strip():
            raise ValueError("Имя модуля, отображаемое имя и entry_callback_data не могут быть пустыми строками")
        return v

    class Config:
        validate_assignment = True 
        extra = 'forbid' 


class UIRegistry:
    def __init__(self):
        self._module_entries: Dict[str, ModuleUIEntry] = {}
        self._logger = logger.bind(service="UIRegistry")
        self._logger.info("UIRegistry инициализирован.")

    def register_module_entry(
        self,
        module_name: str,
        display_name: str,
        entry_callback_data: str,
        icon: Optional[str] = None,
        description: Optional[str] = None,
        order: int = 100,
        required_permission_to_view: Optional[str] = None # <--- Новое поле
    ) -> bool:
        if module_name in self._module_entries:
            self._logger.warning(
                f"Модуль '{module_name}' уже зарегистрировал свою UI-точку входа. "
                f"Повторная регистрация перезапишет предыдущую запись."
            )
        
        try:
            entry = ModuleUIEntry(
                module_name=module_name,
                display_name=display_name,
                entry_callback_data=entry_callback_data,
                icon=icon,
                description=description,
                order=order,
                required_permission_to_view=required_permission_to_view # <--- Используем новое поле
            )
            self._module_entries[module_name] = entry
            self._logger.info(f"UI-точка входа для модуля '{module_name}' ('{display_name}') успешно зарегистрирована. "
                              f"Требуемое разрешение для просмотра: '{required_permission_to_view or 'нет'}'.")
            return True
        except ValidationError as e:
            self._logger.error(f"Ошибка валидации данных при регистрации UI-точки входа для модуля '{module_name}': {e}")
            return False
        except Exception as e:
            self._logger.error(f"Неожиданная ошибка при регистрации UI-точки входа для модуля '{module_name}': {e}", exc_info=True)
            return False

    def unregister_module_entry(self, module_name: str) -> bool:
        if module_name in self._module_entries:
            del self._module_entries[module_name]
            self._logger.info(f"UI-точка входа для модуля '{module_name}' была отменена (удалена из реестра).")
            return True
        else:
            self._logger.warning(f"Попытка отменить регистрацию для незарегистрированной UI-точки входа модуля '{module_name}'.")
            return False

    def get_all_module_entries(self) -> List[ModuleUIEntry]: # Убрал for_admin_status, будем проверять required_permission_to_view
        entries = list(self._module_entries.values())
        entries.sort(key=lambda x: (x.order, x.display_name.lower()))
        self._logger.trace(f"Запрошен список ВСЕХ UI-точек входа модулей. Найдено: {len(entries)}")
        return entries

    def get_module_entry(self, module_name: str) -> Optional[ModuleUIEntry]:
        return self._module_entries.get(module_name)

    async def dispose(self) -> None: 
        self._module_entries.clear()
        self._logger.info("UIRegistry очищен (все UI-точки входа модулей удалены).")


======================================================================

------------------------------ FILE: core/ui/handlers_core_ui.py ------------------------------
# SwiftDevBot/core/ui/handlers_core_ui.py
from aiogram import Router, F, types, Bot
from aiogram.filters import CommandStart, Command, StateFilter 
from aiogram.fsm.context import FSMContext 
from aiogram.fsm.state import State, StatesGroup 
from aiogram.utils.markdown import hbold, hitalic, hcode 
import html # <--- ИМПОРТИРУЕМ СТАНДАРТНЫЙ МОДУЛЬ html
from loguru import logger
from aiogram.exceptions import TelegramBadRequest 
from aiogram.types import ReplyKeyboardRemove 

from .callback_data_factories import CoreMenuNavigate, ModuleMenuEntry, CoreServiceAction 
from .keyboards_core import (
    get_main_menu_reply_keyboard,
    get_modules_list_keyboard, 
    get_welcome_confirmation_keyboard, 
    get_profile_menu_keyboard,         
    get_language_selection_keyboard, 
    TEXTS_CORE_KEYBOARDS_EN 
)
from core.database.core_models import User as DBUser 
from core.ui.registry_ui import ModuleUIEntry 
from sqlalchemy import select 
from core.i18n.translator import Translator 

from typing import TYPE_CHECKING, Optional, List
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession 

core_ui_router = Router(name="sdb_core_ui_handlers")
MODULE_NAME_FOR_LOG = "CoreUI"

class FSMFeedback(StatesGroup):
    waiting_for_feedback_message = State()

async def show_main_menu_reply(
    message_or_query: types.Message | types.CallbackQuery, 
    bot: Bot, 
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser,
    text_override: Optional[str] = None,
    state: Optional[FSMContext] = None 
):
    if state: 
        current_fsm_state = await state.get_state()
        if current_fsm_state is not None:
            logger.info(f"[{MODULE_NAME_FOR_LOG}] Сброс состояния FSM ({current_fsm_state}) перед показом главного reply-меню для пользователя {sdb_user.telegram_id}.")
            await state.clear()

    user_id = sdb_user.telegram_id
    user_display_name = sdb_user.full_name 
    logger.debug(f"[{MODULE_NAME_FOR_LOG}] User {user_id} ({user_display_name}) showing main reply menu.")
    
    texts = TEXTS_CORE_KEYBOARDS_EN
    default_text = f"🏠 {hbold('Главное меню SwiftDevBot')}\nС возвращением, {hbold(user_display_name)}! Выберите действие:"
    text_to_send = text_override if text_override else default_text
    
    keyboard = await get_main_menu_reply_keyboard(services_provider=services_provider, user_telegram_id=user_id)
    
    target_chat_id = message_or_query.chat.id if isinstance(message_or_query, types.Message) else message_or_query.message.chat.id # type: ignore

    if isinstance(message_or_query, types.CallbackQuery) and message_or_query.message:
        try:
            if message_or_query.message.reply_markup: 
                 await message_or_query.message.edit_reply_markup(reply_markup=None)
        except Exception as e_del_edit:
            logger.warning(f"Не удалось изменить/удалить старое сообщение перед показом reply menu: {e_del_edit}")
    
    await bot.send_message(target_chat_id, text_to_send, reply_markup=keyboard)
    
    if isinstance(message_or_query, types.CallbackQuery):
        await message_or_query.answer()


@core_ui_router.message(CommandStart())
async def handle_start_command(
    message: types.Message,
    bot: Bot, 
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser, 
    state: FSMContext, 
    user_was_just_created: Optional[bool] = False 
):
    user_tg = message.from_user 
    if not user_tg: return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_tg.id} (@{user_tg.username or 'N/A'}) вызвал /start. "
                f"SDB_User DB ID: {sdb_user.id}. Был только что создан (в middleware): {user_was_just_created}.")

    texts = TEXTS_CORE_KEYBOARDS_EN
    is_owner_from_config = sdb_user.telegram_id in services_provider.config.core.super_admins
    user_display_name = sdb_user.full_name 

    if is_owner_from_config or not user_was_just_created: 
        logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {sdb_user.telegram_id} ({'Владелец' if is_owner_from_config else 'существующий'}). Показ главного reply-меню.")
        await show_main_menu_reply(message, bot, services_provider, sdb_user, state=state) 
    else: 
        logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {sdb_user.telegram_id} новый. Показ приветственного сообщения.")
        welcome_title = texts.get("welcome_message_title", "Добро пожаловать!")
        welcome_body = texts.get("welcome_message_body", "Описание бота...")
        full_welcome_text = f"{hbold(welcome_title)}\n\n{welcome_body}"
        welcome_keyboard = get_welcome_confirmation_keyboard()
        await message.answer(full_welcome_text, reply_markup=welcome_keyboard)


@core_ui_router.callback_query(CoreServiceAction.filter(F.action == "confirm_registration"))
async def cq_confirm_registration_and_show_main_menu(
    query: types.CallbackQuery, 
    bot: Bot, 
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser,
    state: FSMContext 
):
    user_id = sdb_user.telegram_id 
    user_full_name = sdb_user.full_name
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_id} ({user_full_name}) подтвердил регистрацию, показ главного reply-меню.")
    
    if query.message:
        try:
            await query.message.delete()
        except Exception as e:
            logger.warning(f"Не удалось удалить сообщение с приветствием: {e}")
            
    await show_main_menu_reply(query, bot, services_provider, sdb_user, 
                               text_override=f"Отлично, {hbold(user_full_name)}! Вот главное меню:",
                               state=state) 


@core_ui_router.callback_query(CoreServiceAction.filter(F.action == "cancel_registration"))
async def cq_cancel_registration(
    query: types.CallbackQuery, 
    bot: Bot, 
    services_provider: 'BotServicesProvider', 
    state: FSMContext 
):
    user_id = query.from_user.id 
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_id} отменил регистрацию/продолжение.")
    await state.clear() 
    
    texts = TEXTS_CORE_KEYBOARDS_EN
    cancel_text = texts.get("registration_cancelled_message", "Регистрация отменена.")

    if query.message:
        try:
            await query.message.delete()
        except Exception as e_delete:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Не удалось удалить сообщение после отмены регистрации (user: {user_id}): {e_delete}")
    
    await bot.send_message(user_id, cancel_text, reply_markup=ReplyKeyboardRemove())
    await query.answer()


@core_ui_router.message(F.text == TEXTS_CORE_KEYBOARDS_EN["main_menu_reply_modules"], StateFilter(None)) 
async def handle_text_modules_list(message: types.Message, bot:Bot, services_provider: 'BotServicesProvider', sdb_user: DBUser):
    logger.info(f"Пользователь {sdb_user.telegram_id} нажал reply-кнопку 'Модули'")
    await send_modules_list_message(message.chat.id, bot, services_provider, sdb_user, page=1)

@core_ui_router.message(F.text == TEXTS_CORE_KEYBOARDS_EN["main_menu_reply_profile"], StateFilter(None))
async def handle_text_profile(message: types.Message, bot: Bot, services_provider: 'BotServicesProvider', sdb_user: DBUser):
    logger.info(f"Пользователь {sdb_user.telegram_id} нажал reply-кнопку 'Профиль'")
    await send_profile_message(message.chat.id, bot, services_provider, sdb_user)

@core_ui_router.message(F.text == TEXTS_CORE_KEYBOARDS_EN["main_menu_reply_feedback"], StateFilter(None))
async def handle_text_feedback_start_fsm(
    message: types.Message, 
    services_provider: 'BotServicesProvider', 
    sdb_user: DBUser, 
    state: FSMContext
):
    logger.info(f"Пользователь {sdb_user.telegram_id} нажал reply-кнопку 'Обратная связь', вход в FSM.")
    text = (
        "✍️ Пожалуйста, напишите ваше сообщение для обратной связи.\n"
        f"{hitalic('Для отмены введите /cancel_feedback')}"
    )
    await state.set_state(FSMFeedback.waiting_for_feedback_message)
    await message.answer(text) 

@core_ui_router.message(StateFilter(FSMFeedback.waiting_for_feedback_message), F.text)
async def process_feedback_message(
    message: types.Message, 
    bot: Bot, 
    services_provider: 'BotServicesProvider', 
    sdb_user: DBUser, 
    state: FSMContext
):
    feedback_text = message.text
    user_id = sdb_user.telegram_id
    # ИСПОЛЬЗУЕМ html.escape
    user_full_name_escaped = html.escape(sdb_user.full_name) 
    username_escaped = f"@{html.escape(sdb_user.username)}" if sdb_user.username else "(нет username)"
    
    logger.info(f"Получено сообщение обратной связи от {user_id} ({username_escaped}): '{feedback_text[:100]}...'")

    admin_message_header = (
        f"📬 {hbold('Новый отзыв от пользователя!')}\n\n"
        f"👤 От: {user_full_name_escaped}\n"
        f"🆔 Telegram ID: {hcode(str(user_id))}\n"
        f"🔗 Username: {username_escaped}\n"
        f"🕒 Время: {message.date.strftime('%Y-%m-%d %H:%M:%S %Z') if message.date else 'N/A'}\n"
    )
    admin_message_body = f"\n📝 {hbold('Текст отзыва:')}\n{html.escape(feedback_text)}" # ИСПОЛЬЗУЕМ html.escape
    full_admin_message = admin_message_header + admin_message_body
    
    sent_to_admins_count = 0
    if services_provider.config.core.super_admins:
        for admin_tg_id in services_provider.config.core.super_admins:
            try:
                await bot.send_message(admin_tg_id, full_admin_message)
                sent_to_admins_count += 1
            except Exception as e:
                logger.error(f"Не удалось отправить обратную связь админу {admin_tg_id}: {e}")
        if sent_to_admins_count > 0:
            logger.info(f"Отзыв успешно отправлен {sent_to_admins_count} супер-администраторам.")
        else:
            logger.warning("Отзыв не был отправлен ни одному супер-администратору (возможно, список пуст или произошли ошибки).")
    else:
        logger.warning("Список супер-администраторов пуст. Отзыв не будет отправлен.")
    
    await message.reply("Спасибо за ваш отзыв! Мы его получили.")
    await show_main_menu_reply(message, bot, services_provider, sdb_user, text_override="Главное меню:", state=state)

@core_ui_router.message(Command("cancel_feedback"), StateFilter(FSMFeedback.waiting_for_feedback_message))
async def cancel_feedback_fsm(
    message: types.Message, 
    bot: Bot,
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser,
    state: FSMContext
):
    logger.info(f"Пользователь {sdb_user.telegram_id} отменил ввод обратной связи.")
    await message.reply("Ввод обратной связи отменен.")
    await show_main_menu_reply(message, bot, services_provider, sdb_user, text_override="Главное меню:", state=state)


@core_ui_router.message(F.text == TEXTS_CORE_KEYBOARDS_EN["main_menu_reply_admin_panel"], StateFilter(None))
async def handle_text_admin_panel(message: types.Message, bot:Bot, services_provider: 'BotServicesProvider', sdb_user: DBUser, state: FSMContext): 
    logger.info(f"Пользователь {sdb_user.telegram_id} нажал reply-кнопку 'Админ-панель'")
    await state.clear() 
    from core.admin.entry.handlers_entry import send_admin_main_menu 
    await send_admin_main_menu(message, services_provider) 


@core_ui_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "main_reply"))
async def cq_nav_to_main_menu_reply(
    query: types.CallbackQuery, 
    bot: Bot, 
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser,
    state: FSMContext 
):
    await show_main_menu_reply(query, bot, services_provider, sdb_user, state=state) 


async def send_modules_list_message(
    chat_id: int, 
    bot: Bot, 
    services_provider: 'BotServicesProvider', 
    sdb_user: DBUser, 
    page: int = 1,
    message_to_edit: Optional[types.Message] = None 
):
    user_id = sdb_user.telegram_id
    texts = TEXTS_CORE_KEYBOARDS_EN
    items_per_page = 5
    keyboard = await get_modules_list_keyboard(services_provider, user_id, page, items_per_page)
    
    num_module_buttons = 0; total_accessible_items = 0
    if keyboard.inline_keyboard: 
        for row in keyboard.inline_keyboard:
            for button in row:
                if button.callback_data and button.callback_data.startswith(ModuleMenuEntry.__prefix__):
                    num_module_buttons +=1

    all_module_ui_entries_temp = services_provider.ui_registry.get_all_module_entries()
    if all_module_ui_entries_temp:
        async with services_provider.db.get_session() as session:
            for entry_temp in all_module_ui_entries_temp:
                if entry_temp.required_permission_to_view:
                    if await services_provider.rbac.user_has_permission(session, user_id, entry_temp.required_permission_to_view):
                        total_accessible_items +=1
                else: total_accessible_items +=1
    
    total_pages = (total_accessible_items + items_per_page - 1) // items_per_page
    total_pages = max(1, total_pages)

    if num_module_buttons == 0 and page == 1: text = texts["modules_list_no_modules"]
    else: text = texts["modules_list_title_template"].format(current_page=page, total_pages=total_pages)
    
    if message_to_edit: 
        try:
            if message_to_edit.text != text or message_to_edit.reply_markup != keyboard:
                await message_to_edit.edit_text(text, reply_markup=keyboard)
            return 
        except TelegramBadRequest as e:
            if "message is not modified" not in str(e).lower():
                logger.warning(f"Не удалось edit modules list (inline pagination): {e}")
            return
        except Exception as e:
            logger.error(f"Ошибка в send_modules_list_message (edit): {e}", exc_info=True)
            return
    
    await bot.send_message(chat_id, text, reply_markup=keyboard)


async def send_profile_message(
    chat_id: int, 
    bot: Bot, 
    services_provider: 'BotServicesProvider', 
    sdb_user: DBUser,
    message_to_edit: Optional[types.Message] = None
):
    texts = TEXTS_CORE_KEYBOARDS_EN
    reg_date_str = sdb_user.created_at.strftime('%d.%m.%Y %H:%M') if sdb_user.created_at else texts["profile_no_reg_date"]
    username_str = f"@{sdb_user.username}" if sdb_user.username else texts["profile_no_username"] 
    current_lang = sdb_user.preferred_language_code or services_provider.config.core.i18n.default_locale
    lang_display_name = current_lang.upper()

    profile_text = texts["profile_info_template"].format(
        user_id=hcode(str(sdb_user.telegram_id)),
        full_name=hbold(sdb_user.full_name),
        username=username_str,
        registration_date=reg_date_str,
        current_language=lang_display_name
    )
    final_text = f"{hbold(texts['profile_title'])}\n\n{profile_text}"
    keyboard = await get_profile_menu_keyboard(sdb_user, services_provider)
    
    if message_to_edit:
        try:
            if message_to_edit.text != final_text or message_to_edit.reply_markup != keyboard:
                await message_to_edit.edit_text(final_text, reply_markup=keyboard)
            return
        except TelegramBadRequest as e:
            if "message is not modified" not in str(e).lower():
                logger.warning(f"Не удалось edit profile (inline nav): {e}")
            return
        except Exception as e:
            logger.error(f"Ошибка в send_profile_message (edit): {e}", exc_info=True)
            return
            
    await bot.send_message(chat_id, final_text, reply_markup=keyboard)


@core_ui_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "modules_list"))
async def cq_nav_to_modules_list(
    query: types.CallbackQuery, 
    callback_data: CoreMenuNavigate, 
    bot: Bot, 
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser
):
    user_id = sdb_user.telegram_id
    page = callback_data.page if callback_data.page is not None else 1
    logger.debug(f"[{MODULE_NAME_FOR_LOG}] User {user_id} requested modules list (inline nav), page: {page}")
    
    if query.message:
        await send_modules_list_message(query.message.chat.id, bot, services_provider, sdb_user, page, message_to_edit=query.message)
    await query.answer()


@core_ui_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "profile"))
async def cq_nav_to_profile( 
    query: types.CallbackQuery, 
    bot: Bot, 
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser 
):
    if query.message:
        await send_profile_message(query.message.chat.id, bot, services_provider, sdb_user, message_to_edit=query.message)
    await query.answer()


@core_ui_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "profile_change_lang_list"))
async def cq_profile_show_language_list(
    query: types.CallbackQuery,
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser
):
    user_id = sdb_user.telegram_id
    logger.debug(f"[{MODULE_NAME_FOR_LOG}] User {user_id} requested language selection list.")
    
    texts = TEXTS_CORE_KEYBOARDS_EN
    i18n_settings = services_provider.config.core.i18n
    
    current_lang = sdb_user.preferred_language_code or i18n_settings.default_locale
    available_langs = i18n_settings.available_locales
    
    text = texts.get("profile_select_language_title", "Выберите язык:")
    keyboard = await get_language_selection_keyboard(current_lang, available_langs)
    
    if query.message:
        try:
            if query.message.text != text or query.message.reply_markup != keyboard: 
                await query.message.edit_text(text, reply_markup=keyboard)
            await query.answer()
        except TelegramBadRequest as e:
            if "message is not modified" not in str(e).lower():
                 logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка edit_text в cq_profile_show_language_list: {e}")
            await query.answer() 
        except Exception as e:
            logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка в cq_profile_show_language_list: {e}", exc_info=True)
            await query.answer("Ошибка отображения.")

@core_ui_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "profile_set_lang"))
async def cq_profile_set_language(
    query: types.CallbackQuery,
    callback_data: CoreMenuNavigate,
    bot: Bot, 
    services_provider: 'BotServicesProvider',
    sdb_user: DBUser,
    translator: Translator 
):
    new_lang_code = callback_data.payload
    user_id = sdb_user.telegram_id
    
    if not new_lang_code or new_lang_code not in services_provider.config.core.i18n.available_locales:
        logger.warning(f"[{MODULE_NAME_FOR_LOG}] User {user_id} попытался установить некорректный язык: {new_lang_code}")
        await query.answer("Выбран некорректный язык.", show_alert=True)
        if query.message: 
            await send_profile_message(query.message.chat.id, bot, services_provider, sdb_user, message_to_edit=query.message)
        return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] User {user_id} устанавливает язык: {new_lang_code}")
    
    user_service = services_provider.user_service 
    async with services_provider.db.get_session() as session: 
        user_in_session = await session.get(DBUser, sdb_user.id) 
        if user_in_session:
            if await user_service.update_user_language(user_in_session, new_lang_code, session):
                try:
                    await session.commit()
                    sdb_user.preferred_language_code = new_lang_code 
                    
                    logger.success(f"[{MODULE_NAME_FOR_LOG}] Язык для пользователя {user_id} успешно изменен на {new_lang_code} в БД.")
                    await query.answer(f"Language changed to {new_lang_code.upper()}", show_alert=False)
                except Exception as e_commit:
                    await session.rollback()
                    logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка commit при смене языка для {user_id}: {e_commit}", exc_info=True)
                    await query.answer("Ошибка сохранения языка.", show_alert=True)
            else:
                await query.answer(f"Язык уже установлен на {new_lang_code.upper()}.", show_alert=False)
        else: 
            await query.answer("Ошибка: пользователь не найден для обновления языка.", show_alert=True)
            
    if query.message:
        await send_profile_message(query.message.chat.id, bot, services_provider, sdb_user, message_to_edit=query.message)
    

@core_ui_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "feedback_fsm_start"))
async def cq_nav_to_feedback_fsm_start( 
    query: types.CallbackQuery, 
    bot: Bot, 
    services_provider: 'BotServicesProvider', 
    sdb_user: DBUser, 
    state: FSMContext
):
    user_id = query.from_user.id
    logger.debug(f"[{MODULE_NAME_FOR_LOG}] User {user_id} запросил обратную связь (FSM через callback).")
    text = (
        "✍️ Пожалуйста, напишите ваше сообщение для обратной связи.\n"
        f"{hitalic('Для отмены введите /cancel_feedback')}"
    )
    await state.set_state(FSMFeedback.waiting_for_feedback_message)
    
    if query.message:
        try: 
            await query.message.edit_text(text, reply_markup=None) 
        except TelegramBadRequest as e:
             if "message is not modified" not in str(e).lower():
                logger.warning(f"Не удалось отредактировать сообщение перед вводом feedback (callback): {e}")
                await bot.send_message(user_id, text) 
        except Exception as e_edit_fb:
            logger.warning(f"Не удалось отредактировать сообщение перед вводом feedback (callback): {e_edit_fb}")
            await bot.send_message(user_id, text)
    else: 
        await bot.send_message(user_id, text)
    await query.answer()


@core_ui_router.callback_query(CoreServiceAction.filter(F.action == "delete_this_message"))
async def cq_service_action_delete_message(query: types.CallbackQuery, bot: Bot):
    user_id = query.from_user.id
    message_id = query.message.message_id if query.message else "N/A"
    logger.debug(f"[{MODULE_NAME_FOR_LOG}] User {user_id} requested to delete message_id: {message_id}")
    
    try:
        if query.message:
            await bot.delete_message(chat_id=query.message.chat.id, message_id=query.message.message_id)
            await query.answer("Сообщение удалено.") 
        else:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Не найдено сообщение для удаления по запросу от user {user_id}.")
            await query.answer("Не найдено сообщение для удаления.")
    except TelegramBadRequest as e: 
        logger.warning(f"[{MODULE_NAME_FOR_LOG}] Не удалось удалить сообщение {message_id} для user {user_id}: {e} (возможно, уже удалено или нет прав).")
        await query.answer() 
    except Exception as e:
        logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка при удалении сообщения {message_id} для user {user_id}: {e}", exc_info=True)
        await query.answer("Ошибка при удалении сообщения.", show_alert=True)


======================================================================

------------------------------ FILE: core/ui/keyboards_core.py ------------------------------
# SwiftDevBot/core/ui/keyboards_core.py

from typing import List, Dict, Optional, TYPE_CHECKING
# Используем нужные типы для Reply клавиатур
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton 
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder # Добавляем ReplyKeyboardBuilder
from loguru import logger 

from .callback_data_factories import CoreMenuNavigate, ModuleMenuEntry, CoreServiceAction
from core.rbac.service import PERMISSION_CORE_VIEW_ADMIN_PANEL 
from core.database.core_models import User as DBUser

if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from core.ui.registry_ui import ModuleUIEntry
    from sqlalchemy.ext.asyncio import AsyncSession 

# Обновляем тексты для кнопок, чтобы они были командами или уникальными фразами
TEXTS_CORE_KEYBOARDS_EN = {
    # Для Reply Keyboard (главное меню)
    "main_menu_reply_modules": "🗂 Модули", # Текст, который будет отправлен как сообщение
    "main_menu_reply_profile": "👤 Профиль",
    "main_menu_reply_feedback": "✍️ Обратная связь",
    "main_menu_reply_admin_panel": "🛠 Админ-панель",

    # Для Inline Keyboard (остальные меню)
    "main_menu_inline_modules": "🗂 Modules", # Оставим старые для инлайн, если понадобятся
    "main_menu_inline_profile": "👤 Profile",
    "main_menu_inline_feedback": "✍️ Feedback",
    "main_menu_inline_admin_panel": "🛠 Admin Panel",

    "modules_list_no_modules": "🤷 No modules available",
    "modules_list_title_template": "Available Modules (Page {current_page}/{total_pages}):",
    "pagination_prev": "⬅️ Prev",
    "pagination_next": "Next ➡️",
    "navigation_back_to_main": "🏠 Main Menu", # Может быть и для инлайн, и для reply (как /start)
    "service_delete_message": "❌ Close this menu",
    "confirm_yes": "✅ Yes",
    "confirm_no": "❌ No",
    "welcome_message_title": "🎉 Добро пожаловать в SwiftDevBot!",
    "welcome_message_body": (
        "Я — ваш модульный Telegram-помощник, созданный для расширения функциональности и автоматизации задач.\n\n"
        "🔍 **Что я могу?**\n"
        "Мои возможности зависят от подключенных модулей. Это могут быть инструменты для разработки, утилиты, информационные сервисы и многое другое.\n\n"
        "🔒 **Конфиденциальность:**\n"
        "Я обрабатываю только те данные, которые необходимы для моей работы и работы активных модулей. "
        "Мы ценим вашу приватность. Для получения более подробной информации вы всегда можете обратиться к администратору бота.\n\n"
        "Нажимая «Продолжить», вы соглашаетесь с тем, что бот будет обрабатывать ваши сообщения для предоставления своих функций."
    ),
    "welcome_button_continue": "✅ Продолжить",
    "welcome_button_cancel": "❌ Отмена",
    "registration_cancelled_message": "Очень жаль, что вы передумали. Если надумаете снова, просто напишите /start.",
    "user_middleware_please_register": (
        "👋 Похоже, вы еще не знакомы со мной! "
        "Чтобы начать, пожалуйста, нажмите /start или введите команду /start."
    ),
    "profile_title": "👤 Ваш профиль",
    "profile_info_template": (
        "🆔 Ваш Telegram ID: {user_id}\n"
        "📝 Имя: {full_name}\n"
        "👤 Username: @{username}\n"
        "📅 Дата регистрации: {registration_date}\n"
        "🗣 Язык интерфейса: {current_language}"
    ),
    "profile_no_username": "не указан",
    "profile_no_reg_date": "неизвестно",
    "profile_button_change_language": "🌐 Сменить язык", # Это будет инлайн кнопка в профиле
    "profile_select_language_title": "Выберите язык интерфейса:",
}

# --- НОВАЯ ФУНКЦИЯ ДЛЯ REPLY KEYBOARD ГЛАВНОГО МЕНЮ ---
async def get_main_menu_reply_keyboard( 
    services_provider: 'BotServicesProvider', 
    user_telegram_id: int
) -> ReplyKeyboardMarkup:
    builder = ReplyKeyboardBuilder() # Используем ReplyKeyboardBuilder
    texts = TEXTS_CORE_KEYBOARDS_EN 
    
    builder.button(text=texts["main_menu_reply_modules"])
    builder.button(text=texts["main_menu_reply_profile"])
    
    show_admin_button = False
    if user_telegram_id in services_provider.config.core.super_admins:
        show_admin_button = True
    else:
        try:
            async with services_provider.db.get_session() as session: 
                if await services_provider.rbac.user_has_permission(session, user_telegram_id, PERMISSION_CORE_VIEW_ADMIN_PANEL):
                    show_admin_button = True
        except Exception as e: 
            logger.error(f"[MainMenuReplyKeyboard] Ошибка проверки разрешения '{PERMISSION_CORE_VIEW_ADMIN_PANEL}' для {user_telegram_id}: {e}")
            
    if show_admin_button:
        builder.button(text=texts["main_menu_reply_admin_panel"])
        
    builder.button(text=texts["main_menu_reply_feedback"])
    
    # Расположим кнопки, например, по 2 в ряд
    builder.adjust(2, 2) # Первые два ряда по 2 кнопки
    
    return builder.as_markup(
        resize_keyboard=True, 
        # one_time_keyboard=True # Если хотите, чтобы клавиатура скрывалась после нажатия
        input_field_placeholder="Выберите действие из меню..." # Подсказка в поле ввода
    )

# Старая функция для инлайн-клавиатуры главного меню (может пригодиться для других случаев или если захотите вернуть)
async def get_main_menu_inline_keyboard( # Переименовал для ясности
    services_provider: 'BotServicesProvider', 
    user_telegram_id: int
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = TEXTS_CORE_KEYBOARDS_EN 
    
    builder.button(
        text=texts["main_menu_inline_modules"], # Используем тексты для инлайн
        callback_data=CoreMenuNavigate(target_menu="modules_list", page=1).pack()
    )
    builder.button(
        text=texts["main_menu_inline_profile"],
        callback_data=CoreMenuNavigate(target_menu="profile").pack()
    )
    # ... (логика кнопки админки как была) ...
    show_admin_button = False
    if user_telegram_id in services_provider.config.core.super_admins:
        show_admin_button = True
    else:
        try:
            async with services_provider.db.get_session() as session: 
                if await services_provider.rbac.user_has_permission(session, user_telegram_id, PERMISSION_CORE_VIEW_ADMIN_PANEL):
                    show_admin_button = True
        except Exception: pass # Логирование уже есть в get_main_menu_reply_keyboard
            
    if show_admin_button:
        builder.button(
            text=texts["main_menu_inline_admin_panel"],
            callback_data=CoreMenuNavigate(target_menu="admin_panel_main").pack()
        )
    builder.button(
        text=texts["main_menu_inline_feedback"],
        callback_data=CoreMenuNavigate(target_menu="feedback").pack()
    )
    builder.adjust(2) 
    return builder.as_markup()


async def get_modules_list_keyboard( # Остается инлайн
    # ... (без изменений) ...
    services_provider: 'BotServicesProvider',
    user_telegram_id: int, 
    current_page: int = 1,
    items_per_page: int = 5
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = TEXTS_CORE_KEYBOARDS_EN
    
    all_module_ui_entries: List['ModuleUIEntry'] = services_provider.ui_registry.get_all_module_entries()
    
    accessible_module_entries: List['ModuleUIEntry'] = []
    if all_module_ui_entries:
        async with services_provider.db.get_session() as session: 
            for entry in all_module_ui_entries:
                if entry.required_permission_to_view:
                    if await services_provider.rbac.user_has_permission(session, user_telegram_id, entry.required_permission_to_view):
                        accessible_module_entries.append(entry)
                else:
                    accessible_module_entries.append(entry)

    if not accessible_module_entries:
        builder.button(
            text=texts["modules_list_no_modules"],
            callback_data="core:dummy_no_modules"
        )
    else:
        # ... (логика пагинации и кнопок модулей без изменений) ...
        total_items = len(accessible_module_entries)
        total_pages = (total_items + items_per_page - 1) // items_per_page
        current_page = max(1, min(current_page, total_pages if total_pages > 0 else 1))

        start_index = (current_page - 1) * items_per_page
        end_index = start_index + items_per_page
        paginated_entries = accessible_module_entries[start_index:end_index]

        for entry in paginated_entries:
            button_text = f"{entry.icon} {entry.display_name}" if entry.icon else entry.display_name
            builder.button(
                text=button_text,
                callback_data=entry.entry_callback_data
            )
        builder.adjust(1)

        if total_pages > 1:
            pagination_buttons_row: List[InlineKeyboardButton] = []
            if current_page > 1:
                pagination_buttons_row.append(InlineKeyboardButton(text=texts["pagination_prev"], callback_data=CoreMenuNavigate(target_menu="modules_list", page=current_page - 1).pack()))
            pagination_buttons_row.append(InlineKeyboardButton(text=f"{current_page}/{total_pages}", callback_data="core:dummy_page_indicator"))
            if current_page < total_pages:
                pagination_buttons_row.append(InlineKeyboardButton(text=texts["pagination_next"], callback_data=CoreMenuNavigate(target_menu="modules_list", page=current_page + 1).pack()))
            if pagination_buttons_row:
                 builder.row(*pagination_buttons_row)
    builder.row(
        InlineKeyboardButton(
            text=texts["navigation_back_to_main"], 
            callback_data=CoreMenuNavigate(target_menu="main_reply").pack() # <--- ИЗМЕНЕНО: возврат к reply-меню
        )
    )
    return builder.as_markup()


def get_welcome_confirmation_keyboard() -> InlineKeyboardMarkup: # Остается инлайн
    # ... (без изменений) ...
    builder = InlineKeyboardBuilder()
    texts = TEXTS_CORE_KEYBOARDS_EN
    builder.button(
        text=texts["welcome_button_continue"],
        callback_data=CoreServiceAction(action="confirm_registration").pack()
    )
    builder.button(
        text=texts["welcome_button_cancel"],
        callback_data=CoreServiceAction(action="cancel_registration").pack()
    )
    builder.adjust(2)
    return builder.as_markup()

async def get_profile_menu_keyboard( # Остается инлайн
    # ... (без изменений) ...
    db_user: DBUser, 
    services_provider: 'BotServicesProvider'
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = TEXTS_CORE_KEYBOARDS_EN
    available_langs = services_provider.config.core.i18n.available_locales
    if len(available_langs) > 1:
        builder.button(
            text=texts["profile_button_change_language"],
            callback_data=CoreMenuNavigate(target_menu="profile_change_lang_list").pack()
        )
    if not builder.export():
        builder.button(text="Нет доступных действий в профиле", callback_data="core_profile:dummy_no_actions")
    builder.row(
        InlineKeyboardButton(
            text=texts["navigation_back_to_main"],
            callback_data=CoreMenuNavigate(target_menu="main_reply").pack() # <--- ИЗМЕНЕНО: возврат к reply-меню
        )
    )
    builder.adjust(1)
    return builder.as_markup()

async def get_language_selection_keyboard( # Остается инлайн
    # ... (без изменений) ...
    current_lang_code: Optional[str],
    available_locales: List[str], 
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    for lang_code in available_locales:
        prefix = "✅ " if lang_code == current_lang_code else "▫️ "
        display_name = lang_code.upper() 
        builder.button(
            text=f"{prefix}{display_name}",
            callback_data=CoreMenuNavigate(target_menu="profile_set_lang", payload=lang_code).pack()
        )
    builder.adjust(1) 
    builder.row(
        InlineKeyboardButton(
            text="⬅️ Назад в профиль", 
            callback_data=CoreMenuNavigate(target_menu="profile").pack()
        )
    )
    return builder.as_markup()

# ... (get_confirm_action_keyboard, get_close_button_keyboard без изменений, т.к. они инлайн)
def get_confirm_action_keyboard(
    confirm_callback_data: str,
    cancel_callback_data: str,
    confirm_text_key: str = "confirm_yes",
    cancel_text_key: str = "confirm_no"
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = TEXTS_CORE_KEYBOARDS_EN
    
    builder.button(text=texts[confirm_text_key], callback_data=confirm_callback_data)
    builder.button(text=texts[cancel_text_key], callback_data=cancel_callback_data)
    builder.adjust(2)
    return builder.as_markup()

def get_close_button_keyboard(
    close_text_key: str = "service_delete_message"
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = TEXTS_CORE_KEYBOARDS_EN
    builder.button(
        text=texts[close_text_key],
        callback_data=CoreServiceAction(action="delete_this_message").pack()
    )
    return builder.as_markup()


======================================================================

------------------------------ FILE: core/ui/navigation_core.py ------------------------------
# core/ui/navigation_core.py

from aiogram import Router, F, types, Bot
from aiogram.exceptions import TelegramBadRequest
from aiogram.utils.markdown import hbold, hitalic
from loguru import logger

from .callback_data_factories import CoreMenuNavigate, ModuleMenuEntry, CoreServiceAction
from .keyboards_core import (
    get_main_menu_keyboard, 
    get_modules_list_keyboard,
    # get_close_button_keyboard, # Если будет использоваться явно
    TEXTS_CORE_KEYBOARDS_EN 
)

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider

core_navigation_router = Router(name="sdb_core_ui_navigation_handlers")

@core_navigation_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "main"))
async def cq_nav_to_main_menu(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider' 
):
    user_id = query.from_user.id
    user_full_name = query.from_user.full_name
    logger.debug(f"User {user_id} ({user_full_name}) navigating to main menu.")
    
    texts = TEXTS_CORE_KEYBOARDS_EN
    text = f"🏠 {hbold('Главное меню SwiftDevBot')}\nПривет, {hbold(user_full_name)}! Выберите действие:"
    
    keyboard = await get_main_menu_keyboard(services_provider=services_provider, user_telegram_id=user_id)
    
    try:
        if query.message:
            if query.message.text != text or query.message.reply_markup != keyboard:
                await query.message.edit_text(text, reply_markup=keyboard)
            else:
                logger.trace("Сообщение главного меню не было изменено (текст и клавиатура совпадают).")
        await query.answer()
    except TelegramBadRequest as e:
        if "message is not modified" in str(e).lower():
            logger.trace("Сообщение главного меню не было изменено (поймано исключение).")
            await query.answer()
        else:
            logger.warning(f"Не удалось отредактировать сообщение для главного меню (user: {user_id}): {e}")
            await query.answer("Ошибка отображения меню.", show_alert=True)
    except Exception as e:
        logger.error(f"Непредвиденная ошибка при показе главного меню (user: {user_id}): {e}", exc_info=True)
        await query.answer("Произошла серьезная ошибка.", show_alert=True)


@core_navigation_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "modules_list"))
async def cq_nav_to_modules_list(
    query: types.CallbackQuery, 
    callback_data: CoreMenuNavigate, 
    services_provider: 'BotServicesProvider' 
):
    user_id = query.from_user.id
    page = callback_data.page if callback_data.page is not None else 1
    logger.debug(f"User {user_id} requested modules list, page: {page}")

    texts = TEXTS_CORE_KEYBOARDS_EN
    
    module_ui_entries = services_provider.ui_registry.get_all_module_entries()
    items_per_page = 5 
    total_pages = (len(module_ui_entries) + items_per_page - 1) // items_per_page
    total_pages = max(1, total_pages) 

    text = texts["modules_list_title_template"].format(current_page=page, total_pages=total_pages)
    
    keyboard = await get_modules_list_keyboard(
        services_provider=services_provider, 
        user_telegram_id=user_id, 
        current_page=page,
        items_per_page=items_per_page
    )
    
    try:
        if query.message:
            if query.message.text != text or query.message.reply_markup != keyboard:
                await query.message.edit_text(text, reply_markup=keyboard)
            else:
                logger.trace("Сообщение списка модулей не было изменено.")
        await query.answer()
    except TelegramBadRequest as e:
        if "message is not modified" in str(e).lower():
            logger.trace("Сообщение списка модулей не было изменено (поймано исключение).")
            await query.answer()
        else:
            logger.warning(f"Не удалось отредактировать сообщение для списка модулей (user: {user_id}): {e}")
            await query.answer("Ошибка отображения списка.", show_alert=True)
    except Exception as e:
        logger.error(f"Непредвиденная ошибка при показе списка модулей (user: {user_id}): {e}", exc_info=True)
        await query.answer("Произошла серьезная ошибка.", show_alert=True)

@core_navigation_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "profile"))
async def cq_nav_to_profile(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider' 
):
    user_id = query.from_user.id
    logger.debug(f"User {user_id} requested profile menu (WIP).")
    text = "👤 Раздел 'Профиль' находится в разработке."
    keyboard = await get_main_menu_keyboard(services_provider=services_provider, user_telegram_id=user_id) 
    if query.message:
        
        try:
            if query.message.text != text or query.message.reply_markup != keyboard:
                await query.message.edit_text(text, reply_markup=keyboard)
        except TelegramBadRequest as e:
            if "message is not modified" not in str(e).lower():
                logger.warning(f"Ошибка edit_text в cq_nav_to_profile: {e}")
    await query.answer("Раздел в разработке.")

@core_navigation_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "feedback"))
async def cq_nav_to_feedback(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider' 
):
    user_id = query.from_user.id
    logger.debug(f"User {user_id} requested feedback menu (WIP).")
    text = "✍️ Раздел 'Обратная связь' находится в разработке."
    keyboard = await get_main_menu_keyboard(services_provider=services_provider, user_telegram_id=user_id) 
    if query.message:
        try:
            if query.message.text != text or query.message.reply_markup != keyboard:
                await query.message.edit_text(text, reply_markup=keyboard)
        except TelegramBadRequest as e:
            if "message is not modified" not in str(e).lower():
                logger.warning(f"Ошибка edit_text в cq_nav_to_feedback: {e}")
    await query.answer("Раздел в разработке.")

# Удален обработчик cq_nav_to_admin_panel, так как он конфликтовал
# с рабочим обработчиком в core/admin/handlers_admin_entry.py

@core_navigation_router.callback_query(CoreServiceAction.filter(F.action == "delete_this_message"))
async def cq_service_action_delete_message(query: types.CallbackQuery, bot: Bot):
    user_id = query.from_user.id
    message_id = query.message.message_id if query.message else "N/A"
    logger.debug(f"User {user_id} requested to delete message_id: {message_id}")
    
    try:
        if query.message:
            await bot.delete_message(chat_id=query.message.chat.id, message_id=query.message.message_id)
            await query.answer("Сообщение удалено.") 
        else:
            logger.warning(f"Не найдено сообщение для удаления по запросу от user {user_id}.")
            await query.answer("Не найдено сообщение для удаления.")
    except TelegramBadRequest as e:
        logger.warning(f"Не удалось удалить сообщение {message_id} для user {user_id}: {e}")
        await query.answer()
    except Exception as e:
        logger.error(f"Ошибка при удалении сообщения {message_id} для user {user_id}: {e}", exc_info=True)
        await query.answer("Ошибка при удалении сообщения.", show_alert=True)


======================================================================

------------------------------ FILE: core/ui/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/ui/callback_data_factories.py ------------------------------
# SwiftDevBot/core/ui/callback_data_factories.py
from typing import Optional, Literal, Union 
from aiogram.filters.callback_data import CallbackData

CORE_CALLBACK_PREFIX = "sdb_core"
ADMIN_CALLBACK_PREFIX = "sdb_admin" 

# --- Фабрики для навигации ядра ---
class CoreMenuNavigate(CallbackData, prefix=f"{CORE_CALLBACK_PREFIX}_nav"):
    target_menu: str 
    page: Optional[int] = None
    action: Optional[str] = None 
    # Добавим параметр для передачи данных, например, кода языка
    payload: Optional[str] = None 

class ModuleMenuEntry(CallbackData, prefix=f"{CORE_CALLBACK_PREFIX}_module_entry"):
    module_name: str

class CoreServiceAction(CallbackData, prefix=f"{CORE_CALLBACK_PREFIX}_service"):
    action: Literal[
        "delete_this_message", 
        "close_menu_silently",
        "confirm_registration", 
        "cancel_registration",
    ]

# --- Фабрики для Админ-панели ---
# ... (без изменений) ...
ADMIN_MAIN_MENU_PREFIX = "sdb_admin_main"
class AdminMainMenuNavigate(CallbackData, prefix=ADMIN_MAIN_MENU_PREFIX):
    target_section: str 

ADMIN_USERS_PREFIX = "sdb_admin_users"
class AdminUsersPanelNavigate(CallbackData, prefix=ADMIN_USERS_PREFIX):
    action: str 
    item_id: Optional[int] = None       
    page: Optional[int] = None          
    role_id: Optional[int] = None       
    permission_id: Optional[int] = None 
    
    category_key: Optional[str] = None 
    entity_name: Optional[str] = None  


ADMIN_ROLES_PREFIX = "sdb_admin_roles"
class AdminRolesPanelNavigate(CallbackData, prefix=ADMIN_ROLES_PREFIX):
    action: str 
    item_id: Optional[int] = None       
    permission_id: Optional[int] = None 
    category_key: Optional[str] = None  
    entity_name: Optional[str] = None   
    page: Optional[int] = None          

ADMIN_SYSINFO_PREFIX = "sdb_admin_sysinfo"
class AdminSysInfoPanelNavigate(CallbackData, prefix=ADMIN_SYSINFO_PREFIX):
    action: str 

ADMIN_MODULES_PREFIX = "sdb_admin_modules"
class AdminModulesPanelNavigate(CallbackData, prefix=ADMIN_MODULES_PREFIX):
    action: str 
    item_id: Optional[str] = None 
    page: Optional[int] = None

ADMIN_LOGS_PREFIX = "sdb_admin_logs"
class AdminLogsPanelNavigate(CallbackData, prefix=ADMIN_LOGS_PREFIX):
    action: str 
    item_id: Optional[str] = None 
    page: Optional[int] = None

class AdminPanelNavigate(CallbackData, prefix=ADMIN_CALLBACK_PREFIX): 
    section: str 
    action: Optional[str] = None
    item_id: Optional[Union[int, str]] = None 
    page: Optional[int] = None
    role_id: Optional[int] = None 
    permission_name: Optional[str] = None


======================================================================

------------------------------ FILE: core/users/middleware.py ------------------------------
# SwiftDevBot/core/users/middleware.py
from typing import Callable, Dict, Any, Awaitable, Optional
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, User as AiogramUser, Update 
from loguru import logger
from datetime import datetime, timezone 

from core.database.core_models import User as DBUser
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from core.ui.keyboards_core import TEXTS_CORE_KEYBOARDS_EN


from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from core.users.service import UserService 

MODULE_NAME_FOR_LOG = "UserStatusMiddleware"

class UserStatusMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: Update, 
        data: Dict[str, Any]
    ) -> Any:
        
        aiogram_event_user: Optional[AiogramUser] = data.get("event_from_user")
        if not aiogram_event_user:
            return await handler(event, data)

        user_tg_id = aiogram_event_user.id
        user_mention = f"@{aiogram_event_user.username}" if aiogram_event_user.username else f"ID:{user_tg_id}"
        
        services_provider: Optional['BotServicesProvider'] = data.get("services_provider")
        if not (services_provider and hasattr(services_provider, 'db') and hasattr(services_provider, 'user_service')):
            logger.critical(f"[{MODULE_NAME_FOR_LOG}] Необходимые сервисы (DBManager, UserService) не инициализированы "
                           f"или отсутствуют в data. Проверка/создание пользователя {user_mention} невозможно. Прерывание.")
            if event.message: await event.message.reply("Ошибка конфигурации сервисов бота. Пожалуйста, сообщите администратору.")
            elif event.callback_query: await event.callback_query.answer("Ошибка конфигурации сервисов.", show_alert=True)
            return None

        db_user: Optional[DBUser] = None
        user_service: 'UserService' = services_provider.user_service
        user_was_created_in_this_middleware_call = False # Флаг для этого вызова middleware

        try:
            async with services_provider.db.get_session() as session:
                stmt = select(DBUser).where(DBUser.telegram_id == user_tg_id)
                result = await session.execute(stmt)
                db_user = result.scalars().first()
        except Exception as e_get_user:
            logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка БД при первоначальном получении пользователя {user_mention}: {e_get_user}", exc_info=True)
            if event.message: await event.message.reply("Внутренняя ошибка сервера. Попробуйте позже.")
            elif event.callback_query: await event.callback_query.answer("Внутренняя ошибка сервера.", show_alert=True)
            return None

        is_owner_from_config = user_tg_id in services_provider.config.core.super_admins
        is_start_command = event.message and event.message.text and event.message.text.startswith("/start")

        if not db_user: 
            if is_start_command or is_owner_from_config:
                logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} не найден в БД. "
                            f"Это {'/start' if is_start_command else 'Владелец ('+str(user_tg_id)+')'}. "
                            f"Вызов UserService.process_user_on_start для создания/обновления...")
                try:
                    processed_user, created_flag = await user_service.process_user_on_start(aiogram_event_user)
                    db_user = processed_user
                    if created_flag: # Если UserService его ТОЛЬКО ЧТО СОЗДАЛ
                        user_was_created_in_this_middleware_call = True
                    
                    if not db_user:
                        # ... (обработка ошибки process_user_on_start)
                        logger.error(f"[{MODULE_NAME_FOR_LOG}] UserService.process_user_on_start не смог создать/обработать пользователя {user_mention} в middleware. Прерывание.")
                        if event.message: await event.message.reply("Ошибка регистрации профиля. Попробуйте /start еще раз или свяжитесь с администратором.")
                        elif event.callback_query: await event.callback_query.answer("Ошибка регистрации профиля.", show_alert=True)
                        return None
                    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} (DB ID: {db_user.id}) успешно создан/обработан UserService в middleware. Был создан сейчас: {user_was_created_in_this_middleware_call}")
                except Exception as e_create_mw:
                    # ... (обработка исключения e_create_mw)
                    logger.error(f"[{MODULE_NAME_FOR_LOG}] Исключение при вызове process_user_on_start из middleware для {user_mention}: {e_create_mw}", exc_info=True)
                    if event.message: await event.message.reply("Критическая ошибка при обработке вашего профиля.")
                    elif event.callback_query: await event.callback_query.answer("Критическая ошибка профиля.", show_alert=True)
                    return None
            else: 
                logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} не найден в БД и это не /start/владелец. Отправка призыва к регистрации.")
                please_register_text = TEXTS_CORE_KEYBOARDS_EN.get("user_middleware_please_register", "Пожалуйста, используйте /start для начала работы с ботом.")
                # ... (отправка сообщения и return None)
                if event.message:
                    try: await event.message.reply(please_register_text)
                    except Exception as e_reply: logger.error(f"Не удалось отправить сообщение о регистр. {user_mention}: {e_reply}")
                elif event.callback_query:
                    try: await event.callback_query.answer(please_register_text, show_alert=True)
                    except Exception as e_answer: logger.error(f"Не удалось ответить на callback о регистр. {user_mention}: {e_answer}")
                return None 
        elif not is_start_command: 
            logger.trace(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} найден. Вызов process_user_on_start для обновления...")
            try:
                processed_user, _ = await user_service.process_user_on_start(aiogram_event_user) # Флаг created здесь не так важен
                if processed_user:
                    db_user = processed_user 
                else: 
                    logger.warning(f"[{MODULE_NAME_FOR_LOG}] process_user_on_start вернул None для существующего пользователя {user_mention} в middleware.")
            except Exception as e_update_mw:
                 logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка при обновлении данных существующего пользователя {user_mention} в middleware: {e_update_mw}", exc_info=True)
        
        if not db_user:
            logger.critical(f"[{MODULE_NAME_FOR_LOG}] db_user отсутствует после всех попыток получения/создания для {user_mention}. Прерывание.")
            return None

        # Проверки is_active и is_bot_blocked (без изменений)
        if not db_user.is_active:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} (DB ID: {db_user.id}) неактивен. Доступ запрещен.")
            # ... (отправка сообщения и return None)
            return None 

        if db_user.is_bot_blocked:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} (DB ID: {db_user.id}) заблокирован в системе. Доступ запрещен.")
            # ... (отправка сообщения и return None)
            return None 
            
        logger.trace(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} (DB ID: {db_user.id}) проверки прошел. Доступ разрешен.")
        data['sdb_user'] = db_user
        # --- ПЕРЕДАЕМ ФЛАГ О СОЗДАНИИ В ХЭНДЛЕР /start ---
        if is_start_command: # Только для команды /start передаем этот флаг
            data['user_was_just_created'] = user_was_created_in_this_middleware_call
            logger.debug(f"[{MODULE_NAME_FOR_LOG}] Для /start пользователя {user_mention} установлен флаг user_was_just_created = {user_was_created_in_this_middleware_call}")

        return await handler(event, data)


======================================================================

------------------------------ FILE: core/users/__init__.py ------------------------------
# core/users/__init__.py
from .service import UserService

__all__ = ["UserService"]


======================================================================

------------------------------ FILE: core/users/service.py ------------------------------
# SwiftDevBot/core/users/service.py
from typing import TYPE_CHECKING, Optional, Tuple, List 
from aiogram import types as aiogram_types
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, orm 
from sqlalchemy.orm import attributes as orm_attributes 
from loguru import logger
from sqlalchemy.exc import IntegrityError 
from datetime import datetime, timezone 

from core.database.core_models import User as DBUser, Role as DBRole 
from core.rbac.service import DEFAULT_ROLE_USER 

if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from core.app_settings import I18nSettings 
    from core.rbac.service import RBACService 


class UserService:
    def __init__(self, services_provider: 'BotServicesProvider'):
        self._services = services_provider
        self._logger = logger.bind(service="UserService")
        self._logger.info("UserService инициализирован.")

    async def _get_user_by_telegram_id(self, telegram_id: int, session: AsyncSession, load_roles: bool = False, load_direct_perms: bool = False) -> Optional[DBUser]:
        self._logger.trace(f"Запрос пользователя из БД. TG ID: {telegram_id}, загрузка ролей: {load_roles}, прямых прав: {load_direct_perms}")
        stmt = select(DBUser).where(DBUser.telegram_id == telegram_id)
        options_to_load = []
        if load_roles:
            options_to_load.append(orm.selectinload(DBUser.roles).selectinload(DBRole.permissions))
        if load_direct_perms:
            options_to_load.append(orm.selectinload(DBUser.direct_permissions))
        
        if options_to_load:
            stmt = stmt.options(*options_to_load)
            
        result = await session.execute(stmt)
        user = result.scalars().first()
        if user:
            roles_loaded_str = "не запрошено"
            if load_roles:
                is_roles_relationship_loaded = orm_attributes.instance_state(user).has_identity and \
                                            'roles' in orm_attributes.instance_state(user).committed_state
                
                roles_loaded_str = "загружены" if is_roles_relationship_loaded and user.roles is not None else "НЕ загружены"
                if is_roles_relationship_loaded and user.roles is not None:
                     self._logger.trace(f"User roles data (count): {len(user.roles)}")
                elif not is_roles_relationship_loaded:
                    self._logger.trace(f"Атрибут 'roles' не был загружен для пользователя {telegram_id}, хотя load_roles=True.")

            self._logger.trace(f"Пользователь {telegram_id} найден в БД (DB ID: {user.id}). Роли: {roles_loaded_str}")
        else:
            self._logger.trace(f"Пользователь {telegram_id} не найден в БД.")
        return user

    async def _update_existing_user_data(
        self,
        db_user: DBUser,
        tg_user: aiogram_types.User,
        current_lang_code: str
        ) -> bool: # Возвращает True, если были значимые изменения данных (кроме last_activity_at)
        updated_fields_log: dict = {}
        data_changed_meaningfully = False # Флаг для изменений, кроме last_activity

        if db_user.username != tg_user.username:
            updated_fields_log['username'] = (db_user.username, tg_user.username)
            db_user.username = tg_user.username
            db_user.username_lower = tg_user.username.lower() if tg_user.username else None 
            data_changed_meaningfully = True
        if db_user.first_name != tg_user.first_name:
            updated_fields_log['first_name'] = (db_user.first_name, tg_user.first_name)
            db_user.first_name = tg_user.first_name
            data_changed_meaningfully = True
        if db_user.last_name != tg_user.last_name:
            updated_fields_log['last_name'] = (db_user.last_name, tg_user.last_name)
            db_user.last_name = tg_user.last_name
            data_changed_meaningfully = True
        if db_user.preferred_language_code != current_lang_code:
            updated_fields_log['preferred_language_code'] = (db_user.preferred_language_code, current_lang_code)
            db_user.preferred_language_code = current_lang_code
            data_changed_meaningfully = True
        
        is_owner_check = tg_user.id in self._services.config.core.super_admins

        if is_owner_check:
            if not db_user.is_active:
                db_user.is_active = True; data_changed_meaningfully = True
                updated_fields_log['is_active (owner override)'] = (False, True)
            if db_user.is_bot_blocked:
                db_user.is_bot_blocked = False; data_changed_meaningfully = True
                updated_fields_log['is_bot_blocked (owner override)'] = (True, False)
        else: 
            if db_user.is_bot_blocked: 
                updated_fields_log['is_bot_blocked (user active)'] = (db_user.is_bot_blocked, False)
                db_user.is_bot_blocked = False 
                data_changed_meaningfully = True
            if not db_user.is_active: 
                updated_fields_log['is_active (user active)'] = (db_user.is_active, True)
                db_user.is_active = True
                data_changed_meaningfully = True

        # Обновляем last_activity_at всегда
        db_user.last_activity_at = datetime.now(timezone.utc)
        
        if data_changed_meaningfully:
            self._logger.info(f"Данные пользователя TG ID: {tg_user.id} (DB ID: {db_user.id}) будут обновлены: {updated_fields_log}")
        
        return data_changed_meaningfully

    async def process_user_on_start(self, tg_user: aiogram_types.User) -> Tuple[Optional[DBUser], bool]:
        """
        Обрабатывает пользователя при старте или любом другом событии.
        Создает нового пользователя или обновляет существующего.
        Возвращает кортеж (DBUser, user_was_created_bool).
        """
        self._logger.info(f"UserService.process_user_on_start для TG ID: {tg_user.id} (@{tg_user.username or 'N/A'})")
        
        is_owner = tg_user.id in self._services.config.core.super_admins
        if is_owner:
            self._logger.info(f"Пользователь {tg_user.id} идентифицирован как Владелец системы.")

        user_was_created = False # Инициализируем флаг

        async with self._services.db.get_session() as session:
            try:
                db_user = await self._get_user_by_telegram_id(tg_user.id, session, load_roles=True) # Загружаем с ролями
                
                data_actually_changed_in_db = False # Флаг для реальных изменений, требующих коммита

                i18n_settings: Optional["I18nSettings"] = getattr(self._services.config.core, 'i18n', None)
                available_locales = getattr(i18n_settings, 'available_locales', ['en', 'ua']) if i18n_settings else ['en', 'ua']
                default_locale = getattr(i18n_settings, 'default_locale', 'en') if i18n_settings else 'en'
                current_lang_code = tg_user.language_code if tg_user.language_code and tg_user.language_code in available_locales else default_locale
                self._logger.trace(f"Определен язык '{current_lang_code}' для пользователя {tg_user.id}.")

                if not db_user:
                    self._logger.info(f"Пользователь TG ID: {tg_user.id} не найден. Создание нового пользователя.")
                    db_user = DBUser(
                        telegram_id=tg_user.id, username=tg_user.username,
                        username_lower=tg_user.username.lower() if tg_user.username else None,
                        first_name=tg_user.first_name, last_name=tg_user.last_name,
                        preferred_language_code=current_lang_code,
                        is_active=True, is_bot_blocked=False,
                        last_activity_at=datetime.now(timezone.utc) 
                    )
                    session.add(db_user) 
                    user_was_created = True # Устанавливаем флаг
                    data_actually_changed_in_db = True
                    self._logger.info(f"Новый пользователь TG ID: {tg_user.id} подготовлен к созданию.")
                else:
                    self._logger.info(f"Пользователь TG ID: {tg_user.id} (DB ID: {db_user.id}) найден. Обновление данных...")
                    if await self._update_existing_user_data(db_user, tg_user, current_lang_code):
                        data_actually_changed_in_db = True
                    # last_activity_at обновляется в _update_existing_user_data, и если только оно изменилось,
                    # то data_actually_changed_in_db может быть False, но сессия все равно будет dirty.
                    if db_user not in session.dirty and db_user not in session.new :
                        session.add(db_user) # Добавляем в сессию для отслеживания, если не там
                    self._logger.info(f"Данные пользователя TG ID: {tg_user.id} отслеживаются сессией (изменения: {data_actually_changed_in_db}).")
                
                # Управление ролями
                rbac_service: Optional["RBACService"] = getattr(self._services, 'rbac', None)
                if rbac_service:
                    if user_was_created: 
                        await session.flush([db_user]) # Получаем ID
                        self._logger.info(f"Новый пользователь TG ID: {tg_user.id} получил DB ID: {db_user.id} после flush.")
                        if not is_owner:
                            if await rbac_service.assign_role_to_user(session, db_user, DEFAULT_ROLE_USER):
                                data_actually_changed_in_db = True
                    elif db_user: # Существующий
                        if is_owner: # Снимаем все роли с владельца
                            if db_user.roles:
                                roles_removed_from_owner = False
                                for role_in_db in list(db_user.roles): # Копируем список для итерации
                                    if await rbac_service.remove_role_from_user(session, db_user, role_in_db.name):
                                        roles_removed_from_owner = True
                                if roles_removed_from_owner: data_actually_changed_in_db = True
                        elif not db_user.roles: # Обычный юзер без ролей - даем User
                            if await rbac_service.assign_role_to_user(session, db_user, DEFAULT_ROLE_USER):
                                data_actually_changed_in_db = True
                
                # Коммит только если были реальные изменения или сессия "грязная"
                # (обновление last_activity_at делает сессию грязной)
                if data_actually_changed_in_db or (session.new or session.dirty or session.deleted): 
                    self._logger.info(f"UserService: ПЕРЕД session.commit() для TG ID {tg_user.id}. "
                                     f"Data changed: {data_actually_changed_in_db}, Dirty: {session.dirty}, New: {session.new}")
                    await session.commit()
                    self._logger.success(f"UserService: ПОСЛЕ session.commit() для TG ID {tg_user.id}.")
                    if db_user: # Обновляем объект из БД
                        await session.refresh(db_user, attribute_names=['id', 'roles', 'direct_permissions', 'last_activity_at', 'is_active', 'is_bot_blocked'])
                        logger.debug(f"Пользователь {db_user.id} обновлен из БД после коммита в UserService.")
                else:
                    self._logger.trace(f"Нет фактических изменений в сессии для TG ID {tg_user.id} в UserService. Коммит не требуется.")
                
                return db_user, user_was_created

            except IntegrityError as ie: # Обработка гонки (пользователь создан между SELECT и INSERT)
                await session.rollback()
                self._logger.error(f"Ошибка IntegrityError при обработке TG ID {tg_user.id}. {ie.orig if hasattr(ie, 'orig') else ie}", exc_info=True)
                self._logger.info(f"Повторная попытка получения пользователя TG ID {tg_user.id} после IntegrityError.")
                db_user_retry = await self._get_user_by_telegram_id(tg_user.id, session, load_roles=True)
                if db_user_retry:
                    self._logger.info(f"Пользователь TG ID {tg_user.id} найден при повторной попытке. Обновляем данные.")
                    meaningful_data_updated_on_retry = await self._update_existing_user_data(db_user_retry, tg_user, current_lang_code)
                    
                    # Логика ролей при ретрае (убедимся, что владелец без ролей, а юзер с ролью User)
                    if rbac_service:
                        if is_owner:
                            if db_user_retry.roles:
                                for role_retry in list(db_user_retry.roles): await rbac_service.remove_role_from_user(session, db_user_retry, role_retry.name)
                        elif not db_user_retry.roles: # Если это не владелец и у него нет ролей
                             await rbac_service.assign_role_to_user(session, db_user_retry, DEFAULT_ROLE_USER)
                    
                    if meaningful_data_updated_on_retry or (session.new or session.dirty or session.deleted):
                        self._logger.info(f"UserService (retry): ПЕРЕД session.commit() для TG ID {tg_user.id}.")
                        await session.commit()
                        self._logger.success(f"UserService (retry): ПОСЛЕ session.commit() для TG ID {tg_user.id}.")
                        await session.refresh(db_user_retry, attribute_names=['id', 'roles', 'direct_permissions', 'last_activity_at', 'is_active', 'is_bot_blocked'])
                    return db_user_retry, False # False, т.к. он уже существовал на момент ретрая
                self._logger.error(f"Пользователь TG ID {tg_user.id} не найден даже после IntegrityError и повторной попытки.")
                return None, False
            except Exception as e: 
                self._logger.error(f"Непредвиденная ошибка ({type(e).__name__}) при обработке TG ID {tg_user.id} в UserService: {e}", exc_info=True)
                if hasattr(session, 'is_active') and session.is_active: 
                    await session.rollback()
                return None, False
        
        self._logger.error(f"Выход из process_user_on_start для TG ID {tg_user.id} без явного возврата.")
        return None, False
    
    async def update_user_language(self, user: DBUser, language_code: str, session: AsyncSession) -> bool:
        if user.preferred_language_code != language_code:
            user.preferred_language_code = language_code
            if user not in session.dirty and user not in session.new : session.add(user) 
            self._logger.info(f"Язык для пользователя {user.telegram_id} (DB ID: {user.id}) изменен на '{language_code}' (добавлен в сессию).")
            return True
        return False

    async def set_user_active_status(self, user: DBUser, is_active: bool, session: AsyncSession) -> bool:
        if user.telegram_id in self._services.config.core.super_admins:
            self._logger.warning(f"Попытка изменить статус активности Владельца ({user.telegram_id}). Действие запрещено.")
            return False 

        if user.is_active != is_active:
            user.is_active = is_active
            if user not in session.dirty and user not in session.new : session.add(user)
            self._logger.info(f"Статус активности для пользователя {user.telegram_id} (DB ID: {user.id}) изменен на {is_active} (добавлен в сессию).")
            return True
        return False

    async def set_user_bot_blocked_status(self, user: DBUser, is_bot_blocked: bool, session: AsyncSession) -> bool:
        if user.telegram_id in self._services.config.core.super_admins:
            self._logger.warning(f"Попытка изменить статус блокировки Владельца ({user.telegram_id}). Действие запрещено.")
            return False 

        if user.is_bot_blocked != is_bot_blocked:
            user.is_bot_blocked = is_bot_blocked
            if user not in session.dirty and user not in session.new : session.add(user)
            self._logger.info(f"Статус блокировки бота для пользователя {user.telegram_id} (DB ID: {user.id}) изменен на {is_bot_blocked} (добавлен в сессию).")
            return True
        return False


======================================================================

------------------------------ FILE: core/cache/manager.py ------------------------------
# core/cache/manager.py

import asyncio
import time
import pickle
from typing import Optional, Any, Union, TYPE_CHECKING
from abc import ABC, abstractmethod

# Используем redis.asyncio для асинхронной работы с Redis
try:
    import redis.asyncio as redis_async
    from redis.asyncio.client import Redis as AsyncRedisClient
    from redis.exceptions import RedisError, ConnectionError as RedisConnectionError, TimeoutError as RedisTimeoutError
    REDIS_PY_AVAILABLE = True
except ImportError:
    redis_async = None # type: ignore
    AsyncRedisClient = Any # type: ignore
    RedisError = Exception # type: ignore
    RedisConnectionError = Exception # type: ignore
    RedisTimeoutError = asyncio.TimeoutError # Фоллбэк на asyncio.TimeoutError
    REDIS_PY_AVAILABLE = False

try:
    from cachetools import TTLCache
except ImportError:
    TTLCache = None # type: ignore

from loguru import logger

if TYPE_CHECKING:
    from core.app_settings import CacheSettings

class BaseCache(ABC):
    @abstractmethod
    async def initialize(self) -> None: pass
    @abstractmethod
    async def dispose(self) -> None: pass
    @abstractmethod
    async def get(self, key: str) -> Optional[Any]: raise NotImplementedError
    @abstractmethod
    async def set(self, key: str, value: Any, ttl_seconds: Optional[int] = None) -> None: raise NotImplementedError
    @abstractmethod
    async def delete(self, key: str) -> bool: raise NotImplementedError
    @abstractmethod
    async def exists(self, key: str) -> bool: raise NotImplementedError
    @abstractmethod
    async def clear(self) -> None: raise NotImplementedError

class MemoryCache(BaseCache):
    def __init__(self, maxsize: int = 1024, default_ttl: int = 300):
        self._default_ttl = default_ttl
        if TTLCache:
            self._cache: Union[TTLCache, dict] = TTLCache(maxsize=maxsize, ttl=default_ttl)
            self._uses_cachetools = True
        else:
            logger.warning("Библиотека 'cachetools' не найдена. Используется простая ручная реализация MemoryCache с TTL.")
            self._cache = {} 
            self._maxsize = maxsize
            self._uses_cachetools = False
        logger.info(f"MemoryCache инициализирован (использует cachetools: {self._uses_cachetools}, default TTL: {default_ttl}s).")

    async def initialize(self) -> None: logger.debug("MemoryCache.initialize() - операция не требуется.")
    async def dispose(self) -> None: await self.clear(); logger.debug("MemoryCache.dispose() - кэш очищен.")

    async def get(self, key: str) -> Optional[Any]:
        if self._uses_cachetools and isinstance(self._cache, TTLCache):
            try: return self._cache[key]
            except KeyError: return None
        elif isinstance(self._cache, dict):
            item = self._cache.get(key)
            if item:
                value, expiry_timestamp = item
                if time.time() < expiry_timestamp: return value
                else: 
                    # Явно удаляем просроченный ключ
                    await self.delete(key) 
            return None
        return None

    async def set(self, key: str, value: Any, ttl_seconds: Optional[int] = None) -> None:
        effective_ttl = ttl_seconds if ttl_seconds is not None else self._default_ttl
        if self._uses_cachetools and isinstance(self._cache, TTLCache):
            if ttl_seconds is not None and ttl_seconds != self._cache.ttl: # type: ignore
                 # TTLCache имеет общий TTL, но можно хранить время истечения отдельно, если очень нужно.
                 # Пока оставляем как есть - используем общий TTL.
                 logger.trace(f"MemoryCache (TTLCache) использует общий TTL ({self._cache.ttl} сек) для всех ключей.") # type: ignore
            self._cache[key] = value
        elif isinstance(self._cache, dict):
            if len(self._cache) >= self._maxsize and key not in self._cache:
                # Простая LRU-подобная логика: удаляем самый старый (первый добавленный)
                # Это не настоящий LRU, но для простой реализации сойдет.
                try:
                    oldest_key = next(iter(self._cache))
                    del self._cache[oldest_key]
                    logger.trace(f"MemoryCache достиг maxsize, удален ключ (FIFO-like): {oldest_key}")
                except StopIteration: pass # Пустой словарь
            self._cache[key] = (value, time.time() + effective_ttl)

    async def delete(self, key: str) -> bool:
        if key in self._cache: 
            del self._cache[key]
            return True
        return False

    async def exists(self, key: str) -> bool: 
        # Для TTLCache проверка на существование автоматически учитывает TTL
        # Для ручной реализации get() также проверяет TTL
        return await self.get(key) is not None

    async def clear(self) -> None: 
        self._cache.clear()
        logger.info("MemoryCache очищен.")


class RedisCache(BaseCache):
    def __init__(self, redis_url: str):
        if not REDIS_PY_AVAILABLE:
            msg = "Библиотека 'redis' (с поддержкой asyncio) не установлена. `pip install redis`. RedisCache не будет работать."
            logger.critical(msg)
            raise ImportError(msg)
        self.redis_url = redis_url
        self._redis_client: Optional[AsyncRedisClient] = None
        logger.info(f"RedisCache инициализирован для URL: {self.redis_url} (используя redis.asyncio)")

    async def initialize(self) -> None:
        logger.debug(f"RedisCache: Попытка инициализации для URL: {self.redis_url}")
        if not redis_async:
            logger.critical("RedisCache.initialize: redis.asyncio не импортирован!")
            raise ImportError("redis.asyncio не доступен")

        try:
            logger.debug(f"RedisCache: Вызов redis.asyncio.from_url('{self.redis_url}')")
            self._redis_client = redis_async.from_url(
                self.redis_url, 
                decode_responses=False, # Важно для pickle
                socket_timeout=5,
                socket_connect_timeout=5,
                # health_check_interval=30 # Опционально
            )
            logger.debug(f"RedisCache: redis.asyncio.from_url выполнен. Клиент: {type(self._redis_client)}")
            
            if self._redis_client:
                logger.debug("RedisCache: Попытка PING...")
                await self._redis_client.ping()
                logger.success(f"Успешное подключение и PING к Redis: {self.redis_url}")
            else:
                # Эта ветка маловероятна, так как from_url обычно либо падает, либо возвращает клиент
                logger.error(f"RedisCache: redis.asyncio.from_url вернул None для {self.redis_url}")
                self._redis_client = None 
                raise RedisConnectionError("Не удалось создать клиент Redis (from_url вернул None)")

        except (asyncio.TimeoutError, RedisTimeoutError) as te: 
            logger.error(f"RedisCache: Таймаут при подключении/пинге к Redis ({self.redis_url}): {te}", exc_info=False) # exc_info=False т.к. таймаут - это ожидаемое
            self._redis_client = None
            raise
        except RedisConnectionError as ce: 
            logger.error(f"RedisCache: Ошибка соединения Redis ({self.redis_url}): {ce}", exc_info=True)
            self._redis_client = None
            raise
        except RedisError as re: 
            logger.error(f"RedisCache: Общая ошибка Redis при подключении/пинге ({self.redis_url}): {re}", exc_info=True)
            self._redis_client = None
            raise
        except Exception as e: 
            logger.error(f"RedisCache: Непредвиденная ошибка при инициализации Redis ({self.redis_url}): {type(e).__name__} - {e}", exc_info=True)
            self._redis_client = None
            raise

    async def dispose(self) -> None:
        if self._redis_client:
            logger.info(f"RedisCache: Закрытие соединения с Redis ({self.redis_url})...")
            try:
                await self._redis_client.close()
                # Для redis-py 4.2+ можно также закрыть пул соединений, если он не общий
                # и если это необходимо (обычно close() клиента достаточно)
                if hasattr(self._redis_client, 'connection_pool') and hasattr(self._redis_client.connection_pool, 'disconnect'):
                     await self._redis_client.connection_pool.disconnect()
                logger.info(f"Соединение с Redis ({self.redis_url}) успешно закрыто.")
            except Exception as e:
                logger.error(f"Ошибка при закрытии соединения с Redis ({self.redis_url}): {e}", exc_info=True)
            finally:
                self._redis_client = None

    async def get(self, key: str) -> Optional[Any]:
        if not self._redis_client: return None
        try:
            pickled_value = await self._redis_client.get(key)
            if pickled_value: return pickle.loads(pickled_value)
            return None
        except RedisError as e: logger.error(f"RedisCache: Ошибка Redis при GET для ключа '{key}': {e}"); return None
        except pickle.UnpicklingError as e: logger.error(f"RedisCache: Ошибка десериализации для ключа '{key}': {e}"); return None
        except Exception as e_unexp: logger.error(f"RedisCache: Неожиданная ошибка GET для ключа '{key}': {e_unexp}"); return None


    async def set(self, key: str, value: Any, ttl_seconds: Optional[int] = None) -> None:
        if not self._redis_client: return
        try:
            pickled_value = pickle.dumps(value)
            await self._redis_client.set(key, pickled_value, ex=ttl_seconds)
        except pickle.PicklingError as e: logger.error(f"RedisCache: Ошибка сериализации для ключа '{key}': {e}")
        except RedisError as e_redis: logger.error(f"RedisCache: Ошибка Redis при SET для ключа '{key}': {e_redis}")
        except Exception as e_unexp: logger.error(f"RedisCache: Неожиданная ошибка SET для ключа '{key}': {e_unexp}")


    async def delete(self, key: str) -> bool:
        if not self._redis_client: return False
        try: 
            deleted_count = await self._redis_client.delete(key)
            return deleted_count > 0
        except RedisError as e: logger.error(f"RedisCache: Ошибка Redis при DELETE для ключа '{key}': {e}"); return False
        except Exception as e_unexp: logger.error(f"RedisCache: Неожиданная ошибка DELETE для ключа '{key}': {e_unexp}"); return False


    async def exists(self, key: str) -> bool:
        if not self._redis_client: return False
        try: 
            exists_count = await self._redis_client.exists(key)
            return exists_count > 0
        except RedisError as e: logger.error(f"RedisCache: Ошибка Redis при EXISTS для ключа '{key}': {e}"); return False
        except Exception as e_unexp: logger.error(f"RedisCache: Неожиданная ошибка EXISTS для ключа '{key}': {e_unexp}"); return False


    async def clear(self) -> None:
        if not self._redis_client: return
        try:
            logger.warning(f"RedisCache: Выполняется команда FLUSHDB для Redis ({self.redis_url})!")
            await self._redis_client.flushdb()
            logger.info(f"RedisCache: FLUSHDB для Redis ({self.redis_url}) выполнен.")
        except RedisError as e: logger.error(f"RedisCache: Ошибка Redis при FLUSHDB: {e}")
        except Exception as e_unexp: logger.error(f"RedisCache: Неожиданная ошибка FLUSHDB: {e_unexp}")


    def get_client_instance(self) -> Optional[AsyncRedisClient]:
        return self._redis_client


class CacheManager:
    def __init__(self, cache_settings: 'CacheSettings'):
        self._settings = cache_settings
        self._cache_backend: Optional[BaseCache] = None
        self._is_initialized_successfully = False
        logger.info(f"CacheManager инициализирован. Сконфигурированный тип кэша: {self._settings.type}")

    async def initialize(self) -> None:
        if self._is_initialized_successfully:
            logger.debug(f"CacheManager (бэкенд: {self._settings.type}) уже был успешно инициализирован.")
            return
        self._is_initialized_successfully = False # Сбрасываем флаг перед новой попыткой

        if self._settings.type == "redis":
            if not self._settings.redis_url:
                logger.error("Тип кэша 'redis', но redis_url не указан в настройках. Кэш не будет инициализирован.")
                return
            if not REDIS_PY_AVAILABLE:
                logger.critical("Библиотека 'redis' (для asyncio) не установлена, но выбран тип кэша 'redis'. Кэш не будет работать.")
                return
            try:
                self._cache_backend = RedisCache(redis_url=str(self._settings.redis_url))
            except ImportError as e_imp_redis: 
                logger.critical(f"CacheManager: Не удалось создать RedisCache (ImportError): {e_imp_redis}")
                return 
        elif self._settings.type == "memory":
            self._cache_backend = MemoryCache() 
        else:
            logger.warning(f"Неизвестный тип кэша: '{self._settings.type}'. Кэш не будет доступен.")
            return

        if self._cache_backend:
            try:
                await self._cache_backend.initialize()
                # Дополнительная проверка для Redis, что клиент действительно создался
                if isinstance(self._cache_backend, RedisCache) and self._cache_backend.get_client_instance() is None:
                    logger.error(f"CacheManager: RedisCache.initialize() завершился, но клиент Redis остался None. Инициализация не удалась.")
                    self._cache_backend = None # Сбрасываем, чтобы is_available() вернул False
                else:
                    self._is_initialized_successfully = True
                    logger.success(f"Бэкенд кэша '{self._settings.type}' успешно инициализирован.")
            except Exception as e_init_backend: 
                logger.error(f"Ошибка инициализации бэкенда кэша '{self._settings.type}': {type(e_init_backend).__name__} - {e_init_backend}", exc_info=False)
                self._cache_backend = None 
    
    async def dispose(self) -> None:
        if self._cache_backend: 
            try: await self._cache_backend.dispose()
            except Exception as e: logger.error(f"Ошибка при освобождении ресурсов кэша '{self._settings.type}': {e}", exc_info=True)
        self._is_initialized_successfully = False 
        self._cache_backend = None 
        logger.info(f"Ресурсы CacheManager для бэкенда '{self._settings.type}' освобождены (или попытка освобождения).")


    def is_available(self) -> bool:
        return self._cache_backend is not None and self._is_initialized_successfully

    async def get(self, key: str, default: Optional[Any] = None) -> Optional[Any]:
        if not self.is_available() or self._cache_backend is None:
            logger.trace(f"Кэш недоступен. get('{key}') вернет default ({default}).")
            return default
        return await self._cache_backend.get(key)

    async def set(self, key: str, value: Any, ttl_seconds: Optional[int] = None) -> None:
        if not self.is_available() or self._cache_backend is None:
            logger.trace(f"Кэш недоступен. set('{key}', ...) не будет выполнено.")
            return
        await self._cache_backend.set(key, value, ttl_seconds=ttl_seconds)

    async def delete(self, key: str) -> bool:
        if not self.is_available() or self._cache_backend is None:
            logger.trace(f"Кэш недоступен. delete('{key}') вернет False.")
            return False
        return await self._cache_backend.delete(key)

    async def exists(self, key: str) -> bool:
        if not self.is_available() or self._cache_backend is None:
            logger.trace(f"Кэш недоступен. exists('{key}') вернет False.")
            return False
        return await self._cache_backend.exists(key)

    async def clear_all_cache(self) -> None:
        if not self.is_available() or self._cache_backend is None:
            logger.trace(f"Кэш недоступен. clear_all_cache() не будет выполнено.")
            return
        logger.warning(f"Запрошена полная очистка кэша для бэкенда '{self._settings.type}'.")
        await self._cache_backend.clear()

    async def get_redis_client_instance(self) -> Optional[AsyncRedisClient]:
        if self.is_available() and isinstance(self._cache_backend, RedisCache):
            return self._cache_backend.get_client_instance()
        logger.debug("Запрошен экземпляр Redis клиента, но RedisCache не используется или не инициализирован.")
        return None


======================================================================

------------------------------ FILE: core/cache/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/database/manager.py ------------------------------
# core/database/manager.py

from pathlib import Path
from contextlib import asynccontextmanager
from typing import AsyncGenerator, List, Type, Optional, TYPE_CHECKING

from sqlalchemy.ext.asyncio import (
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
    AsyncEngine
)
from sqlalchemy.pool import NullPool
from loguru import logger

from .base import Base
from core.app_settings import DEFAULT_PROJECT_DATA_DIR_NAME

if TYPE_CHECKING:
    from core.app_settings import DBSettings, AppSettings

class DBManager:
    def __init__(self, db_settings: 'DBSettings', app_settings: 'AppSettings'): # app_settings теперь обязателен
        self._db_settings: 'DBSettings' = db_settings
        self._app_settings: 'AppSettings' = app_settings
        self._engine: Optional[AsyncEngine] = None
        self._session_factory: Optional[async_sessionmaker[AsyncSession]] = None
        self._db_url: Optional[str] = None

        self._logger = logger.bind(service="DBManager")
        self._logger.info(f"DBManager инициализирован для типа БД: {self._db_settings.type}")

    def _build_db_url(self) -> str:
        if self._db_url:
            return self._db_url

        db_type = self._db_settings.type
        url: str

        if db_type == "sqlite":
            sqlite_path_str = self._db_settings.sqlite_path
            path_obj = Path(sqlite_path_str)
            abs_path: Path

            if path_obj.is_absolute():
                abs_path = path_obj.resolve()
            else:
                # self._app_settings здесь всегда должен быть доступен, т.к. он обязательный параметр конструктора
                if DEFAULT_PROJECT_DATA_DIR_NAME in path_obj.parts:
                    project_root_dir = self._app_settings.core.project_data_path.parent
                    abs_path = (project_root_dir / path_obj).resolve()
                else: 
                    abs_path = (self._app_settings.core.project_data_path / path_obj).resolve()
            
            abs_path.parent.mkdir(parents=True, exist_ok=True)
            self._logger.debug(f"Окончательный абсолютный путь для SQLite: {abs_path}")
            url = f"sqlite+aiosqlite:///{abs_path}"
            
        elif db_type == "postgresql":
            if not self._db_settings.pg_dsn:
                msg = "DSN для PostgreSQL (pg_dsn) не указана в настройках."
                self._logger.error(msg)
                raise ValueError(msg)
            url = str(self._db_settings.pg_dsn)
            
        elif db_type == "mysql":
            if not self._db_settings.mysql_dsn:
                msg = "DSN для MySQL (mysql_dsn) не указана в настройках."
                self._logger.error(msg)
                raise ValueError(msg)
            url = str(self._db_settings.mysql_dsn)
            
        else:
            msg = f"Неподдерживаемый тип базы данных в настройках: '{db_type}'"
            self._logger.error(msg)
            raise ValueError(msg)
        
        self._db_url = url
        return url

    async def initialize(self) -> None:
        if self._engine is not None:
            self._logger.debug("DBManager (engine) уже был инициализирован.")
            return

        db_url = self._build_db_url()
        self._logger.info(f"Инициализация асинхронного движка SQLAlchemy для URL: '{db_url[:db_url.find('://')+3]}...' (детали URL скрыты)")
        
        echo_sql = self._db_settings.echo_sql

        try:
            self._engine = create_async_engine(
                db_url,
                echo=echo_sql, 
                poolclass=NullPool,
            )
            
            self._session_factory = async_sessionmaker(
                bind=self._engine,
                class_=AsyncSession,
                expire_on_commit=False,
                autoflush=False,
                autocommit=False,
            )
            self._logger.success("SQLAlchemy AsyncEngine и SessionFactory успешно созданы.")
        except Exception as e:
            self._logger.critical(f"Ошибка при создании SQLAlchemy Engine или SessionFactory для URL '{db_url}': {e}", exc_info=True)
            self._engine = None
            self._session_factory = None
            raise

    async def dispose(self) -> None:
        if self._engine:
            self._logger.info("Закрытие SQLAlchemy AsyncEngine...")
            try:
                await self._engine.dispose()
                self._logger.success("SQLAlchemy AsyncEngine успешно закрыт.")
            except Exception as e:
                self._logger.error(f"Ошибка при закрытии SQLAlchemy AsyncEngine: {e}", exc_info=True)
            finally:
                self._engine = None
                self._session_factory = None
        else:
            self._logger.debug("DBManager (engine) не был инициализирован или уже закрыт.")

    @asynccontextmanager
    async def get_session(self) -> AsyncGenerator[AsyncSession, None]:
        if not self._session_factory:
            msg = "DBManager SessionFactory не инициализирована! Вызовите initialize() перед запросом сессии."
            self._logger.critical(msg)
            raise RuntimeError(msg)

        session: AsyncSession = self._session_factory()
        self._logger.trace(f"Сессия БД {id(session)} открыта.")
        try:
            yield session
        except Exception as e:
            self._logger.error(f"Ошибка в сессии БД {id(session)}: {e}. Выполняется откат (rollback).", exc_info=True)
            await session.rollback()
            raise
        finally:
            await session.close()
            self._logger.trace(f"Сессия БД {id(session)} закрыта.")

    async def create_all_core_tables(self) -> None:
        if not self._engine:
            err_msg = "DBManager Engine не инициализирован. Невозможно создать таблицы."
            self._logger.error(err_msg)
            raise RuntimeError(err_msg)

        self._logger.info("Запрос на создание всех таблиц ядра на основе Base.metadata...")
        async with self._engine.begin() as conn:
            from core.database import core_models # noqa: F401
            await conn.run_sync(Base.metadata.create_all)
        self._logger.success("Все таблицы ядра (на основе текущего Base.metadata) успешно созданы (или уже существовали).")

    async def create_specific_module_tables(self, module_model_classes: List[Type[Base]]) -> None:
        if not self._engine:
            err_msg = "DBManager Engine не инициализирован. Невозможно создать таблицы модуля."
            self._logger.error(err_msg)
            raise RuntimeError(err_msg)
        if not module_model_classes:
            self._logger.debug("Нет моделей для создания таблиц модуля (список пуст).")
            return

        tables_to_create = [model_cls.__table__ for model_cls in module_model_classes]
        table_names_str = ", ".join([table.name for table in tables_to_create])
        self._logger.info(f"Запрос на создание таблиц для модуля: [{table_names_str}]")

        async with self._engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all, tables=tables_to_create)
        self._logger.success(f"Таблицы модуля [{table_names_str}] успешно созданы (или уже существовали).")

    async def drop_specific_module_tables(self, module_model_classes: List[Type[Base]]) -> None:
        if not self._engine:
            err_msg = "DBManager Engine не инициализирован. Невозможно удалить таблицы модуля."
            self._logger.error(err_msg)
            raise RuntimeError(err_msg)
        if not module_model_classes:
            self._logger.debug("Нет моделей для удаления таблиц модуля (список пуст).")
            return

        tables_to_drop = [model_cls.__table__ for model_cls in module_model_classes]
        tables_to_drop_ordered = tables_to_drop[::-1] 
        table_names_str = ", ".join([table.name for table in tables_to_drop_ordered])
        
        self._logger.warning(f"ЗАПРОС НА УДАЛЕНИЕ ТАБЛИЦ МОДУЛЯ (ОПАСНО!): [{table_names_str}]")
        
        async with self._engine.begin() as conn:
            await conn.run_sync(Base.metadata.drop_all, tables=tables_to_drop_ordered)
        self._logger.success(f"Таблицы модуля [{table_names_str}] успешно УДАЛЕНЫ.")


======================================================================

------------------------------ FILE: core/database/db_utils.py ------------------------------
"""
Утилиты для работы с разными типами баз данных.
"""
from typing import Optional, Dict, Any
from sqlalchemy import create_engine, text
from sqlalchemy.engine import Engine


class DatabaseDialectHandler:
    """Класс для обработки специфики разных диалектов БД"""
    
    @staticmethod
    def get_dialect_features(engine: Engine) -> Dict[str, bool]:
        """Возвращает поддерживаемые функции для диалекта БД"""
        dialect_name = engine.dialect.name.lower()
        
        features = {
            'supports_comments': True,
            'supports_check_constraints': True,
            'supports_deferrable_fks': True,
            'supports_sequences': True,
            'supports_returning': True,
            'case_sensitive': True,
        }
        
        if dialect_name == 'sqlite':
            features.update({
                'supports_comments': False,
                'supports_deferrable_fks': False,
                'supports_sequences': False,
                'supports_returning': False,  # Старые версии SQLite
                'case_sensitive': False,
            })
        elif dialect_name in ['mysql', 'mariadb']:
            features.update({
                'supports_comments': True,
                'supports_check_constraints': True,  # MySQL 8.0+
                'supports_deferrable_fks': False,
                'supports_sequences': False,  # До MySQL 8.0
                'supports_returning': False,
                'case_sensitive': False,  # Зависит от настроек
            })
        elif dialect_name == 'postgresql':
            features.update({
                'supports_comments': True,
                'supports_check_constraints': True,
                'supports_deferrable_fks': True,
                'supports_sequences': True,
                'supports_returning': True,
                'case_sensitive': True,
            })
        
        return features
    
    @staticmethod
    def get_recommended_types(engine: Engine) -> Dict[str, str]:
        """Возвращает рекомендуемые типы данных для диалекта"""
        dialect_name = engine.dialect.name.lower()
        
        if dialect_name == 'sqlite':
            return {
                'id': 'INTEGER',
                'bigint': 'INTEGER',
                'string_short': 'TEXT',
                'string_long': 'TEXT',
                'text': 'TEXT',
                'boolean': 'INTEGER',
                'datetime': 'DATETIME',
                'json': 'TEXT',
            }
        elif dialect_name in ['mysql', 'mariadb']:
            return {
                'id': 'INT AUTO_INCREMENT',
                'bigint': 'BIGINT',
                'string_short': 'VARCHAR(255)',
                'string_long': 'TEXT',
                'text': 'TEXT',
                'boolean': 'TINYINT(1)',
                'datetime': 'DATETIME',
                'json': 'JSON',  # MySQL 5.7+
            }
        elif dialect_name == 'postgresql':
            return {
                'id': 'SERIAL',
                'bigint': 'BIGINT',
                'string_short': 'VARCHAR(255)',
                'string_long': 'TEXT',
                'text': 'TEXT',
                'boolean': 'BOOLEAN',
                'datetime': 'TIMESTAMP WITH TIME ZONE',
                'json': 'JSONB',
            }
        
        return {}
    
    @staticmethod
    def create_db_if_not_exists(connection_url: str, db_name: str) -> bool:
        """Создает базу данных, если она не существует (для MySQL/PostgreSQL)"""
        try:
            if 'mysql' in connection_url or 'mariadb' in connection_url:
                # Для MySQL
                base_url = connection_url.rsplit('/', 1)[0]
                engine = create_engine(base_url + '/mysql')
                with engine.connect() as conn:
                    conn.execute(text(f"CREATE DATABASE IF NOT EXISTS `{db_name}` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci"))
                    conn.commit()
                return True
                
            elif 'postgresql' in connection_url:
                # Для PostgreSQL
                base_url = connection_url.rsplit('/', 1)[0]
                engine = create_engine(base_url + '/postgres')
                with engine.connect() as conn:
                    # PostgreSQL требует автокоммит для CREATE DATABASE
                    conn.execute(text("COMMIT"))
                    result = conn.execute(text(f"SELECT 1 FROM pg_database WHERE datname = '{db_name}'"))
                    if not result.fetchone():
                        conn.execute(text(f'CREATE DATABASE "{db_name}" WITH ENCODING "UTF8"'))
                return True
                
        except Exception as e:
            print(f"Ошибка при создании БД {db_name}: {e}")
            return False
        
        return True  # SQLite создается автоматически


def get_db_info_query(dialect_name: str) -> Optional[str]:
    """Возвращает SQL-запрос для получения информации о БД"""
    if dialect_name == 'sqlite':
        return "SELECT sqlite_version() as version"
    elif dialect_name in ['mysql', 'mariadb']:
        return "SELECT VERSION() as version"
    elif dialect_name == 'postgresql':
        return "SELECT version() as version"
    return None


def optimize_for_dialect(engine: Engine) -> Dict[str, Any]:
    """Возвращает оптимальные настройки для диалекта БД"""
    dialect_name = engine.dialect.name.lower()
    
    settings = {}
    
    if dialect_name == 'sqlite':
        settings = {
            'pool_pre_ping': False,
            'pool_recycle': -1,
            'echo': False,
            'connect_args': {
                'check_same_thread': False,
                'timeout': 30,
            }
        }
    elif dialect_name in ['mysql', 'mariadb']:
        settings = {
            'pool_pre_ping': True,
            'pool_recycle': 3600,
            'pool_size': 10,
            'max_overflow': 20,
            'connect_args': {
                'charset': 'utf8mb4',
                'connect_timeout': 60,
            }
        }
    elif dialect_name == 'postgresql':
        settings = {
            'pool_pre_ping': True,
            'pool_recycle': 3600,
            'pool_size': 10,
            'max_overflow': 20,
            'connect_args': {
                'connect_timeout': 60,
                'application_name': 'SwiftDevBot',
            }
        }
    
    return settings


======================================================================

------------------------------ FILE: core/database/core_models.py ------------------------------
# core/database/core_models.py
from datetime import datetime
from typing import List, Optional, TYPE_CHECKING
from sqlalchemy import String, ForeignKey, UniqueConstraint, Text, BigInteger
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .base import SDBBaseModel 

SDB_CORE_TABLE_PREFIX = "sdb_"

if TYPE_CHECKING:
    pass 

def get_column_comment(text: str) -> Optional[str]:
    return text

class Permission(SDBBaseModel):
    __tablename__ = f"{SDB_CORE_TABLE_PREFIX}permissions"
    
    name: Mapped[str] = mapped_column(
        String(100), 
        unique=True, 
        index=True, 
        nullable=False, 
        comment=get_column_comment("Уникальное имя разрешения (например, 'view_users', 'manage_modules')")
    )
    description: Mapped[Optional[str]] = mapped_column(
        Text, 
        nullable=True, 
        comment=get_column_comment("Описание разрешения")
    )
    
    roles: Mapped[List["Role"]] = relationship(
        "Role",
        secondary=f"{SDB_CORE_TABLE_PREFIX}role_permissions",
        back_populates="permissions",
        lazy="selectin" 
    )
    
    # Новое отношение для прямых разрешений пользователя
    users_with_direct_access: Mapped[List["User"]] = relationship(
        "User",
        secondary=f"{SDB_CORE_TABLE_PREFIX}user_permissions", # Имя новой связующей таблицы
        back_populates="direct_permissions",
        lazy="selectin" # или "noload", если не нужно часто загружать пользователей по разрешению
    )

    def __repr__(self) -> str:
        return f"<Permission(id={self.id}, name='{self.name}')>"

class RolePermission(SDBBaseModel):
    __tablename__ = f"{SDB_CORE_TABLE_PREFIX}role_permissions"
    __table_args__ = (
        UniqueConstraint('role_id', 'permission_id', name=f'uq_{SDB_CORE_TABLE_PREFIX}role_permissions_role_id_permission_id'),
    )
    
    role_id: Mapped[int] = mapped_column(
        ForeignKey(f"{SDB_CORE_TABLE_PREFIX}roles.id", ondelete="CASCADE"), 
        nullable=False, 
        index=True,
        comment=get_column_comment("ID роли")
    )
    permission_id: Mapped[int] = mapped_column(
        ForeignKey(f"{SDB_CORE_TABLE_PREFIX}permissions.id", ondelete="CASCADE"), 
        nullable=False, 
        index=True,
        comment=get_column_comment("ID разрешения")
    )

    def __repr__(self) -> str:
        return f"<RolePermission(id={self.id}, role_id={self.role_id}, permission_id={self.permission_id})>"
        
class Role(SDBBaseModel):
    __tablename__ = f"{SDB_CORE_TABLE_PREFIX}roles"
    
    name: Mapped[str] = mapped_column(
        String(50), 
        unique=True, 
        index=True, 
        nullable=False, 
        comment=get_column_comment("Уникальное имя роли")
    )
    description: Mapped[Optional[str]] = mapped_column(
        Text, 
        nullable=True, 
        comment=get_column_comment("Описание роли")
    )
    
    users: Mapped[List["User"]] = relationship(
        "User", 
        secondary=f"{SDB_CORE_TABLE_PREFIX}user_roles",
        back_populates="roles",
        lazy="selectin",
        cascade="save-update, merge" 
    )

    permissions: Mapped[List["Permission"]] = relationship(
        "Permission",
        secondary=f"{SDB_CORE_TABLE_PREFIX}role_permissions",
        back_populates="roles",
        lazy="selectin", 
        cascade="save-update, merge"
    )

    def __repr__(self) -> str:
        return f"<Role(id={self.id}, name='{self.name}')>"


class UserRole(SDBBaseModel):
    __tablename__ = f"{SDB_CORE_TABLE_PREFIX}user_roles"
    __table_args__ = (
        UniqueConstraint('user_id', 'role_id', name=f'uq_{SDB_CORE_TABLE_PREFIX}user_roles_user_id_role_id'),
    )
    
    user_id: Mapped[int] = mapped_column(
        ForeignKey(f"{SDB_CORE_TABLE_PREFIX}users.id", ondelete="CASCADE"), 
        nullable=False, 
        index=True,
        comment=get_column_comment("ID пользователя")
    )
    role_id: Mapped[int] = mapped_column(
        ForeignKey(f"{SDB_CORE_TABLE_PREFIX}roles.id", ondelete="CASCADE"), 
        nullable=False, 
        index=True,
        comment=get_column_comment("ID роли")
    )

    def __repr__(self) -> str:
        return f"<UserRole(id={self.id}, user_id={self.user_id}, role_id={self.role_id})>"

# --- Новая модель для связи User <-> Permission ---
class UserPermission(SDBBaseModel):
    __tablename__ = f"{SDB_CORE_TABLE_PREFIX}user_permissions"
    __table_args__ = (
        UniqueConstraint('user_id', 'permission_id', name=f'uq_{SDB_CORE_TABLE_PREFIX}user_permissions_user_id_permission_id'),
    )

    user_id: Mapped[int] = mapped_column(
        ForeignKey(f"{SDB_CORE_TABLE_PREFIX}users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment=get_column_comment("ID пользователя")
    )
    permission_id: Mapped[int] = mapped_column(
        ForeignKey(f"{SDB_CORE_TABLE_PREFIX}permissions.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment=get_column_comment("ID разрешения")
    )

    def __repr__(self) -> str:
        return f"<UserPermission(id={self.id}, user_id={self.user_id}, permission_id={self.permission_id})>"


class User(SDBBaseModel):
    __tablename__ = f"{SDB_CORE_TABLE_PREFIX}users"

    username_lower: Mapped[Optional[str]] = mapped_column(
        String(32), 
        nullable=True, 
        index=True, 
        comment=get_column_comment("Telegram username в нижнем регистре для поиска")
    )
    
    telegram_id: Mapped[int] = mapped_column(
        BigInteger, 
        unique=True, 
        index=True, 
        nullable=False, 
        comment=get_column_comment("Уникальный Telegram ID пользователя")
    )
    username: Mapped[Optional[str]] = mapped_column( 
        String(32), 
        nullable=True, 
        index=True, 
        comment=get_column_comment("Telegram username (оригинальный регистр)")
    )
    first_name: Mapped[Optional[str]] = mapped_column(
        String(255), 
        nullable=True, 
        comment=get_column_comment("Имя пользователя")
    )
    last_name: Mapped[Optional[str]] = mapped_column(
        String(255), 
        nullable=True, 
        comment=get_column_comment("Фамилия пользователя")
    )
    preferred_language_code: Mapped[Optional[str]] = mapped_column(
        String(10), 
        nullable=True, 
        comment=get_column_comment("Код языка бота")
    )
    is_active: Mapped[bool] = mapped_column(
        default=True, 
        nullable=False, 
        comment=get_column_comment("Активен ли пользователь")
    )
    is_bot_blocked: Mapped[bool] = mapped_column(
        default=False, 
        nullable=False, 
        comment=get_column_comment("Заблокировал ли пользователь бота")
    )
    last_activity_at: Mapped[Optional[datetime]] = mapped_column(
        nullable=True, 
        comment=get_column_comment("Время последней активности")
    )

    roles: Mapped[List["Role"]] = relationship(
        "Role", 
        secondary=f"{SDB_CORE_TABLE_PREFIX}user_roles",
        back_populates="users",
        lazy="selectin",
        cascade="save-update, merge"
    )
    
    # Новое отношение для прямых разрешений
    direct_permissions: Mapped[List["Permission"]] = relationship(
        "Permission",
        secondary=f"{SDB_CORE_TABLE_PREFIX}user_permissions", # Имя новой связующей таблицы
        back_populates="users_with_direct_access",
        lazy="selectin", # или "noload", если не нужно часто загружать права при загрузке юзера
        cascade="save-update, merge" # Позволит управлять через user.direct_permissions.append()
    )
    
    @property
    def full_name(self) -> str:
        parts = []
        if self.first_name: parts.append(self.first_name)
        if self.last_name: parts.append(self.last_name)
        if parts: return " ".join(parts)
        elif self.username: return f"@{self.username}"
        return f"User_{self.telegram_id}"

    def __repr__(self) -> str:
        return f"<User(id={self.id}, tg_id={self.telegram_id}, name='{self.full_name}')>"


======================================================================

------------------------------ FILE: core/database/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/database/base.py ------------------------------
# core/database/base.py
from typing import Any, Dict
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy import func, MetaData
from datetime import datetime, timezone 

convention = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}
metadata_obj = MetaData(naming_convention=convention)

class Base(DeclarativeBase):
    metadata = metadata_obj

class SDBBaseModel(Base):
    __abstract__ = True
    id: Mapped[int] = mapped_column(primary_key=True, index=True, autoincrement=True)
    created_at: Mapped[datetime] = mapped_column(
        default=lambda: datetime.now(timezone.utc),
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
        server_default=func.now(),
        server_onupdate=func.now() 
    )
    def to_dict(self, exclude: set = None) -> Dict[str, Any]:
        if exclude is None: exclude = set()
        data = {}
        for prop in self.__mapper__.iterate_properties:
            if hasattr(prop, 'columns') and prop.key not in exclude:
                try: data[prop.key] = getattr(self, prop.key)
                except AttributeError: pass
        return data
    def __repr__(self) -> str:
        pk_column_names = [pk_col.name for pk_col in self.__table__.primary_key.columns]
        pk_values_str = ", ".join(f"{name}={getattr(self, name)!r}" for name in pk_column_names)
        return f"<{self.__class__.__name__}({pk_values_str})>"


======================================================================

------------------------------ FILE: core/admin/filters_admin.py ------------------------------
# core/admin/filters_admin.py

from aiogram import types
from loguru import logger

# Используем основное разрешение для доступа к админ-панели
from core.rbac.service import PERMISSION_CORE_VIEW_ADMIN_PANEL 

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider

MODULE_NAME_FOR_LOG = "AdminFilters"

async def can_view_admin_panel_filter(event: types.TelegramObject, services_provider: 'BotServicesProvider') -> bool:
    """
    Проверяет, имеет ли пользователь доступ к основным разделам админ-панели.
    Доступ разрешен, если:
    1. Пользователь находится в списке super_admins из конфигурации.
    2. Пользователь имеет разрешение PERMISSION_CORE_VIEW_ADMIN_PANEL.
    """
    user = getattr(event, 'from_user', None) 
    if not user: 
        logger.trace(f"[{MODULE_NAME_FOR_LOG}] Событие без 'from_user', доступ к админ-панели не релевантен или запрещен.")
        return False

    user_id = user.id
    user_mention = f"@{user.username}" if user.username else f"ID:{user.id}"

    if user_id in services_provider.config.core.super_admins:
        logger.trace(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} имеет доступ к админ-панели (super_admin из config).")
        return True
    try:
        async with services_provider.db.get_session() as session:
            has_permission = await services_provider.rbac.user_has_permission(
                session, user_id, PERMISSION_CORE_VIEW_ADMIN_PANEL
            )
            if has_permission:
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} имеет разрешение '{PERMISSION_CORE_VIEW_ADMIN_PANEL}' (доступ разрешен).")
                return True
    except Exception as e:
        logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка проверки разрешения '{PERMISSION_CORE_VIEW_ADMIN_PANEL}' для {user_mention} в БД: {e}", exc_info=True)
        return False 
    
    logger.warning(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_mention} "
                   f"попытался получить доступ к админ-панели без разрешения '{PERMISSION_CORE_VIEW_ADMIN_PANEL}'.")
    return False



======================================================================

------------------------------ FILE: core/admin/handlers_log_viewer.py ------------------------------
# core/admin/handlers_log_viewer.py
import logging
from aiogram import Router, types
from aiogram.filters import Command

router = Router()

@router.message(Command("some_command")) 
async def some_handler(message: types.Message):
    await message.answer("You triggered some_command!")


======================================================================

------------------------------ FILE: core/admin/keyboards_admin_common.py ------------------------------
# core/admin/keyboards_admin_common.py
from aiogram import types 
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder 
from core.ui.callback_data_factories import CoreMenuNavigate, AdminMainMenuNavigate

from typing import TYPE_CHECKING 
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession
    from core.rbac.service import (
        PERMISSION_CORE_USERS_VIEW_LIST,
        PERMISSION_CORE_MODULES_VIEW_LIST,
        PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC,
        PERMISSION_CORE_SYSTEM_VIEW_INFO_FULL,
        PERMISSION_CORE_ROLES_VIEW
    )

ADMIN_COMMON_TEXTS = {
    "back_to_main_menu_sdb": "🏠 Главное меню SDB",
    "back_to_admin_menu_main": "⬅️ Админ-панель (Главная)",
    "pagination_prev": "⬅️ Пред.",
    "pagination_next": "След. ➡️",
    "confirm_yes": "✅ Да",
    "confirm_no": "❌ Нет",
    "close_message": "❌ Закрыть это сообщение",
    "error_general": "Произошла ошибка. Попробуйте позже.",
    "access_denied": "У вас нет прав для этого действия.",
    "not_found_generic": "Запрошенный элемент не найден.",
    
    # Тексты для кнопок главного меню админки
    "manage_users": "👤 Управление пользователями",
    "manage_roles": "🛡️ Управление ролями",
    "manage_modules": "🧩 Управление модулями",
    "system_info": "⚙️ Информация о системе",

    # Тексты для категорий и групп разрешений (добавлены)
    "perm_category_core": "Разрешения Ядра",
    "perm_category_modules": "Разрешения Модулей",
    "perm_core_group_users": "Пользователи (Ядро)",
    "perm_core_group_roles": "Роли (Ядро)",
    "perm_core_group_modules_core": "Управление модулями (Ядро)", # Изменено для ясности
    "perm_core_group_system": "Система (Ядро)",
    "perm_core_group_settings_core": "Настройки Ядра",
    "perm_core_group_other": "Прочие (Ядро)",
    "back_to_perm_categories": "⬅️ К категориям разрешений",
    "back_to_core_perm_groups": "⬅️ К группам Ядра",
    "back_to_module_list_for_perms": "⬅️ К списку модулей (для прав)",
    "no_modules_with_perms": "Нет модулей с объявлениями прав",
    "no_permissions_in_group": "В этой группе нет разрешений",

    # Тексты для FSM (добавлены)
    "fsm_enter_role_name": "Введите имя новой роли:",
    "fsm_role_name_empty": "Имя роли не может быть пустым.",
    "fsm_role_name_taken": "Роль с именем \"{role_name}\" уже существует.",
    "fsm_enter_role_description": "Введите описание для роли {role_name}:",
    "fsm_command_skip_description": "/skip_description - Пропустить",
    "fsm_command_cancel_role_creation": "/cancel_role_creation - Отменить создание",
    "fsm_role_created_successfully": "Роль \"{role_name}\" успешно создана!",
    "fsm_role_creation_cancelled": "Создание роли отменено.",
    
    "fsm_edit_role_title": "Редактирование роли: {role_name}",
    "fsm_edit_role_name_not_allowed": "Имя стандартной роли {role_name} изменять нельзя.",
    "fsm_enter_new_role_description": "Введите новое описание для роли {role_name} (текущее: {current_description}):",
    "fsm_enter_new_role_name": "Введите новое имя для роли (текущее: {current_name}):",
    "fsm_command_skip_name": "/skip_name - Оставить как есть",
    "fsm_command_cancel_role_edit": "/cancel_role_edit - Отменить редактирование",
    "fsm_role_updated_successfully": "Роль \"{role_name}\" успешно обновлена!",
    "fsm_role_update_cancelled": "Редактирование роли отменено.",

    "delete_role_confirm_text": "Вы уверены, что хотите удалить роль {role_name}?\n{warning_if_users}\nЭто действие необратимо!",
    "role_is_standard_cant_delete": "Стандартную роль \"{role_name}\" удалять нельзя.",
    "role_delete_failed": "Не удалось удалить роль \"{role_name}\".",
    "role_deleted_successfully": "Роль \"{role_name}\" успешно удалена.",
}

def get_back_to_admin_main_menu_button() -> InlineKeyboardButton:
    return InlineKeyboardButton(
        text=ADMIN_COMMON_TEXTS["back_to_admin_menu_main"],
        callback_data=AdminMainMenuNavigate(target_section="main_admin").pack()
    )

def get_back_to_sdb_main_menu_button() -> InlineKeyboardButton:
    return InlineKeyboardButton(
        text=ADMIN_COMMON_TEXTS["back_to_main_menu_sdb"],
        callback_data=CoreMenuNavigate(target_menu="main").pack()
    )

async def get_admin_main_menu_keyboard( 
    services: 'BotServicesProvider',
    user_tg_id: int,
    session: 'AsyncSession' 
) -> types.InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = ADMIN_COMMON_TEXTS 

    rbac = services.rbac
    user_is_owner_from_config = user_tg_id in services.config.core.super_admins

    from core.rbac.service import (
        PERMISSION_CORE_USERS_VIEW_LIST,
        PERMISSION_CORE_MODULES_VIEW_LIST,
        PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC,
        PERMISSION_CORE_SYSTEM_VIEW_INFO_FULL,
        PERMISSION_CORE_ROLES_VIEW
    )
    
    if user_is_owner_from_config or \
       await rbac.user_has_permission(session, user_tg_id, PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC) or \
       await rbac.user_has_permission(session, user_tg_id, PERMISSION_CORE_SYSTEM_VIEW_INFO_FULL):
        builder.button(
            text=texts["system_info"],
            callback_data=AdminMainMenuNavigate(target_section="sys_info").pack() 
        )

    if user_is_owner_from_config or \
       await rbac.user_has_permission(session, user_tg_id, PERMISSION_CORE_USERS_VIEW_LIST):
        builder.button(
            text=texts["manage_users"],
            callback_data=AdminMainMenuNavigate(target_section="users").pack() 
        )
    
    if user_is_owner_from_config or \
       await rbac.user_has_permission(session, user_tg_id, PERMISSION_CORE_ROLES_VIEW): 
        builder.button(
            text=texts["manage_roles"],
            callback_data=AdminMainMenuNavigate(target_section="roles").pack() 
        )

    if user_is_owner_from_config or \
       await rbac.user_has_permission(session, user_tg_id, PERMISSION_CORE_MODULES_VIEW_LIST):
        builder.button(
            text=texts["manage_modules"],
            callback_data=AdminMainMenuNavigate(target_section="modules").pack() 
        )
    
    # Кнопка для просмотра логов, если нужно
    # from core.rbac.service import PERMISSION_CORE_SYSTEM_VIEW_LOGS_BASIC
    # if user_is_owner_from_config or \
    #    await rbac.user_has_permission(session, user_tg_id, PERMISSION_CORE_SYSTEM_VIEW_LOGS_BASIC):
    #     builder.button(
    #         text="Просмотр логов", # Добавить в ADMIN_COMMON_TEXTS
    #         callback_data=AdminMainMenuNavigate(target_section="logs_view").pack()
    #     )
    
    if builder.export(): 
        builder.adjust(1)

    builder.row(get_back_to_sdb_main_menu_button()) 
    return builder.as_markup()


======================================================================

------------------------------ FILE: core/admin/handlers_module_management.py ------------------------------
# core/admin/handlers_module_management.py
import logging
from aiogram import Router, types
from aiogram.filters import Command

router = Router()

@router.message(Command("some_command")) 
async def some_handler(message: types.Message):
    await message.answer("You triggered some_command!")


======================================================================

------------------------------ FILE: core/admin/__init__.py ------------------------------
# core/admin/__init__.py
from aiogram import Router
from loguru import logger

# Импортируем "собирающие" роутеры из каждого раздела
try:
    from .entry import section_entry_router # Импортируем собирающий роутер раздела
    logger.info("Admin submodule 'entry' (section router) loaded.")
except ImportError as e:
    section_entry_router = Router(name="sdb_admin_entry_stub_main") 
    logger.error(f"Failed to load admin submodule 'entry' (section router): {e}")

try:
    from .users import section_users_router # Импортируем собирающий роутер раздела
    logger.info("Admin submodule 'users' (section router) loaded.")
except ImportError as e:
    section_users_router = Router(name="sdb_admin_users_stub_main")
    logger.error(f"Failed to load admin submodule 'users' (section router): {e}")

try:
    from .roles import section_roles_router # Импортируем собирающий роутер раздела
    logger.info("Admin submodule 'roles' (section router) loaded.")
except ImportError as e:
    section_roles_router = Router(name="sdb_admin_roles_stub_main")
    logger.error(f"Failed to load admin submodule 'roles' (section router): {e}")

try:
    from .sys_info import section_sys_info_router # Импортируем собирающий роутер раздела
    logger.info("Admin submodule 'sys_info' (section router) loaded.")
except ImportError as e:
    section_sys_info_router = Router(name="sdb_admin_sys_info_stub_main")
    logger.error(f"Failed to load admin submodule 'sys_info' (section router): {e}")

try:
    from .modules_mgmt import section_modules_mgmt_router # Импортируем собирающий роутер раздела
    logger.info("Admin submodule 'modules_mgmt' (section router) loaded.")
except ImportError as e:
    section_modules_mgmt_router = Router(name="sdb_admin_modules_mgmt_stub_main")
    logger.error(f"Failed to load admin submodule 'modules_mgmt' (section router): {e}")

try:
    from .logs_viewer import section_logs_viewer_router # Импортируем собирающий роутер раздела
    logger.info("Admin submodule 'logs_viewer' (section router) loaded.")
except ImportError as e:
    section_logs_viewer_router = Router(name="sdb_admin_logs_viewer_stub_main")
    logger.error(f"Failed to load admin submodule 'logs_viewer' (section router): {e}")


# Главный роутер админ-панели
admin_router = Router(name="sdb_admin_top_level_router") # Даем ему уникальное имя

admin_router.include_router(section_entry_router)
admin_router.include_router(section_users_router)
admin_router.include_router(section_roles_router)
admin_router.include_router(section_sys_info_router)
admin_router.include_router(section_modules_mgmt_router)
admin_router.include_router(section_logs_viewer_router)

logger.success("Main admin_router composed from section routers.")

__all__ = ["admin_router"]


======================================================================

------------------------------ FILE: core/i18n/middleware.py ------------------------------
# core/i18n/middleware.py

from typing import Callable, Dict, Any, Awaitable, Optional
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, User as AiogramUser # User из aiogram.types

# Импортируем наш Translator и AppSettings (для дефолтного языка и списка доступных)
from .translator import Translator
from core.app_settings import settings as sdb_settings # Глобальные настройки
from core.database.core_models import User as DBUser # Наша модель User из БД
from sqlalchemy.ext.asyncio import AsyncSession # Для работы с БД

# Для доступа к BotServicesProvider из workflow_data диспетчера (если он там есть)
# from core.services_provider import BotServicesProvider


class I18nMiddleware(BaseMiddleware):
    """
    Middleware для определения языка пользователя и предоставления
    инструментов локализации (gettext) в хэндлеры.
    """
    def __init__(self, translator: Translator):
        super().__init__()
        self.translator = translator
        self.default_locale = translator.default_locale
        self.available_locales = translator.available_locales
        # logger здесь можно получить из data, если BotServicesProvider его передает, или создать свой

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject, # Это может быть Message, CallbackQuery, etc.
        data: Dict[str, Any]   # Словарь данных, передаваемый в хэндлер
    ) -> Any:
        
        # Получаем объект пользователя Telegram, если он есть в событии
        aiogram_event_user: Optional[AiogramUser] = data.get("event_from_user")
        
        user_locale: str = self.default_locale # По умолчанию язык системы

        if aiogram_event_user:
            # Пытаемся получить язык пользователя из нашей БД
            # Для этого нужен доступ к DBManager или сессии
            # Предположим, что BotServicesProvider (services) доступен в data
            services = data.get("services_provider") # Имя ключа зависит от того, как мы его положили в Dispatcher
            
            db_user: Optional[DBUser] = None
            if services and hasattr(services, 'db'):
                try:
                    async with services.db.get_session() as session: # type: AsyncSession
                        # Ищем пользователя по telegram_id
                        from sqlalchemy import select # Ленивый импорт
                        stmt = select(DBUser).where(DBUser.telegram_id == aiogram_event_user.id)
                        result = await session.execute(stmt)
                        db_user = result.scalars().first()
                        
                        if db_user and db_user.preferred_language_code and db_user.preferred_language_code in self.available_locales:
                            user_locale = db_user.preferred_language_code
                        elif db_user and not db_user.preferred_language_code:
                            # Если у пользователя в БД нет языка, но есть язык в Telegram и он поддерживается
                            if aiogram_event_user.language_code and aiogram_event_user.language_code in self.available_locales:
                                user_locale = aiogram_event_user.language_code
                                # Можно обновить язык в БД для этого пользователя
                                # db_user.preferred_language_code = user_locale
                                # await session.commit() # ОСТОРОЖНО: commit в middleware
                        elif not db_user: # Если пользователя нет в БД
                            if aiogram_event_user.language_code and aiogram_event_user.language_code in self.available_locales:
                                user_locale = aiogram_event_user.language_code
                except Exception as e:
                    # logger.error(f"Ошибка получения языка пользователя из БД для TG ID {aiogram_event_user.id}: {e}")
                    # Используем логгер из data, если он там есть
                    data.get("logger", logger).error(f"I18nMiddleware: Ошибка БД при получении языка для TG ID {aiogram_event_user.id}: {e}")
                    # Продолжаем с default_locale или языком из Telegram, если он был определен ранее
            else: # Если services или services.db недоступны
                 data.get("logger", logger).warning("I18nMiddleware: BotServicesProvider или DBManager не найдены в data. Язык из БД не будет загружен.")
                 # Пытаемся использовать язык из Telegram API, если он поддерживается
                 if aiogram_event_user.language_code and aiogram_event_user.language_code in self.available_locales:
                     user_locale = aiogram_event_user.language_code
        
        # Сохраняем определенный язык в data для доступа в хэндлерах
        data["user_locale"] = user_locale
        
        # Предоставляем хэндлерам удобные функции для перевода
        # Они будут использовать user_locale, сохраненный в data
        # Это обертки, чтобы не передавать locale каждый раз
        data["gettext"] = lambda message_key, **kwargs: self.translator.gettext(message_key, user_locale, **kwargs)
        data["ngettext"] = lambda singular_key, plural_key, count, **kwargs: self.translator.ngettext(singular_key, plural_key, count, user_locale, **kwargs)
        
        # Также можно передать сам объект translator, если это удобнее
        data["translator"] = self.translator 
        
        # data.get("logger", logger).debug(f"I18nMiddleware: Установлен язык '{user_locale}' для TG ID {aiogram_event_user.id if aiogram_event_user else 'N/A'}.")
        
        return await handler(event, data)


======================================================================

------------------------------ FILE: core/i18n/translator.py ------------------------------
# core/i18n/translator.py

import gettext # Стандартная библиотека для i18n
from pathlib import Path
from typing import Dict, List, Optional, Any
from loguru import logger

# Импортируем настройки, чтобы знать путь к 'locales' и дефолтный язык
# Этот импорт может быть убран, если Translator будет получать эти данные извне
# from core.app_settings import settings as sdb_settings # Предположим, что настройки i18n там есть

class Translator:
    """
    Сервис для работы с переводами (локализацией) строк.
    Использует стандартный механизм gettext.
    """
    def __init__(
        self, 
        locales_dir: Path, 
        domain: str = "bot", # Имя домена переводов (соответствует имени .mo/.po файла)
        default_locale: str = "en", 
        available_locales: Optional[List[str]] = None
    ):
        """
        Инициализирует транслятор.

        Args:
            locales_dir: Путь к директории 'locales' (где лежат папки en/, ua/, etc.).
            domain: Имя домена переводов (обычно имя вашего .po/.mo файла, например, 'bot').
            default_locale: Язык по умолчанию, если перевод для языка пользователя не найден.
            available_locales: Список поддерживаемых языков (например, ['en', 'ua']).
                               Если None, попытается определить из папок в locales_dir.
        """
        self.locales_dir = locales_dir
        self.domain = domain
        self.default_locale = default_locale
        self._translations: Dict[str, gettext.GNUTranslations] = {} # Кэш загруженных переводов

        if available_locales:
            self.available_locales = available_locales
        else:
            # Пытаемся определить доступные языки по папкам в locales_dir
            self.available_locales = []
            if self.locales_dir.is_dir():
                for item in self.locales_dir.iterdir():
                    if item.is_dir() and (item / "LC_MESSAGES" / f"{self.domain}.mo").exists():
                        self.available_locales.append(item.name)
            if not self.available_locales:
                 logger.warning(f"Не найдены скомпилированные .mo файлы в {self.locales_dir} для домена '{self.domain}'. "
                                f"Локализация может не работать.")
            elif default_locale not in self.available_locales and self.available_locales:
                logger.warning(f"Язык по умолчанию '{default_locale}' не найден среди доступных: {self.available_locales}. "
                               f"Будет использован первый доступный язык или английский, если gettext не найдет ничего.")
        
        logger.info(f"Translator инициализирован. Locales dir: '{self.locales_dir}', Domain: '{self.domain}', "
                    f"Default: '{self.default_locale}', Available: {self.available_locales}")
        
        # Предзагрузка переводов (опционально, можно грузить по запросу)
        self.load_all_translations()


    def load_translation(self, locale: str) -> Optional[gettext.GNUTranslations]:
        """Загружает или возвращает из кэша объект перевода для указанного языка."""
        if locale in self._translations:
            return self._translations[locale]
        
        if locale not in self.available_locales:
            logger.trace(f"Язык '{locale}' не поддерживается или для него нет файлов перевода.")
            return None # Или можно вернуть перевод для default_locale

        try:
            # gettext.translation требует путь к директории, содержащей en/LC_MESSAGES, ua/LC_MESSAGES и т.д.
            # и список языков для поиска (fallback).
            translation = gettext.translation(
                domain=self.domain,
                localedir=str(self.locales_dir),
                languages=[locale, self.default_locale] # Порядок важен для fallback
            )
            self._translations[locale] = translation
            logger.debug(f"Переводы для языка '{locale}' успешно загружены.")
            return translation
        except FileNotFoundError:
            logger.warning(f"Файл перевода .mo для языка '{locale}' (домен '{self.domain}') не найден в '{self.locales_dir}'.")
            # Можно кэшировать None, чтобы не пытаться грузить снова
            self._translations[locale] = gettext.NullTranslations() # type: ignore # Используем NullTranslations как заглушку
            return self._translations[locale]
        except Exception as e:
            logger.error(f"Ошибка при загрузке перевода для языка '{locale}': {e}", exc_info=True)
            return None

    def load_all_translations(self) -> None:
        """Предзагружает все доступные переводы."""
        logger.info(f"Предзагрузка всех доступных переводов ({self.available_locales})...")
        for lang in self.available_locales:
            self.load_translation(lang)

    def gettext(self, message_key: str, locale: str, **kwargs: Any) -> str:
        """
        Получает переведенную строку по ключу для указанного языка.
        Поддерживает форматирование с kwargs.

        Пример ключа: "main_menu:button_profile" или просто "Profile Button Text"
        """
        translation = self._translations.get(locale)
        if not translation: # Если не загружен или NullTranslations
            # Пытаемся загрузить или используем дефолтный, если не удалось
            translation = self.load_translation(locale) or self._translations.get(self.default_locale)
            if not translation: # Если и дефолтный не загружен
                translation = self.load_translation(self.default_locale) or gettext.NullTranslations() # type: ignore
                self._translations[self.default_locale] = translation # Кэшируем NullTranslations для дефолта

        # gettext.gettext() используется объектом GNUTranslations
        translated_text = translation.gettext(message_key) # type: ignore

        try:
            # Применяем форматирование, если есть kwargs
            return translated_text.format(**kwargs) if kwargs else translated_text
        except (KeyError, IndexError) as e_format:
            logger.warning(f"Ошибка форматирования для ключа '{message_key}' (locale: {locale}): {e_format}. "
                           f"Переведенный текст: '{translated_text}', kwargs: {kwargs}")
            return translated_text # Возвращаем неформатированный текст в случае ошибки

    def ngettext(self, singular_key: str, plural_key: str, count: int, locale: str, **kwargs: Any) -> str:
        """
        Получает переведенную строку с учетом множественного числа.
        """
        translation = self._translations.get(locale)
        if not translation:
            translation = self.load_translation(locale) or self._translations.get(self.default_locale)
            if not translation:
                translation = self.load_translation(self.default_locale) or gettext.NullTranslations() # type: ignore
                self._translations[self.default_locale] = translation

        # ngettext ожидает msgid1, msgid2, n
        # Если мы используем ключи, то нам нужно как-то их передать.
        # Простой gettext.GNUTranslations.ngettext(msgid1, msgid2, n) не будет работать с нашими ключами.
        # Нам нужно, чтобы .po файлы содержали msgid и msgid_plural.
        # Для простоты, предположим, что ключи это и есть msgid/msgid_plural.
        translated_text = translation.ngettext(singular_key, plural_key, count) # type: ignore
        
        # Добавляем count в kwargs для форматирования, если его там нет
        format_kwargs = {**kwargs, 'count': count}
        try:
            return translated_text.format(**format_kwargs)
        except (KeyError, IndexError) as e_format:
            logger.warning(f"Ошибка форматирования ngettext для ключей '{singular_key}/{plural_key}' (locale: {locale}): {e_format}. "
                           f"Переведенный текст: '{translated_text}', kwargs: {format_kwargs}")
            return translated_text

    # Можно добавить методы для получения переводов для конкретного пользователя,
    # если язык пользователя известен сервису.
    # async def gettext_for_user(self, user_id: int, message_key: str, **kwargs) -> str:
    #     user_locale = await self._get_user_locale(user_id) # Нужен доступ к БД или кэшу с языком пользователя
    #     return self.gettext(message_key, user_locale, **kwargs)


======================================================================

------------------------------ FILE: core/i18n/__init__.py ------------------------------



======================================================================

------------------------------ FILE: core/admin/modules_mgmt/handlers_modules.py ------------------------------
# core/admin/modules_mgmt/handlers_modules.py
from aiogram import Router, types, F
from loguru import logger

from core.ui.callback_data_factories import AdminModulesPanelNavigate # Пример
from core.admin.filters_admin import can_view_admin_panel_filter
# from .keyboards_modules import ...

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider

modules_mgmt_router = Router(name="sdb_admin_modules_mgmt_handlers")
MODULE_NAME_FOR_LOG = "AdminModulesMgmt"

#modules_mgmt_router.callback_query.filter(can_view_admin_panel_filter)

@modules_mgmt_router.callback_query(AdminModulesPanelNavigate.filter(F.action == "list"))
async def cq_admin_modules_list_stub(
    query: types.CallbackQuery,
    callback_data: AdminModulesPanelNavigate, 
    services_provider: 'BotServicesProvider'
):
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Заглушка для списка модулей вызвана.")
    await query.answer("Раздел управления модулями в разработке.", show_alert=True)


======================================================================

------------------------------ FILE: core/admin/modules_mgmt/keyboards_modules.py ------------------------------
# core/admin/modules_mgmt/keyboards_modules.py
# Пока пустой, но файл существует
from aiogram.types import InlineKeyboardMarkup
from aiogram.utils.keyboard import InlineKeyboardBuilder

# def get_some_keyboard():
#     builder = InlineKeyboardBuilder()
#     # ...
#     return builder.as_markup()


======================================================================

------------------------------ FILE: core/admin/modules_mgmt/__init__.py ------------------------------
# core/admin/modules_mgmt/__init__.py
from aiogram import Router

from .handlers_modules import modules_mgmt_router # Роутер из handlers_modules.py

section_modules_mgmt_router = Router(name="sdb_admin_section_modules_mgmt_router")
section_modules_mgmt_router.include_router(modules_mgmt_router)

__all__ = ["section_modules_mgmt_router"]


======================================================================

------------------------------ FILE: core/admin/entry/handlers_entry.py ------------------------------
# core/admin/entry/handlers_entry.py
from aiogram import Router, types, F, Bot
from aiogram.filters import Command
from aiogram.utils.markdown import hbold
from loguru import logger
from aiogram.exceptions import TelegramBadRequest # <--- ИСПРАВЛЕН ИМПОРТ

from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS, get_admin_main_menu_keyboard 
from core.ui.callback_data_factories import CoreMenuNavigate, AdminMainMenuNavigate
from core.admin.filters_admin import can_view_admin_panel_filter 

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession 


admin_entry_router = Router(name="sdb_admin_entry_handlers")
MODULE_NAME_FOR_LOG = "AdminEntry"

#admin_entry_router.message.filter(can_view_admin_panel_filter)
#admin_entry_router.callback_query.filter(can_view_admin_panel_filter)


async def send_admin_main_menu(message_or_query: types.Message | types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = message_or_query.from_user.id 
    
    text = (f"🛠 {hbold('Административная панель SwiftDevBot')}\n"
            f"Выберите раздел для управления:")
    
    async with services_provider.db.get_session() as session: 
        keyboard = await get_admin_main_menu_keyboard(services_provider, user_id, session)

    if isinstance(message_or_query, types.Message):
        await message_or_query.answer(text, reply_markup=keyboard)
    elif isinstance(message_or_query, types.CallbackQuery) and message_or_query.message:
        try:
            if message_or_query.message.text != text or message_or_query.message.reply_markup != keyboard:
                await message_or_query.message.edit_text(text, reply_markup=keyboard)
            else:
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение админ-панели не было изменено.")
            await message_or_query.answer() 
        except TelegramBadRequest as e_tbr: # Используем импортированный TelegramBadRequest
            if "message is not modified" in str(e_tbr).lower():
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение админ-панели не было изменено (поймано исключение TelegramBadRequest).")
                await message_or_query.answer()
            else:
                logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка редактирования сообщения для админ-панели: {e_tbr}")
                if isinstance(message_or_query, types.CallbackQuery): 
                    try:
                        await message_or_query.bot.send_message(user_id, text, reply_markup=keyboard)
                        await message_or_query.message.delete() 
                        await message_or_query.answer()
                    except Exception as e_send_new:
                        logger.error(f"[{MODULE_NAME_FOR_LOG}] Не удалось отправить новое сообщение после ошибки редактирования: {e_send_new}")
                        await message_or_query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)
                else: 
                    await message_or_query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)
        except Exception as e:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Непредвиденная ошибка при отправке меню админ-панели: {e}", exc_info=True)
            if isinstance(message_or_query, types.CallbackQuery):
                await message_or_query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)


@admin_entry_router.message(Command("admin"))
async def cmd_admin_panel_main(message: types.Message, services_provider: 'BotServicesProvider'):
    user_id = message.from_user.id 
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_id} (с правами) вошел в админ-панель через команду /admin.")
    await send_admin_main_menu(message, services_provider)

@admin_entry_router.callback_query(CoreMenuNavigate.filter(F.target_menu == "admin_panel_main"))
async def cq_core_nav_to_admin_panel_main(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_id} (с правами) вошел в админ-панель через главное меню SDB.")
    await send_admin_main_menu(query, services_provider)

@admin_entry_router.callback_query(AdminMainMenuNavigate.filter(F.target_section == "main_admin"))
async def cq_admin_nav_to_main_admin_menu(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_id} вернулся в главное меню админ-панели.")
    await send_admin_main_menu(query, services_provider)

@admin_entry_router.callback_query(AdminMainMenuNavigate.filter(F.target_section == "users"))
async def cq_admin_main_to_users_list(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider'
):
    from core.admin.users.handlers_list import cq_admin_users_list_entry
    from core.ui.callback_data_factories import AdminUsersPanelNavigate 
    await cq_admin_users_list_entry(query, AdminUsersPanelNavigate(action="list", page=1), services_provider)

@admin_entry_router.callback_query(AdminMainMenuNavigate.filter(F.target_section == "roles"))
async def cq_admin_main_to_roles_list(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider',
    bot: Bot 
):
    from core.admin.roles.handlers_list import cq_admin_roles_list_entry
    from core.ui.callback_data_factories import AdminRolesPanelNavigate 
    await cq_admin_roles_list_entry(query, AdminRolesPanelNavigate(action="list"), services_provider, bot)

@admin_entry_router.callback_query(AdminMainMenuNavigate.filter(F.target_section == "sys_info"))
async def cq_admin_main_to_sys_info(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider',
    bot: Bot
):
    from core.admin.sys_info.handlers_sys_info import cq_admin_show_system_info_entry
    from core.ui.callback_data_factories import AdminSysInfoPanelNavigate 
    await cq_admin_show_system_info_entry(query, AdminSysInfoPanelNavigate(action="show"), services_provider, bot)

@admin_entry_router.callback_query(AdminMainMenuNavigate.filter(F.target_section == "modules"))
async def cq_admin_main_to_modules(query: types.CallbackQuery, services_provider: 'BotServicesProvider'):
    await query.answer("Раздел 'Управление модулями' в разработке.", show_alert=True)


======================================================================

------------------------------ FILE: core/admin/entry/__init__.py ------------------------------
# core/admin/entry/__init__.py
from aiogram import Router

# Импортируем "конечный" роутер
from .handlers_entry import admin_entry_router

# Создаем "собирающий" роутер для раздела
section_entry_router = Router(name="sdb_admin_section_entry_router")
section_entry_router.include_router(admin_entry_router)

__all__ = ["section_entry_router"]


======================================================================

------------------------------ FILE: core/admin/users/handlers_details.py ------------------------------
# core/admin/users/handlers_details.py
from aiogram import Router, types, F
from aiogram.utils.markdown import hbold, hcode
from loguru import logger
from sqlalchemy.orm import selectinload
from aiogram.exceptions import TelegramBadRequest # <--- ИСПРАВЛЕН ИМПОРТ

from core.ui.callback_data_factories import AdminUsersPanelNavigate
from .keyboards_users import get_admin_user_details_keyboard_local, USERS_MGMT_TEXTS 
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS 
from core.admin.filters_admin import can_view_admin_panel_filter
from core.rbac.service import PERMISSION_CORE_USERS_VIEW_DETAILS, PERMISSION_CORE_USERS_MANAGE_STATUS
from core.database.core_models import User as DBUser

from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession

user_details_router = Router(name="sdb_admin_user_details_handlers")
MODULE_NAME_FOR_LOG = "AdminUserDetails"

#user_details_router.callback_query.filter(can_view_admin_panel_filter)

async def _send_or_edit_user_details_local( 
    query: types.CallbackQuery, 
    target_user: DBUser, 
    services_provider: 'BotServicesProvider', 
    session: 'AsyncSession', 
    admin_tg_id: int
):
    target_user_is_owner = target_user.telegram_id in services_provider.config.core.super_admins
    
    roles_display_str: str
    if target_user_is_owner:
        roles_display_str = USERS_MGMT_TEXTS["user_is_owner_text"]
    elif target_user.roles:
        roles_display_str = ", ".join(sorted([role.name for role in target_user.roles]))
    else:
        roles_display_str = "нет"

    text_parts = [
        f"👤 {hbold(USERS_MGMT_TEXTS['user_details_title'])}: {target_user.full_name}",
        f"   Telegram ID: {hcode(str(target_user.telegram_id))}",
        f"   DB ID: {hcode(str(target_user.id))}",
        f"   Username: {hcode(f'@{target_user.username}') if target_user.username else '-'}",
        f"   Имя: {hcode(target_user.first_name or '-')}",
        f"   Фамилия: {hcode(target_user.last_name or '-')}",
        f"   Язык: {hcode(target_user.preferred_language_code or '-')}",
        f"   Активен: {'Да ✅' if target_user.is_active else 'Нет 💤'}",
        f"   Бот заблокирован: {'Да 🚫' if target_user.is_bot_blocked else 'Нет ✅'}",
        f"   Роли/Статус: {hbold(roles_display_str)}",
        f"   Регистрация: {target_user.created_at.strftime('%Y-%m-%d %H:%M') if target_user.created_at else '-'}",
        f"   Посл. активность: {target_user.last_activity_at.strftime('%Y-%m-%d %H:%M') if target_user.last_activity_at else '-'}",
    ]
    text = "\n".join(text_parts)
    keyboard = await get_admin_user_details_keyboard_local(target_user, services_provider, admin_tg_id, session)

    if query.message:
        try:
            if query.message.text != text or query.message.reply_markup != keyboard:
                await query.message.edit_text(text, reply_markup=keyboard)
            else:
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение деталей пользователя ({target_user.id}) не было изменено.")
        except TelegramBadRequest as e_tbr: # Используем импортированный TelegramBadRequest
            if "message is not modified" in str(e_tbr).lower():
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение деталей пользователя ({target_user.id}) не было изменено (поймано исключение).")
            else:
                logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка редактирования деталей пользователя ({target_user.id}): {e_tbr}")
        except Exception as e_edit:
            logger.error(f"[{MODULE_NAME_FOR_LOG}] Непредвиденная ошибка в _send_or_edit_user_details_local для пользователя {target_user.id}: {e_edit}", exc_info=True)


@user_details_router.callback_query(AdminUsersPanelNavigate.filter(F.action == "view"))
async def cq_admin_user_view_details_entry( 
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate, 
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    target_user_db_id: Optional[int] = None

    if callback_data.item_id is not None:
        try: target_user_db_id = int(str(callback_data.item_id))
        except ValueError:
            await query.answer("Ошибка: неверный формат ID пользователя.", show_alert=True); return
    
    if target_user_db_id is None:
        await query.answer("Ошибка: ID пользователя не указан.", show_alert=True); return
        
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} запросил детали пользователя с DB ID: {target_user_db_id}")

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_VIEW_DETAILS):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return

        target_user = await session.get(DBUser, target_user_db_id, options=[selectinload(DBUser.roles)])
        
        if not target_user:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return
        
        await _send_or_edit_user_details_local(query, target_user, services_provider, session, admin_user_id)
    await query.answer() 

@user_details_router.callback_query(AdminUsersPanelNavigate.filter(F.action == "toggle_active"))
async def cq_admin_user_toggle_active_details( 
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate, 
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    target_user_db_id: Optional[int] = None
    if callback_data.item_id is not None:
        try: target_user_db_id = int(str(callback_data.item_id))
        except ValueError: pass
    
    if target_user_db_id is None:
        await query.answer("Ошибка: ID пользователя не указан.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} изменяет статус активности для пользователя DB ID: {target_user_db_id}")

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_MANAGE_STATUS):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return

        target_user = await session.get(DBUser, target_user_db_id, options=[selectinload(DBUser.roles)])
        if not target_user:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return
        
        if target_user.telegram_id in services_provider.config.core.super_admins:
            await query.answer("Нельзя изменять статус Владельца системы.", show_alert=True)
            await _send_or_edit_user_details_local(query, target_user, services_provider, session, admin_user_id)
            return

        new_status = not target_user.is_active
        changed = await services_provider.user_service.set_user_active_status(target_user, new_status, session)
        alert_text = ""
        if changed:
            try:
                await session.commit()
                alert_text = f"Статус активности {target_user.full_name} изменен на: {'Активен ✅' if new_status else 'Неактивен 💤'}"
                logger.info(f"[{MODULE_NAME_FOR_LOG}] {alert_text}")
            except Exception as e_commit:
                await session.rollback()
                alert_text = "Ошибка сохранения изменений."
        else:
            alert_text = "Статус активности не был изменен."
        await _send_or_edit_user_details_local(query, target_user, services_provider, session, admin_user_id)
        await query.answer(alert_text, show_alert=bool(changed and "Ошибка" not in alert_text)) 

@user_details_router.callback_query(AdminUsersPanelNavigate.filter(F.action == "toggle_blocked"))
async def cq_admin_user_toggle_blocked_details( 
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate, 
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    target_user_db_id: Optional[int] = None
    if callback_data.item_id is not None:
        try: target_user_db_id = int(str(callback_data.item_id))
        except ValueError: pass
    if target_user_db_id is None:
        await query.answer("Ошибка: ID пользователя не указан.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} изменяет статус блокировки для пользователя DB ID: {target_user_db_id}")

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_MANAGE_STATUS):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return

        target_user = await session.get(DBUser, target_user_db_id, options=[selectinload(DBUser.roles)])
        if not target_user:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return
        if target_user.telegram_id in services_provider.config.core.super_admins:
            await query.answer("Нельзя изменять статус блокировки Владельца системы.", show_alert=True)
            await _send_or_edit_user_details_local(query, target_user, services_provider, session, admin_user_id)
            return

        new_status = not target_user.is_bot_blocked
        changed = await services_provider.user_service.set_user_bot_blocked_status(target_user, new_status, session)
        alert_text = ""
        if changed:
            try:
                await session.commit()
                alert_text = f"Блокировка для {target_user.full_name} изменена на: {'Заблокировал 🚫' if new_status else 'Не блокировал ✅'}"
            except Exception as e_commit: await session.rollback(); alert_text = "Ошибка сохранения."
        else: alert_text = "Статус блокировки не изменен."
        await _send_or_edit_user_details_local(query, target_user, services_provider, session, admin_user_id)
        await query.answer(alert_text, show_alert=bool(changed and "Ошибка" not in alert_text))


======================================================================

------------------------------ FILE: core/admin/users/handlers_list.py ------------------------------
# core/admin/users/handlers_list.py
from aiogram import Router, types, F
from aiogram.utils.markdown import hbold
from loguru import logger
from sqlalchemy import select, func as sql_func # <--- ИСПРАВЛЕН ИМПОРТ func

from core.ui.callback_data_factories import AdminUsersPanelNavigate
from .keyboards_users import get_admin_users_list_keyboard_local, USERS_MGMT_TEXTS 
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS 
from core.admin.filters_admin import can_view_admin_panel_filter
from core.rbac.service import PERMISSION_CORE_USERS_VIEW_LIST
from core.database.core_models import User as DBUser

from typing import TYPE_CHECKING, List
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider

users_list_router = Router(name="sdb_admin_users_list_handlers")
MODULE_NAME_FOR_LOG = "AdminUserList"

#users_list_router.callback_query.filter(can_view_admin_panel_filter)

USERS_PER_PAGE_ADMIN_LOCAL = 10 

@users_list_router.callback_query(AdminUsersPanelNavigate.filter(F.action == "list"))
async def cq_admin_users_list_entry( 
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate, 
    services_provider: 'BotServicesProvider' 
):
    admin_user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} запросил список пользователей, страница: {callback_data.page or 1}")

    async with services_provider.db.get_session() as session: 
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins: 
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_VIEW_LIST):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True)
                return
        
        current_page = callback_data.page if callback_data.page is not None else 1
        
        total_users = 0
        try:
            count_stmt = select(sql_func.count(DBUser.id)) 
            total_users_res = await session.execute(count_stmt)
            total_users = total_users_res.scalar_one_or_none() or 0
        except Exception as e_count:
            logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка подсчета пользователей: {e_count}")
            await query.answer("Ошибка получения данных о пользователях.", show_alert=True)
            return
        
        total_pages = (total_users + USERS_PER_PAGE_ADMIN_LOCAL - 1) // USERS_PER_PAGE_ADMIN_LOCAL
        total_pages = max(1, total_pages) 
        current_page = max(1, min(current_page, total_pages))
        offset = (current_page - 1) * USERS_PER_PAGE_ADMIN_LOCAL

        stmt_users = (
            select(DBUser)
            .order_by(DBUser.id.desc()) 
            .limit(USERS_PER_PAGE_ADMIN_LOCAL)
            .offset(offset)
        )
        users_result = await session.execute(stmt_users)
        users_on_page: List[DBUser] = list(users_result.scalars().all())

        text = USERS_MGMT_TEXTS["user_list_title_template"].format(current_page=current_page, total_pages=total_pages)
        if total_users == 0 : 
             text = "👥 Пользователи\n\nВ базе данных нет зарегистрированных пользователей."

        keyboard = await get_admin_users_list_keyboard_local(users_on_page, total_pages, current_page)

        if query.message:
            try:
                if query.message.text != text or query.message.reply_markup != keyboard:
                    await query.message.edit_text(text, reply_markup=keyboard)
                else:
                    logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение списка пользователей не изменено.")
                await query.answer()
            except types.TelegramBadRequest as e_tbr:
                if "message is not modified" in str(e_tbr).lower():
                    logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение списка пользователей не изменено (поймано исключение).")
                    await query.answer()
                else:
                    logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка редактирования списка пользователей: {e_tbr}")
                    await query.answer() 
            except Exception as e_edit:
                logger.error(f"[{MODULE_NAME_FOR_LOG}] Непредвиденная ошибка в cq_admin_users_list_entry: {e_edit}", exc_info=True)
                await query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)


======================================================================

------------------------------ FILE: core/admin/users/handlers_direct_perms.py ------------------------------
# core/admin/users/handlers_direct_perms.py
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.utils.markdown import hbold
from loguru import logger
from sqlalchemy.orm import selectinload
from aiogram.filters import StateFilter # Импортируем StateFilter
from aiogram.exceptions import TelegramBadRequest # Импортируем TelegramBadRequest

from core.ui.callback_data_factories import AdminUsersPanelNavigate
from .keyboards_users import get_user_direct_perms_keyboard, USERS_MGMT_TEXTS 
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS 
from core.admin.filters_admin import can_view_admin_panel_filter
from core.rbac.service import PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS 
from core.database.core_models import User as DBUser, Permission as DBPermission, Role as DBRole # Добавил DBRole

from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession

user_direct_perms_router = Router(name="sdb_admin_user_direct_perms_handlers")
MODULE_NAME_FOR_LOG = "AdminUserDirectPerms"

#user_direct_perms_router.callback_query.filter(can_view_admin_panel_filter)

# --- FSM для навигации по прямым разрешениям пользователя ---
class FSMDirectUserPermsNavigation(StatesGroup):
    navigating_direct_perms = State()

# --- Вход в FSM для управления прямыми разрешениями ---
@user_direct_perms_router.callback_query(AdminUsersPanelNavigate.filter(F.action == "edit_direct_perms_start"))
async def cq_admin_user_edit_direct_perms_entry( # Переименовано для консистентности
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate,
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    admin_user_id = query.from_user.id
    target_user_db_id = callback_data.item_id

    if target_user_db_id is None:
        await query.answer("Ошибка: ID пользователя не указан.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} входит в FSM управления прямыми правами для User DB ID: {target_user_db_id}")

    async with services_provider.db.get_session() as session:
        current_admin_is_owner = admin_user_id in services_provider.config.core.super_admins
        if not current_admin_is_owner and \
           not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS):
            await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True)
            return
        
        target_user = await session.get(DBUser, target_user_db_id)
        if not target_user:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return
        if target_user.telegram_id in services_provider.config.core.super_admins:
            await query.answer("Нельзя управлять прямыми разрешениями Владельца системы.", show_alert=True); return

    await state.clear() 
    await state.set_state(FSMDirectUserPermsNavigation.navigating_direct_perms)
    await state.update_data(
        target_user_id_for_perms=target_user_db_id, 
    )
    
    await _show_user_direct_perms_menu(query, services_provider, state)

# --- Навигация по категориям/сущностям/страницам прямых разрешений ---
@user_direct_perms_router.callback_query(
    AdminUsersPanelNavigate.filter(F.action == "direct_perms_nav"),
    StateFilter(FSMDirectUserPermsNavigation.navigating_direct_perms)
)
async def cq_admin_user_direct_perms_navigate(
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate,
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    fsm_data = await state.get_data()
    target_user_db_id = fsm_data.get("target_user_id_for_perms")
    if target_user_db_id is None: 
        await query.answer("Ошибка состояния FSM. Попробуйте выйти и войти снова.", show_alert=True)
        await state.clear(); return

    new_fsm_context_data = {
        "category_key": callback_data.category_key,
        "entity_name": callback_data.entity_name,
        "current_page": callback_data.page or 1
    }
    await state.update_data(**new_fsm_context_data)
    
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {query.from_user.id} навигация по прямым правам (User ID: {target_user_db_id}). "
                f"Новый FSM контекст навигации: {new_fsm_context_data}")
    
    await _show_user_direct_perms_menu(query, services_provider, state)

# --- Переключение прямого разрешения для пользователя ---
@user_direct_perms_router.callback_query(
    AdminUsersPanelNavigate.filter(F.action == "toggle_direct_perm"),
    StateFilter(FSMDirectUserPermsNavigation.navigating_direct_perms)
)
async def cq_admin_user_toggle_direct_perm(
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate,
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    admin_user_id = query.from_user.id
    fsm_data = await state.get_data()
    target_user_db_id: Optional[int] = fsm_data.get("target_user_id_for_perms")
    permission_to_toggle_id: Optional[int] = callback_data.permission_id

    if target_user_db_id is None or permission_to_toggle_id is None:
        await query.answer("Ошибка: неверные данные для изменения разрешения.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} изменяет прямое разрешение "
                f"PermID:'{permission_to_toggle_id}' для User DBID:{target_user_db_id}")

    async with services_provider.db.get_session() as session:
        current_admin_is_owner = admin_user_id in services_provider.config.core.super_admins
        if not current_admin_is_owner and \
           not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS):
            await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return
        
        target_user = await session.get(DBUser, target_user_db_id, options=[selectinload(DBUser.direct_permissions)])
        permission_to_modify = await session.get(DBPermission, permission_to_toggle_id)

        if not target_user or not permission_to_modify:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return
        if target_user.telegram_id in services_provider.config.core.super_admins: 
            await query.answer("Нельзя изменять прямые разрешения Владельца.", show_alert=True); return

        user_has_direct_perm = permission_to_modify in target_user.direct_permissions
        alert_text, action_performed = "", False

        if user_has_direct_perm:
            if await services_provider.rbac.remove_direct_permission_from_user(session, target_user, permission_to_modify.name):
                action_performed = True
                alert_text = f"Прямое разрешение '{permission_to_modify.name}' снято."
            else: alert_text = f"Не удалось снять прямое разрешение '{permission_to_modify.name}'."
        else:
            if await services_provider.rbac.assign_direct_permission_to_user(session, target_user, permission_to_modify.name, auto_create_perm=False):
                action_performed = True
                alert_text = f"Прямое разрешение '{permission_to_modify.name}' назначено."
            else: alert_text = f"Не удалось назначить прямое разрешение '{permission_to_modify.name}'."
        
        if action_performed:
            try: await session.commit(); logger.info(f"[{MODULE_NAME_FOR_LOG}] {alert_text} для User ID: {target_user.id}"); await session.refresh(target_user, attribute_names=['direct_permissions'])
            except Exception as e: await session.rollback(); logger.error(f"Ошибка commit: {e}"); alert_text = "Ошибка сохранения."
        
        await query.answer(alert_text, show_alert=action_performed and "Не удалось" not in alert_text)
        await _show_user_direct_perms_menu(query, services_provider, state) 

# --- Вспомогательная функция для отображения меню прямых разрешений ---
async def _show_user_direct_perms_menu(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider', 
    state: FSMContext
):
    admin_user_id = query.from_user.id
    fsm_data = await state.get_data()
    
    target_user_db_id = fsm_data.get("target_user_id_for_perms")
    category_key = fsm_data.get("category_key")
    entity_name = fsm_data.get("entity_name")
    page = fsm_data.get("current_page", 1)

    if target_user_db_id is None:
        await query.answer("Ошибка состояния FSM (ID пользователя).", show_alert=True); await state.clear(); return

    async with services_provider.db.get_session() as session:
        target_user = await session.get(DBUser, target_user_db_id, options=[
            selectinload(DBUser.direct_permissions), 
            selectinload(DBUser.roles).selectinload(DBRole.permissions) 
        ])
        if not target_user:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); await state.clear(); return

        all_system_permissions = await services_provider.rbac.get_all_permissions(session)
        
        base_text = USERS_MGMT_TEXTS["edit_direct_perms_for_user"].format(user_name=hbold(target_user.full_name))
        current_level_text = ""
        if category_key == "core":
            current_level_text = " / Ядро"
            if entity_name: current_level_text += f" / {ADMIN_COMMON_TEXTS.get(f'perm_core_group_{entity_name}', entity_name.capitalize())}"
        elif category_key == "module":
            current_level_text = " / Модули"
            if entity_name:
                mod_info = services_provider.modules.get_module_info(entity_name)
                current_level_text += f" / {mod_info.manifest.display_name if mod_info and mod_info.manifest else entity_name}"
        
        text = f"{base_text}{current_level_text}\nОтметьте прямые разрешения:"
        
        keyboard = await get_user_direct_perms_keyboard(
            target_user=target_user, 
            all_system_permissions=all_system_permissions, 
            services=services_provider, 
            current_admin_tg_id=admin_user_id, 
            session=session,
            category_key=category_key, entity_name=entity_name, page=page
        )

        if query.message:
            try:
                if query.message.text != text or query.message.reply_markup != keyboard:
                    await query.message.edit_text(text, reply_markup=keyboard)
            except TelegramBadRequest as e: # Используем импортированный TelegramBadRequest
                if "message is not modified" not in str(e).lower(): 
                    logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка edit_text (_show_user_direct_perms_menu): {e}")
            except Exception as e_edit:
                logger.error(f"Непредвиденная ошибка в _show_user_direct_perms_menu: {e_edit}", exc_info=True)
                if query.message: await query.answer("Ошибка отображения.", show_alert=True)

# Выход из FSM управления прямыми правами (если пользователь нажимает "К деталям пользователя")
@user_direct_perms_router.callback_query(
    AdminUsersPanelNavigate.filter(F.action == "view"), 
    StateFilter(FSMDirectUserPermsNavigation.navigating_direct_perms) 
)
async def cq_back_to_user_details_from_direct_perms_fsm(
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate, 
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    await state.clear() 
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {query.from_user.id} вышел из FSM управления прямыми разрешениями.")
    from .handlers_details import cq_admin_user_view_details_entry
    await cq_admin_user_view_details_entry(query, callback_data, services_provider)


======================================================================

------------------------------ FILE: core/admin/users/keyboards_users.py ------------------------------
# SwiftDevBot/core/admin/users/keyboards_users.py
from typing import TYPE_CHECKING, List, Set, Dict, Optional
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from loguru import logger

from core.ui.callback_data_factories import AdminUsersPanelNavigate, AdminMainMenuNavigate
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS, get_back_to_admin_main_menu_button
from core.rbac.service import (
    PERMISSION_CORE_USERS_ASSIGN_ROLES, 
    PERMISSION_CORE_USERS_MANAGE_STATUS,
    PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS, # <--- ДОБАВЛЕН ИМПОРТ
    DEFAULT_ROLE_USER 
)

if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession
    from core.database.core_models import User as DBUser, Role as DBRole, Permission as DBPermission


USERS_MGMT_TEXTS = {
    "user_list_title_template": ADMIN_COMMON_TEXTS.get("user_list_title_template", "Пользователи (Стр. {current_page}/{total_pages})"),
    "user_details_title": ADMIN_COMMON_TEXTS.get("user_details_title", "Информация о пользователе"),
    "user_action_change_roles": ADMIN_COMMON_TEXTS.get("user_action_change_roles", "Изменить роли"),
    "user_action_toggle_active": ADMIN_COMMON_TEXTS.get("user_action_toggle_active", "Активность: {status}"),
    "user_action_toggle_blocked": ADMIN_COMMON_TEXTS.get("user_action_toggle_blocked", "Блокировка: {status}"),
    "edit_roles_for_user": ADMIN_COMMON_TEXTS.get("edit_roles_for_user", "Изменение ролей для: {user_name}"),
    "back_to_user_details": ADMIN_COMMON_TEXTS.get("back_to_user_details", "⬅️ К деталям пользователя"),
    "user_is_owner_text": ADMIN_COMMON_TEXTS.get("user_is_owner_text", "👑 Владелец системы (неизменяемый)"),
    "user_action_direct_perms": "💎 Индивидуальные разрешения",
    # Тексты для управления прямыми разрешениями пользователя
    "edit_direct_perms_for_user": "💎 Индивидуальные разрешения для: {user_name}",
    "perm_status_direct": "✅ (прямое)",
    "perm_status_role": "☑️ (через роль)",
    "perm_status_none": "⬜ (нет)",
    "back_to_direct_perm_categories": "⬅️ К категориям разрешений (для юзера)",
    "back_to_direct_perm_core_groups": "⬅️ К группам Ядра (для юзера)",
    "back_to_direct_perm_module_list": "⬅️ К модулям (для юзера)",
}


async def get_admin_users_list_keyboard_local( 
    users_on_page: List['DBUser'],
    total_pages: int,
    current_page: int,
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    if not users_on_page and current_page == 1:
        builder.button(text="Нет пользователей для отображения", callback_data=AdminUsersPanelNavigate(action="dummy_no_users").pack())
    else:
        for user_obj in users_on_page:
            user_display = f"{user_obj.full_name}"
            if user_obj.username: user_display += f" (@{user_obj.username})"
            else: user_display += f" (ID: {user_obj.telegram_id})"
            
            status_icons = ["💤" if not user_obj.is_active else "", "🚫" if user_obj.is_bot_blocked else ""]
            status_prefix = "".join(filter(None, status_icons)) + " " if any(status_icons) else ""

            builder.button(
                text=f"{status_prefix}{user_display}",
                callback_data=AdminUsersPanelNavigate(action="view", item_id=user_obj.id).pack()
            )
        builder.adjust(1)

    if total_pages > 1:
        pagination_row = []
        if current_page > 1:
            pagination_row.append(InlineKeyboardButton(
                text=ADMIN_COMMON_TEXTS["pagination_prev"],
                callback_data=AdminUsersPanelNavigate(action="list", page=current_page - 1).pack()
            ))
        pagination_row.append(InlineKeyboardButton(
            text=f"{current_page}/{total_pages}",
            callback_data=AdminUsersPanelNavigate(action="dummy_page").pack() 
        ))
        if current_page < total_pages:
            pagination_row.append(InlineKeyboardButton(
                text=ADMIN_COMMON_TEXTS["pagination_next"],
                callback_data=AdminUsersPanelNavigate(action="list", page=current_page + 1).pack()
            ))
        if pagination_row:
            builder.row(*pagination_row)

    builder.row(get_back_to_admin_main_menu_button())
    return builder.as_markup()


async def get_admin_user_details_keyboard_local( 
    target_user: 'DBUser', 
    services: 'BotServicesProvider',
    current_admin_tg_id: int, 
    session: 'AsyncSession'
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    rbac = services.rbac
    current_admin_is_owner = current_admin_tg_id in services.config.core.super_admins
    target_user_is_owner = target_user.telegram_id in services.config.core.super_admins

    # --- ИСПРАВЛЕНИЕ УСЛОВИЯ ОТОБРАЖЕНИЯ КНОПКИ "Индивидуальные разрешения" ---
    can_manage_direct_perms = False
    if not target_user_is_owner: # Нельзя управлять правами владельца
        if current_admin_is_owner: # Владелец конфига может всё (кроме прав других владельцев)
            can_manage_direct_perms = True
        else:
            # Проверяем разрешение PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS
            if await rbac.user_has_permission(session, current_admin_tg_id, PERMISSION_CORE_USERS_MANAGE_DIRECT_PERMISSIONS):
                can_manage_direct_perms = True
    
    if can_manage_direct_perms:
    # --- КОНЕЦ ИСПРАВЛЕНИЯ ---
        builder.button(
            text=USERS_MGMT_TEXTS["user_action_direct_perms"],
            callback_data=AdminUsersPanelNavigate(action="edit_direct_perms_start", item_id=target_user.id).pack()
        )

    if not target_user_is_owner: 
        if current_admin_is_owner or \
           await rbac.user_has_permission(session, current_admin_tg_id, PERMISSION_CORE_USERS_ASSIGN_ROLES):
            builder.button(
                text=USERS_MGMT_TEXTS["user_action_change_roles"],
                callback_data=AdminUsersPanelNavigate(action="edit_roles_start", item_id=target_user.id).pack()
            )

        if current_admin_is_owner or \
           await rbac.user_has_permission(session, current_admin_tg_id, PERMISSION_CORE_USERS_MANAGE_STATUS):
            active_status_text = "Выкл 💤" if target_user.is_active else "Вкл ✅" 
            builder.button(
                text=USERS_MGMT_TEXTS["user_action_toggle_active"].format(status=active_status_text),
                callback_data=AdminUsersPanelNavigate(action="toggle_active", item_id=target_user.id).pack()
            )
            blocked_status_text = "Да 🚫" if target_user.is_bot_blocked else "Нет ✅" 
            builder.button(
                text=USERS_MGMT_TEXTS["user_action_toggle_blocked"].format(status=blocked_status_text),
                callback_data=AdminUsersPanelNavigate(action="toggle_blocked", item_id=target_user.id).pack()
            )
    
    if builder.export(): 
        builder.adjust(1)

    builder.row(InlineKeyboardButton(
        text="⬅️ К списку пользователей",
        callback_data=AdminUsersPanelNavigate(action="list", page=1).pack() 
    ))
    builder.row(get_back_to_admin_main_menu_button())
    return builder.as_markup()

async def get_admin_user_edit_roles_keyboard_local( 
    target_user: 'DBUser',
    all_system_roles: List['DBRole'],
    services: 'BotServicesProvider',
    current_admin_tg_id: int,
    session: 'AsyncSession'
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    rbac = services.rbac
    current_admin_is_owner = current_admin_tg_id in services.config.core.super_admins

    target_user_role_ids: Set[int] = {role.id for role in target_user.roles if role.id is not None}

    for role in sorted(all_system_roles, key=lambda r: r.name):
        if role.id is None: continue 

        is_assigned = role.id in target_user_role_ids
        prefix = "✅ " if is_assigned else "⬜ "
        
        can_toggle_this_role = False
        if current_admin_is_owner:
            can_toggle_this_role = True
        elif await rbac.user_has_permission(session, current_admin_tg_id, PERMISSION_CORE_USERS_ASSIGN_ROLES):
            if role.name == DEFAULT_ROLE_USER and is_assigned and len(target_user.roles) == 1:
                can_toggle_this_role = False
                prefix = "🔒 " 
            else:
                can_toggle_this_role = True
        
        if can_toggle_this_role:
            builder.button(
                text=f"{prefix}{role.name}",
                callback_data=AdminUsersPanelNavigate(
                    action="toggle_role", 
                    item_id=target_user.id, 
                    role_id=role.id 
                ).pack()
            )
        else: 
            builder.button(
                text=f"{prefix}{role.name} (нет прав)", 
                callback_data=AdminUsersPanelNavigate(action="dummy_cant_toggle").pack() 
            )

    builder.adjust(1)
    builder.row(InlineKeyboardButton(
        text=USERS_MGMT_TEXTS["back_to_user_details"], 
        callback_data=AdminUsersPanelNavigate(action="view", item_id=target_user.id).pack()
    ))
    return builder.as_markup()

# --- Новая клавиатура для управления прямыми разрешениями пользователя ---
async def get_user_direct_perms_keyboard(
    target_user: 'DBUser', # Пользователь, чьи права редактируются
    services: 'BotServicesProvider',
    current_admin_tg_id: int, # Админ, который редактирует
    session: 'AsyncSession',
    all_system_permissions: List['DBPermission'], # Все разрешения в системе
    # Параметры из FSM для навигации:
    category_key: Optional[str] = None,
    entity_name: Optional[str] = None,
    page: int = 1,
    perms_per_page: int = 7 
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = USERS_MGMT_TEXTS 
    
    user_direct_perm_ids: Set[int] = {perm.id for perm in target_user.direct_permissions if perm.id is not None}
    user_role_perm_ids: Set[int] = set()
    for role in target_user.roles:
        if role.permissions:
            user_role_perm_ids.update(p.id for p in role.permissions if p.id is not None)

    # Кнопка "Назад к деталям пользователя"
    builder.row(InlineKeyboardButton(
        text=texts["back_to_user_details"],
        callback_data=AdminUsersPanelNavigate(action="view", item_id=target_user.id).pack()
    ))

    # --- Уровень 1: Выбор основной категории разрешений (Ядро / Модули) ---
    if not category_key:
        builder.button(
            text=ADMIN_COMMON_TEXTS["perm_category_core"], # Используем общие тексты для категорий
            callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id, category_key="core", page=1).pack()
        )
        module_perms_exist = any(not p.name.startswith("core.") for p in all_system_permissions)
        if module_perms_exist:
            builder.button(
                text=ADMIN_COMMON_TEXTS["perm_category_modules"],
                callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id, category_key="module", page=1).pack()
            )
        builder.adjust(1)
        return builder.as_markup()

    # --- Уровень 2 и 3: Выбор подкатегории/модуля и отображение разрешений ---
    permissions_to_display_final: List['DBPermission'] = []
    
    if category_key == "core":
        CORE_PERM_GROUPS_MAP_USERS: Dict[str, str] = { # Локальные тексты, т.к. могут отличаться от ролей
            "users": USERS_MGMT_TEXTS.get("perm_core_group_users", "Пользователи (Ядро)"), 
            "roles": USERS_MGMT_TEXTS.get("perm_core_group_roles", "Роли (Ядро)"),
            # ... и так далее, копируем из ADMIN_COMMON_TEXTS или определяем здесь
            "modules_core": ADMIN_COMMON_TEXTS["perm_core_group_modules_core"], 
            "system": ADMIN_COMMON_TEXTS["perm_core_group_system"],
            "settings_core": ADMIN_COMMON_TEXTS["perm_core_group_settings_core"], 
            "other": ADMIN_COMMON_TEXTS["perm_core_group_other"]
        }
        CORE_PERM_PREFIXES_MAP_USERS: Dict[str, str] = { # Аналогично
            "users": "core.users.", "roles": "core.roles.", "modules_core": "core.modules.",
            "system": "core.system.", "settings_core": "core.settings."
        }

        if not entity_name: # Показываем подкатегории ядра
            for group_key, group_display_name in CORE_PERM_GROUPS_MAP_USERS.items():
                prefix_to_check = CORE_PERM_PREFIXES_MAP_USERS.get(group_key)
                has_perms_in_group = False
                if prefix_to_check:
                    if any(p.name.startswith(prefix_to_check) for p in all_system_permissions): has_perms_in_group = True
                elif group_key == "other": 
                    known_prefixes = list(CORE_PERM_PREFIXES_MAP_USERS.values())
                    if any(p.name.startswith("core.") and not any(p.name.startswith(kp) for kp in known_prefixes) for p in all_system_permissions): has_perms_in_group = True
                if has_perms_in_group:
                    builder.button(text=group_display_name, callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id, category_key="core", entity_name=group_key, page=1).pack())
            builder.adjust(1)
            builder.row(InlineKeyboardButton(text=texts["back_to_direct_perm_categories"], callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id).pack()))
        else: # Показываем разрешения для выбранной подкатегории ядра
            if entity_name == "other":
                known_prefixes = list(CORE_PERM_PREFIXES_MAP_USERS.values())
                permissions_to_display_final = [p for p in all_system_permissions if p.name.startswith("core.") and not any(p.name.startswith(kp) for kp in known_prefixes)]
            elif entity_name in CORE_PERM_PREFIXES_MAP_USERS:
                prefix = CORE_PERM_PREFIXES_MAP_USERS[entity_name]
                permissions_to_display_final = [p for p in all_system_permissions if p.name.startswith(prefix)]
            builder.row(InlineKeyboardButton(text=texts["back_to_direct_perm_core_groups"], callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id, category_key="core").pack()))

    elif category_key == "module":
        if not services.modules: 
            builder.button(text="Ошибка: Загрузчик модулей недоступен.", callback_data="dummy_error_no_module_loader"); return builder.as_markup()
        module_permissions_map: Dict[str, List['DBPermission']] = {}
        module_display_names: Dict[str, str] = {}
        for p in all_system_permissions:
            if not p.name.startswith("core."):
                module_name_candidate = p.name.split('.')[0]
                if module_name_candidate not in module_permissions_map:
                    module_permissions_map[module_name_candidate] = []
                    mod_info = services.modules.get_module_info(module_name_candidate)
                    module_display_names[module_name_candidate] = mod_info.manifest.display_name if mod_info and mod_info.manifest else module_name_candidate
                module_permissions_map[module_name_candidate].append(p)
        if not entity_name: 
            sorted_module_names = sorted(module_permissions_map.keys())
            if not sorted_module_names: builder.button(text=ADMIN_COMMON_TEXTS["no_modules_with_perms"], callback_data="dummy_no_mod_perms_for_user")
            else:
                for mod_name in sorted_module_names:
                    builder.button(text=f"🧩 {module_display_names.get(mod_name, mod_name)}", callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id, category_key="module", entity_name=mod_name, page=1).pack())
            builder.adjust(1)
            builder.row(InlineKeyboardButton(text=texts["back_to_direct_perm_categories"], callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id).pack()))
        else: 
            permissions_to_display_final = module_permissions_map.get(entity_name, [])
            builder.row(InlineKeyboardButton(text=texts["back_to_direct_perm_module_list"], callback_data=AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id, category_key="module").pack()))
    
    if permissions_to_display_final:
        permissions_to_display_final.sort(key=lambda p: p.name)
        total_perms_in_list = len(permissions_to_display_final)
        total_perm_pages = (total_perms_in_list + perms_per_page - 1) // perms_per_page
        total_perm_pages = max(1, total_perm_pages)
        current_perm_page = max(1, min(page, total_perm_pages))
        start_idx = (current_perm_page - 1) * perms_per_page
        end_idx = start_idx + perms_per_page
        paginated_perms = permissions_to_display_final[start_idx:end_idx]

        if not paginated_perms and current_perm_page == 1:
            builder.button(text=ADMIN_COMMON_TEXTS["no_permissions_in_group"], callback_data="dummy_no_perms_in_group_for_user")
        else:
            for perm in paginated_perms:
                if perm.id is None: continue
                status_prefix = texts["perm_status_none"] # ⬜
                is_direct = perm.id in user_direct_perm_ids
                is_via_role = perm.id in user_role_perm_ids

                if is_direct:
                    status_prefix = texts["perm_status_direct"] # ✅
                elif is_via_role: # Не прямое, но через роль
                    status_prefix = texts["perm_status_role"] # ☑️
                
                button_text = f"{status_prefix} {perm.name}"
                
                can_toggle_locally = not (is_via_role and not is_direct)

                if can_toggle_locally:
                    builder.button(
                        text=button_text,
                        callback_data=AdminUsersPanelNavigate(
                            action="toggle_direct_perm", 
                            item_id=target_user.id, 
                            permission_id=perm.id,
                            category_key=category_key, 
                            entity_name=entity_name, 
                            page=current_perm_page
                        ).pack()
                    )
                else: 
                    builder.button(
                        text=button_text,
                        callback_data=AdminUsersPanelNavigate(action="dummy_perm_via_role").pack()
                    )
            builder.adjust(1)

            if total_perm_pages > 1:
                pagination_row_perms = []
                nav_cb_data_base = AdminUsersPanelNavigate(action="direct_perms_nav", item_id=target_user.id, category_key=category_key, entity_name=entity_name)
                if current_perm_page > 1: pagination_row_perms.append(InlineKeyboardButton(text=ADMIN_COMMON_TEXTS["pagination_prev"], callback_data=nav_cb_data_base.model_copy(update={"page": current_perm_page - 1}).pack()))
                pagination_row_perms.append(InlineKeyboardButton(text=f"{current_perm_page}/{total_perm_pages}", callback_data="dummy_direct_perm_page"))
                if current_perm_page < total_perm_pages: pagination_row_perms.append(InlineKeyboardButton(text=ADMIN_COMMON_TEXTS["pagination_next"], callback_data=nav_cb_data_base.model_copy(update={"page": current_perm_page + 1}).pack()))
                if pagination_row_perms: builder.row(*pagination_row_perms)
    elif entity_name: 
        builder.button(text=ADMIN_COMMON_TEXTS["no_permissions_in_group"], callback_data="dummy_no_perms_in_group_for_user_entity")

    builder.row(get_back_to_admin_main_menu_button())
    return builder.as_markup()

def get_admin_main_menu_keyboard_placeholder() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="Временная кнопка", callback_data="temp")
    return builder.as_markup()


======================================================================

------------------------------ FILE: core/admin/users/__init__.py ------------------------------
# SwiftDevBot/core/admin/users/__init__.py
from aiogram import Router
from loguru import logger

# --- ИСПРАВЛЕННЫЙ ИМПОРТ ---
# Импортируем фильтр из директории core/admin/, а не core/admin/users/
from ..filters_admin import can_view_admin_panel_filter # Используем .. для подъема на уровень выше

# Импортируем "конечные" роутеры из этого раздела
from .handlers_list import users_list_router
from .handlers_details import user_details_router
from .handlers_roles_assign import user_roles_assign_router
from .handlers_direct_perms import user_direct_perms_router

# Создаем один "собирающий" роутер для всего раздела "users"
section_users_router = Router(name="sdb_admin_section_users_router")

# Можно применить фильтр здесь, если он должен действовать на весь раздел users
# section_users_router.message.filter(can_view_admin_panel_filter)
# section_users_router.callback_query.filter(can_view_admin_panel_filter)
# Однако, если он уже применен к главному admin_router, это может быть избыточно,
# но не вредно. Лучше применять специфичные для раздела права здесь, если они есть.

section_users_router.include_router(users_list_router)
section_users_router.include_router(user_details_router)
section_users_router.include_router(user_roles_assign_router)
section_users_router.include_router(user_direct_perms_router)

__all__ = ["section_users_router"]


======================================================================

------------------------------ FILE: core/admin/users/handlers_roles_assign.py ------------------------------
# core/admin/users/handlers_roles_assign.py
from aiogram import Router, types, F
from aiogram.utils.markdown import hbold
from loguru import logger
from sqlalchemy.orm import selectinload
from aiogram.exceptions import TelegramBadRequest # <--- ИСПРАВЛЕН ИМПОРТ

from core.ui.callback_data_factories import AdminUsersPanelNavigate
from .keyboards_users import get_admin_user_edit_roles_keyboard_local, USERS_MGMT_TEXTS 
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS 
from core.admin.filters_admin import can_view_admin_panel_filter
from core.rbac.service import PERMISSION_CORE_USERS_ASSIGN_ROLES, DEFAULT_ROLE_USER
from core.database.core_models import User as DBUser, Role as DBRole
from .handlers_details import _send_or_edit_user_details_local

from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession

user_roles_assign_router = Router(name="sdb_admin_user_roles_assign_handlers")
MODULE_NAME_FOR_LOG = "AdminUserRolesAssign"

#user_roles_assign_router.callback_query.filter(can_view_admin_panel_filter)

@user_roles_assign_router.callback_query(AdminUsersPanelNavigate.filter(F.action == "edit_roles_start"))
async def cq_admin_user_edit_roles_start_assign( 
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate, 
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    target_user_db_id: Optional[int] = None
    if callback_data.item_id is not None:
        try: 
            target_user_db_id = int(str(callback_data.item_id))
        except ValueError:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Некорректный item_id '{callback_data.item_id}' для edit_roles_start.")
            await query.answer("Ошибка: неверный ID пользователя.", show_alert=True)
            return
    
    if target_user_db_id is None: 
        await query.answer("Ошибка: ID пользователя для редактирования ролей не указан.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} открывает интерфейс редактирования ролей для пользователя DB ID: {target_user_db_id}")

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_ASSIGN_ROLES):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return
        
        target_user = await session.get(DBUser, target_user_db_id, options=[selectinload(DBUser.roles)])
        if not target_user:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return

        if target_user.telegram_id in services_provider.config.core.super_admins:
            await query.answer("Роли Владельца системы не изменяются через этот интерфейс.", show_alert=True)
            await _send_or_edit_user_details_local(query, target_user, services_provider, session, admin_user_id)
            return

        all_system_roles = await services_provider.rbac.get_all_roles(session)
        text = USERS_MGMT_TEXTS["edit_roles_for_user"].format(user_name=hbold(target_user.full_name))
        keyboard = await get_admin_user_edit_roles_keyboard_local(target_user, all_system_roles, services_provider, admin_user_id, session)

        if query.message:
            try:
                if query.message.text != text or query.message.reply_markup != keyboard:
                    await query.message.edit_text(text, reply_markup=keyboard)
                await query.answer()
            except TelegramBadRequest as e_tbr: # Используем импортированный TelegramBadRequest
                if "message is not modified" not in str(e_tbr).lower(): await query.answer()
                else: logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка edit_text для ролей: {e_tbr}")
            except Exception as e_edit:
                logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка в cq_admin_user_edit_roles_start_assign: {e_edit}", exc_info=True)
                await query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)

@user_roles_assign_router.callback_query(AdminUsersPanelNavigate.filter(F.action == "toggle_role"))
async def cq_admin_user_toggle_role_assign( 
    query: types.CallbackQuery,
    callback_data: AdminUsersPanelNavigate, 
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    target_user_db_id: Optional[int] = None
    role_to_toggle_id: Optional[int] = None

    if callback_data.item_id is not None: 
        try: 
            target_user_db_id = int(str(callback_data.item_id))
        except ValueError: 
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Некорректный item_id '{callback_data.item_id}' для toggle_role.")
            pass 
    
    if callback_data.role_id is not None: 
        try: 
            role_to_toggle_id = int(str(callback_data.role_id))
        except ValueError: 
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Некорректный role_id '{callback_data.role_id}' для toggle_role.")
            pass 

    if target_user_db_id is None or role_to_toggle_id is None:
        logger.warning(f"[{MODULE_NAME_FOR_LOG}] Некорректные или отсутствующие ID для переключения роли: user_id={target_user_db_id}, role_id={role_to_toggle_id}")
        await query.answer("Ошибка: неверные данные для изменения роли.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} пытается изменить роль ID:{role_to_toggle_id} для пользователя DB ID:{target_user_db_id}")

    async with services_provider.db.get_session() as session:
        is_current_admin_owner = admin_user_id in services_provider.config.core.super_admins
        if not is_current_admin_owner:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_USERS_ASSIGN_ROLES):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return
        
        target_user = await session.get(DBUser, target_user_db_id, options=[selectinload(DBUser.roles)])
        role_to_modify = await session.get(DBRole, role_to_toggle_id)

        if not target_user or not role_to_modify:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return
        if target_user.telegram_id in services_provider.config.core.super_admins:
            await query.answer("Нельзя изменять роли Владельца.", show_alert=True); return
            
        user_has_this_role = role_to_modify in target_user.roles
        if role_to_modify.name == DEFAULT_ROLE_USER and user_has_this_role and len(target_user.roles) == 1:
            await query.answer(f"Нельзя снять последнюю роль '{DEFAULT_ROLE_USER}'.", show_alert=True); return
        
        alert_text, action_performed = "", False
        if user_has_this_role: 
            if await services_provider.rbac.remove_role_from_user(session, target_user, role_to_modify.name):
                action_performed, alert_text = True, f"Роль '{role_to_modify.name}' снята."
            else: alert_text = f"Не удалось снять роль '{role_to_modify.name}'."
        else: 
            if await services_provider.rbac.assign_role_to_user(session, target_user, role_to_modify.name):
                action_performed, alert_text = True, f"Роль '{role_to_modify.name}' назначена."
            else: alert_text = f"Не удалось назначить роль '{role_to_modify.name}'."
        
        if action_performed:
            try: 
                await session.commit()
                logger.info(f"[{MODULE_NAME_FOR_LOG}] {alert_text} для {target_user.full_name}")
                await session.refresh(target_user, attribute_names=['roles'])
            except Exception as e: 
                await session.rollback()
                logger.error(f"Ошибка commit: {e}")
                alert_text = "Ошибка сохранения."
                action_performed=False 
        
        all_roles = await services_provider.rbac.get_all_roles(session) 
        keyboard_text = USERS_MGMT_TEXTS["edit_roles_for_user"].format(user_name=hbold(target_user.full_name))
        kb = await get_admin_user_edit_roles_keyboard_local(target_user, all_roles, services_provider, admin_user_id, session)
        if query.message: 
            try: 
                await query.message.edit_text(keyboard_text, reply_markup=kb) # Имя переменной клавиатуры keyboard_text
            except TelegramBadRequest as e_tbr: # Используем импортированный TelegramBadRequest
                if "message is not modified" not in str(e_tbr).lower():
                    logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка обновления клавиатуры ролей (toggle): {e_tbr}")
            except Exception as e: 
                logger.warning(f"Ошибка обновления kb ролей (toggle): {e}")
        await query.answer(alert_text, show_alert=action_performed and "Не удалось" not in alert_text)


======================================================================

------------------------------ FILE: core/admin/logs_viewer/handlers_modules.py ------------------------------
# core/admin/logs_viewer/handlers_logs.py
from aiogram import Router, types, F
from loguru import logger

from core.ui.callback_data_factories import AdminMainMenuNavigate # Пример, если будет навигация
from core.admin.filters_admin import can_view_admin_panel_filter
# from .keyboards_logs import ...

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider

logs_viewer_router = Router(name="sdb_admin_logs_viewer_handlers")
MODULE_NAME_FOR_LOG = "AdminLogsViewer"

#logs_viewer_router.callback_query.filter(can_view_admin_panel_filter)

# Пример обработчика для входа в раздел просмотра логов
# Предположим, что в AdminMainMenuNavigate у нас будет target_section="logs_view"
@logs_viewer_router.callback_query(AdminMainMenuNavigate.filter(F.target_section == "logs_view"))
async def cq_admin_logs_view_start(
    query: types.CallbackQuery,
    # callback_data: AdminMainMenuNavigate, # Если понадобятся данные из callback
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} запросил просмотр логов (раздел в разработке).")
    
    # TODO: Проверить специфичное разрешение на просмотр логов, например, PERMISSION_CORE_SYSTEM_VIEW_LOGS_BASIC
    
    # text = "🛠️ Просмотр логов системы\n\nЭта функция находится в разработке."
    # keyboard = ... # Сделать клавиатуру, если нужны опции (выбор файла, фильтры и т.д.)
    # await query.message.edit_text(text, reply_markup=keyboard)
    await query.answer("Раздел просмотра логов находится в разработке.", show_alert=True)


======================================================================

------------------------------ FILE: core/admin/logs_viewer/keyboards_modules.py ------------------------------
# core/admin/logs_viewer/keyboards_logs.py
# Пока пустой, но файл существует для будущей логики клавиатур этого раздела.
from aiogram.types import InlineKeyboardMarkup
from aiogram.utils.keyboard import InlineKeyboardBuilder
# from core.admin.keyboards_admin_common import get_back_to_admin_main_menu_button

# Пример функции, если понадобится:
# def get_logs_viewer_main_keyboard() -> InlineKeyboardMarkup:
#     builder = InlineKeyboardBuilder()
#     # builder.button(text="Скачать последний лог-файл", callback_data=...)
#     # builder.button(text="Выбрать лог-файл для просмотра", callback_data=...)
#     # builder.row(get_back_to_admin_main_menu_button())
#     return builder.as_markup()


======================================================================

------------------------------ FILE: core/admin/logs_viewer/handlers_logs.py ------------------------------
# core/admin/logs_viewer/handlers_logs.py
from aiogram import Router, types, F
from loguru import logger

from core.ui.callback_data_factories import AdminMainMenuNavigate 
from core.admin.filters_admin import can_view_admin_panel_filter

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider

logs_viewer_router = Router(name="sdb_admin_logs_viewer_handlers")
MODULE_NAME_FOR_LOG = "AdminLogsViewer"

#logs_viewer_router.callback_query.filter(can_view_admin_panel_filter)

@logs_viewer_router.callback_query(AdminMainMenuNavigate.filter(F.target_section == "logs_view"))
async def cq_admin_logs_view_start(
    query: types.CallbackQuery,
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} запросил просмотр логов (раздел в разработке).")
    await query.answer("Раздел просмотра логов находится в разработке.", show_alert=True)


======================================================================

------------------------------ FILE: core/admin/logs_viewer/__init__.py ------------------------------
# core/admin/logs_viewer/__init__.py
from aiogram import Router

from .handlers_logs import logs_viewer_router 

section_logs_viewer_router = Router(name="sdb_admin_section_logs_viewer_router")
section_logs_viewer_router.include_router(logs_viewer_router)

__all__ = ["section_logs_viewer_router"]


======================================================================

------------------------------ FILE: core/admin/roles/handlers_crud_fsm.py ------------------------------
# core/admin/roles/handlers_crud_fsm.py
from aiogram import Router, types, F, Bot
from aiogram.filters import Command, StateFilter 
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup 
from aiogram.utils.markdown import hbold, hcode, hitalic
from aiogram.utils.keyboard import InlineKeyboardBuilder 
from loguru import logger
from sqlalchemy import select, func as sql_func
from aiogram.exceptions import TelegramBadRequest # <--- ИСПРАВЛЕН ИМПОРТ

from core.ui.callback_data_factories import AdminRolesPanelNavigate
from .keyboards_roles import get_admin_roles_list_keyboard_local, ROLES_MGMT_TEXTS 
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS 
from core.admin.filters_admin import can_view_admin_panel_filter
from core.rbac.service import PERMISSION_CORE_ROLES_CREATE, PERMISSION_CORE_ROLES_EDIT, PERMISSION_CORE_ROLES_DELETE, DEFAULT_ROLES_DEFINITIONS
from core.database.core_models import Role as DBRole, UserRole


from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession


role_crud_fsm_router = Router(name="sdb_admin_role_crud_fsm_handlers")
MODULE_NAME_FOR_LOG = "AdminRoleCRUD"

#role_crud_fsm_router.callback_query.filter(can_view_admin_panel_filter)
#role_crud_fsm_router.message.filter(can_view_admin_panel_filter)

class FSMAdminCreateRole(StatesGroup):
    waiting_for_name = State()
    waiting_for_description = State()

class FSMAdminEditRole(StatesGroup): 
    waiting_for_new_name = State()
    waiting_for_new_description = State()

@role_crud_fsm_router.callback_query(AdminRolesPanelNavigate.filter(F.action == "create_start"))
async def cq_admin_role_create_start_fsm( 
    query: types.CallbackQuery,
    state: FSMContext,
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} инициировал создание новой роли (FSM).")

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_CREATE):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True)
                return
    
    await state.set_state(FSMAdminCreateRole.waiting_for_name)
    
    text = (f"{ADMIN_COMMON_TEXTS.get('fsm_enter_role_name', 'Введите имя роли:')}\n\n"
            f"{hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_cancel_role_creation', '/cancel_role_creation - Отменить'))}")
    
    if query.message:
        try:
            await query.message.edit_text(text, reply_markup=None) 
        except TelegramBadRequest as e: # Используем импортированный TelegramBadRequest
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Не удалось отредактировать сообщение для FSM (create_start): {e}. Отправка нового.")
            await query.bot.send_message(query.from_user.id, text) 
        except Exception as e_fatal:
            logger.error(f"Критическая ошибка в cq_admin_role_create_start_fsm при edit/send: {e_fatal}")
            await query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)
    else: 
        await query.bot.send_message(query.from_user.id, text) 
    await query.answer()


@role_crud_fsm_router.message(StateFilter(FSMAdminCreateRole.waiting_for_name), F.text)
async def process_fsm_role_name_crud( 
    message: types.Message, 
    state: FSMContext, 
    services_provider: 'BotServicesProvider'
):
    admin_user_id = message.from_user.id
    role_name = message.text.strip() if message.text else ""

    if not role_name:
        await message.reply(ADMIN_COMMON_TEXTS.get('fsm_role_name_empty', 'Имя роли не может быть пустым.'))
        return

    async with services_provider.db.get_session() as session:
        existing_role = await services_provider.rbac._get_role_by_name(session, role_name) 
        if existing_role:
            await message.reply(ADMIN_COMMON_TEXTS.get('fsm_role_name_taken','Роль с именем "{role_name}" уже существует.').format(role_name=hcode(role_name)))
            return
            
    await state.update_data(new_role_name=role_name)
    await state.set_state(FSMAdminCreateRole.waiting_for_description)
    
    text = (f"{ADMIN_COMMON_TEXTS.get('fsm_enter_role_description','Введите описание для роли {role_name}:').format(role_name=hcode(role_name))}\n\n"
            f"{hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_skip_description','/skip_description - Пропустить'))} или {hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_cancel_role_creation','/cancel_role_creation - Отменить'))}")
    await message.answer(text)


@role_crud_fsm_router.message(StateFilter(FSMAdminCreateRole.waiting_for_description), F.text)
async def process_fsm_role_description_crud( 
    message: types.Message, 
    state: FSMContext, 
    services_provider: 'BotServicesProvider',
    bot: Bot 
):
    admin_user_id = message.from_user.id
    
    if message.text and message.text.lower() == "/skip_description": 
        role_description = None
    else:
        role_description = message.text.strip() if message.text else None

    user_data = await state.get_data()
    role_name = user_data.get("new_role_name")

    if not role_name: 
        logger.error(f"[{MODULE_NAME_FOR_LOG}] FSM: Не найдено имя роли в состоянии при получении описания.")
        await message.answer(ADMIN_COMMON_TEXTS["error_general"])
        await state.clear()
        from .handlers_list import cq_admin_roles_list_entry 
        chat_id_for_reply = message.chat.id
        dummy_message_for_cb = types.Message(message_id=0, chat=types.Chat(id=chat_id_for_reply, type="private"), date=0) 
        await cq_admin_roles_list_entry(
            types.CallbackQuery(id="dummy_fsm_error_cb", from_user=message.from_user, chat_instance=str(chat_id_for_reply), data="dummy", message=dummy_message_for_cb), 
            AdminRolesPanelNavigate(action="list"), services_provider, bot
        )
        return

    async with services_provider.db.get_session() as session:
        created_role = await services_provider.rbac.get_or_create_role(session, role_name, role_description)
        if created_role:
            try:
                await session.commit()
                logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} успешно создал роль: '{role_name}'.")
                await message.answer(ADMIN_COMMON_TEXTS.get('fsm_role_created_successfully','Роль "{role_name}" успешно создана!').format(role_name=hcode(role_name)))
            except Exception as e_commit:
                await session.rollback()
                logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка commit при создании роли '{role_name}': {e_commit}", exc_info=True)
                await message.answer("Ошибка при сохранении роли.")
        else:
            await message.answer("Не удалось создать роль. Возможно, она уже существует или произошла ошибка.")
        
        await state.clear()
        from .handlers_list import cq_admin_roles_list_entry 
        chat_id_for_reply = message.chat.id
        dummy_message_for_cb = types.Message(message_id=0, chat=types.Chat(id=chat_id_for_reply, type="private"), date=0)
        await cq_admin_roles_list_entry(
            types.CallbackQuery(id="dummy_fsm_create_cb", from_user=message.from_user, chat_instance=str(chat_id_for_reply), data="dummy", message=dummy_message_for_cb), 
            AdminRolesPanelNavigate(action="list"), services_provider, bot
        )

@role_crud_fsm_router.message(Command("cancel_role_creation"), StateFilter(FSMAdminCreateRole))
async def cancel_create_role_fsm_command(
    message: types.Message, 
    state: FSMContext, 
    services_provider: 'BotServicesProvider', 
    bot: Bot
):
    admin_user_id = message.from_user.id
    current_fsm_state = await state.get_state()
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} отменил создание роли из состояния {current_fsm_state} командой.")
    await state.clear()
    await message.answer(ADMIN_COMMON_TEXTS.get('fsm_role_creation_cancelled', "Создание роли отменено."))
    
    from .handlers_list import cq_admin_roles_list_entry
    chat_id_for_reply = message.chat.id
    dummy_message_for_cb = types.Message(message_id=0, chat=types.Chat(id=chat_id_for_reply, type="private"), date=0)
    await cq_admin_roles_list_entry(
        types.CallbackQuery(id="dummy_fsm_cancel_cb", from_user=message.from_user, chat_instance=str(chat_id_for_reply), data="dummy", message=dummy_message_for_cb), 
        AdminRolesPanelNavigate(action="list"), services_provider, bot
    )

@role_crud_fsm_router.callback_query(AdminRolesPanelNavigate.filter(F.action == "edit_start"))
async def cq_admin_role_edit_start_fsm( 
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate,
    state: FSMContext,
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    role_id_to_edit = callback_data.item_id

    if role_id_to_edit is None or not str(role_id_to_edit).isdigit(): 
        await query.answer("Ошибка: ID роли для редактирования не указан или некорректен.", show_alert=True); return
    
    role_id_to_edit = int(str(role_id_to_edit)) 

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} инициировал редактирование роли ID: {role_id_to_edit} (FSM).")

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_EDIT):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return
        
        role_to_edit = await session.get(DBRole, role_id_to_edit)
        if not role_to_edit:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return

        await state.update_data(
            editing_role_id=role_to_edit.id,
            current_role_name=role_to_edit.name,
            current_role_description=role_to_edit.description or "" 
        )

        title_text = ADMIN_COMMON_TEXTS.get('fsm_edit_role_title','Редактирование роли: {role_name}').format(role_name=hcode(role_to_edit.name))
        
        if role_to_edit.name in DEFAULT_ROLES_DEFINITIONS:
            await state.set_state(FSMAdminEditRole.waiting_for_new_description)
            prompt_text = (f"{title_text}\n"
                           f"{ADMIN_COMMON_TEXTS.get('fsm_edit_role_name_not_allowed','Имя стандартной роли {role_name} изменять нельзя.').format(role_name=hcode(role_to_edit.name))}\n\n"
                           f"{ADMIN_COMMON_TEXTS.get('fsm_enter_new_role_description','Введите новое описание для роли {role_name} (текущее: {current_description}):').format(role_name=hcode(role_to_edit.name), current_description=hitalic(role_to_edit.description or 'пусто'))}\n\n"
                           f"{hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_skip_description','/skip_description - Пропустить'))} или {hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_cancel_role_edit','/cancel_role_edit - Отменить'))}")
        else:
            await state.set_state(FSMAdminEditRole.waiting_for_new_name)
            prompt_text = (f"{title_text}\n"
                           f"{ADMIN_COMMON_TEXTS.get('fsm_enter_new_role_name','Введите новое имя для роли (текущее: {current_name}):').format(current_name=hcode(role_to_edit.name))}\n\n"
                           f"{hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_skip_name','/skip_name - Оставить как есть'))} или {hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_cancel_role_edit','/cancel_role_edit - Отменить'))}")
    
    if query.message:
        try:
            await query.message.edit_text(prompt_text, reply_markup=None) 
        except TelegramBadRequest as e: # Используем импортированный TelegramBadRequest
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Не удалось отредактировать сообщение для FSM (edit_start): {e}. Отправка нового.")
            await query.bot.send_message(query.from_user.id, prompt_text) 
    else:
        await query.bot.send_message(query.from_user.id, prompt_text) 
    await query.answer()


@role_crud_fsm_router.message(StateFilter(FSMAdminEditRole.waiting_for_new_name), F.text)
async def process_fsm_edit_role_name_crud( 
    message: types.Message, 
    state: FSMContext, 
    services_provider: 'BotServicesProvider'
):
    admin_user_id = message.from_user.id
    new_role_name_input = message.text.strip() if message.text else ""
    
    user_data = await state.get_data()
    current_role_name = user_data.get("current_role_name")
    role_id = user_data.get("editing_role_id")

    final_role_name = current_role_name 

    if new_role_name_input.lower() == "/skip_name":
        logger.info(f"[{MODULE_NAME_FOR_LOG}] FSM Edit Role: Пользователь {admin_user_id} пропустил изменение имени для роли ID {role_id}.")
    elif not new_role_name_input:
        await message.reply(ADMIN_COMMON_TEXTS.get('fsm_role_name_empty', 'Имя роли не может быть пустым.'))
        return
    elif new_role_name_input != current_role_name:
        async with services_provider.db.get_session() as session:
            existing_role_with_new_name = await services_provider.rbac._get_role_by_name(session, new_role_name_input)
            if existing_role_with_new_name and existing_role_with_new_name.id != role_id:
                await message.reply(ADMIN_COMMON_TEXTS.get('fsm_role_name_taken','Роль с именем "{role_name}" уже существует.').format(role_name=hcode(new_role_name_input)))
                return
        final_role_name = new_role_name_input
        logger.info(f"[{MODULE_NAME_FOR_LOG}] FSM Edit Role: Пользователь {admin_user_id} ввел новое имя '{final_role_name}' для роли ID {role_id}.")
    
    await state.update_data(edited_role_name=final_role_name) 
    await state.set_state(FSMAdminEditRole.waiting_for_new_description)
    
    current_description = user_data.get("current_role_description", "пусто")
    text = (f"{ADMIN_COMMON_TEXTS.get('fsm_enter_new_role_description','Введите новое описание для роли {role_name} (текущее: {current_description}):').format(role_name=hcode(final_role_name), current_description=hitalic(current_description))}\n\n"
            f"{hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_skip_description','/skip_description - Пропустить'))} или {hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_cancel_role_edit','/cancel_role_edit - Отменить'))}")
    await message.answer(text)


@role_crud_fsm_router.message(StateFilter(FSMAdminEditRole.waiting_for_new_description), F.text)
async def process_fsm_edit_role_description_crud( 
    message: types.Message, 
    state: FSMContext, 
    services_provider: 'BotServicesProvider',
    bot: Bot
):
    admin_user_id = message.from_user.id
    new_role_description_input = message.text.strip() if message.text else None

    user_data = await state.get_data()
    role_id = user_data.get("editing_role_id")
    final_role_name = user_data.get("edited_role_name", user_data.get("current_role_name")) 
    current_role_description = user_data.get("current_role_description")

    final_role_description = current_role_description 
    if new_role_description_input and new_role_description_input.lower() == "/skip_description":
        final_role_description = current_role_description if current_role_description is not None else None 
        logger.info(f"[{MODULE_NAME_FOR_LOG}] FSM Edit Role: Пользователь {admin_user_id} пропустил изменение описания для роли ID {role_id}.")
    elif new_role_description_input is not None: 
        final_role_description = new_role_description_input if new_role_description_input else None 
        logger.info(f"[{MODULE_NAME_FOR_LOG}] FSM Edit Role: Пользователь {admin_user_id} ввел новое описание для роли ID {role_id}.")

    if role_id is None or final_role_name is None: 
        logger.error(f"[{MODULE_NAME_FOR_LOG}] FSM Edit: Отсутствует ID роли или имя в состоянии.")
        await message.answer(ADMIN_COMMON_TEXTS["error_general"])
        await state.clear()
        return

    async with services_provider.db.get_session() as session:
        role_to_update = await session.get(DBRole, role_id)
        if not role_to_update:
            await message.answer(ADMIN_COMMON_TEXTS["not_found_generic"])
            await state.clear()
            return
        
        made_changes = False
        if role_to_update.name != final_role_name and role_to_update.name not in DEFAULT_ROLES_DEFINITIONS:
            if final_role_name != user_data.get("current_role_name"): 
                existing_role_check = await services_provider.rbac._get_role_by_name(session, final_role_name)
                if existing_role_check and existing_role_check.id != role_id:
                    await message.reply(ADMIN_COMMON_TEXTS.get('fsm_role_name_taken','Роль с именем "{role_name}" уже существует.').format(role_name=hcode(final_role_name)))
                    await state.set_state(FSMAdminEditRole.waiting_for_new_name)
                    current_name_for_prompt = user_data.get("current_role_name")
                    title_text = ADMIN_COMMON_TEXTS.get('fsm_edit_role_title','Редактирование роли: {role_name}').format(role_name=hcode(current_name_for_prompt))
                    prompt_text = (f"{title_text}\n"
                                   f"{ADMIN_COMMON_TEXTS.get('fsm_enter_new_role_name','Введите новое имя для роли (текущее: {current_name}):').format(current_name=hcode(current_name_for_prompt))}\n\n"
                                   f"{hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_skip_name','/skip_name - Оставить как есть'))} или {hitalic(ADMIN_COMMON_TEXTS.get('fsm_command_cancel_role_edit','/cancel_role_edit - Отменить'))}")
                    await message.answer(prompt_text)
                    return
            role_to_update.name = final_role_name
            made_changes = True
        elif role_to_update.name != final_role_name and role_to_update.name in DEFAULT_ROLES_DEFINITIONS:
            logger.warning(f"Попытка изменить имя стандартной роли '{role_to_update.name}' на '{final_role_name}'. Имя не будет изменено.")
        
        if role_to_update.description != final_role_description:
            role_to_update.description = final_role_description
            made_changes = True
        
        if made_changes:
            session.add(role_to_update)
            try:
                await session.commit()
                logger.info(f"[{MODULE_NAME_FOR_LOG}] Роль ID {role_id} успешно обновлена. Имя: '{role_to_update.name}', описание: '{role_to_update.description}'.")
                await message.answer(ADMIN_COMMON_TEXTS.get('fsm_role_updated_successfully','Роль "{role_name}" успешно обновлена!').format(role_name=hcode(role_to_update.name)))
            except Exception as e_commit:
                await session.rollback()
                logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка commit при обновлении роли ID {role_id}: {e_commit}", exc_info=True)
                await message.answer("Ошибка сохранения изменений роли.")
        else:
            await message.answer("Нет изменений для сохранения.")

        await state.clear()
        from .handlers_list import cq_admin_roles_list_entry
        chat_id_for_reply = message.chat.id
        dummy_message_for_cb = types.Message(message_id=0, chat=types.Chat(id=chat_id_for_reply, type="private"), date=0)
        await cq_admin_roles_list_entry(
            types.CallbackQuery(id="dummy_fsm_edit_cb", from_user=message.from_user, chat_instance=str(chat_id_for_reply), data="dummy", message=dummy_message_for_cb), 
            AdminRolesPanelNavigate(action="list"), services_provider, bot
        )

@role_crud_fsm_router.message(Command("cancel_role_edit"), StateFilter(FSMAdminEditRole))
async def cancel_edit_role_fsm_command_crud( 
    message: types.Message, 
    state: FSMContext, 
    services_provider: 'BotServicesProvider', 
    bot: Bot
):
    admin_user_id = message.from_user.id
    current_fsm_state = await state.get_state()
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} отменил редактирование роли из состояния {current_fsm_state} командой.")
    await state.clear()
    await message.answer(ADMIN_COMMON_TEXTS.get('fsm_role_update_cancelled', "Редактирование роли отменено."))
    
    from .handlers_list import cq_admin_roles_list_entry
    chat_id_for_reply = message.chat.id
    dummy_message_for_cb = types.Message(message_id=0, chat=types.Chat(id=chat_id_for_reply, type="private"), date=0)
    await cq_admin_roles_list_entry(
        types.CallbackQuery(id="dummy_fsm_cancel_edit_cb", from_user=message.from_user, chat_instance=str(chat_id_for_reply), data="dummy", message=dummy_message_for_cb), 
        AdminRolesPanelNavigate(action="list"), services_provider, bot
    )

@role_crud_fsm_router.callback_query(AdminRolesPanelNavigate.filter(F.action == "delete_confirm"))
async def cq_admin_role_delete_confirm_crud( 
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate,
    services_provider: 'BotServicesProvider'
):
    admin_user_id = query.from_user.id
    role_id_to_delete = callback_data.item_id

    if role_id_to_delete is None or not str(role_id_to_delete).isdigit():
        await query.answer("Ошибка: ID роли для удаления не указан или некорректен.", show_alert=True); return
    
    role_id_to_delete = int(str(role_id_to_delete))

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} запросил подтверждение удаления роли ID: {role_id_to_delete}.")

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_DELETE):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return

        role_to_delete = await session.get(DBRole, role_id_to_delete)
        if not role_to_delete:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return

        if role_to_delete.name in DEFAULT_ROLES_DEFINITIONS:
            await query.answer(ADMIN_COMMON_TEXTS.get('role_is_standard_cant_delete','Стандартную роль "{role_name}" удалять нельзя.').format(role_name=hcode(role_to_delete.name)), show_alert=True); return
        
        user_role_count_stmt = select(sql_func.count(UserRole.id)).where(UserRole.role_id == role_id_to_delete)
        user_role_count_res = await session.execute(user_role_count_stmt)
        user_count_with_role = user_role_count_res.scalar_one()

        warning_text = ""
        if user_count_with_role > 0:
            text_with_warning = (f"🚫 {hbold('Удаление невозможно!')}\n"
                                 f"Роль {hcode(role_to_delete.name)} назначена {hbold(str(user_count_with_role))} пользователю(ям).\n"
                                 f"Сначала снимите эту роль со всех пользователей.")
            builder = InlineKeyboardBuilder()
            builder.button(text=ROLES_MGMT_TEXTS.get('back_to_role_details', "Назад"), 
                           callback_data=AdminRolesPanelNavigate(action="view", item_id=role_id_to_delete).pack())
            if query.message: await query.message.edit_text(text_with_warning, reply_markup=builder.as_markup())
            await query.answer(f"Роль используется {user_count_with_role} пользователями.", show_alert=True)
            return

        text = ADMIN_COMMON_TEXTS.get('delete_role_confirm_text','Вы уверены, что хотите удалить роль {role_name}?\n{warning_if_users}\nЭто действие необратимо!').format(role_name=hbold(role_to_delete.name), warning_if_users=warning_text)
        
        from core.ui.keyboards_core import get_confirm_action_keyboard 
        keyboard = get_confirm_action_keyboard(
            confirm_callback_data=AdminRolesPanelNavigate(action="delete_execute", item_id=role_id_to_delete).pack(),
            cancel_callback_data=AdminRolesPanelNavigate(action="view", item_id=role_id_to_delete).pack() 
        )
        if query.message:
            await query.message.edit_text(text, reply_markup=keyboard)
        await query.answer()


@role_crud_fsm_router.callback_query(AdminRolesPanelNavigate.filter(F.action == "delete_execute"))
async def cq_admin_role_delete_execute_crud( 
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate,
    services_provider: 'BotServicesProvider',
    bot: Bot
):
    admin_user_id = query.from_user.id
    role_id_to_delete = callback_data.item_id

    if role_id_to_delete is None or not str(role_id_to_delete).isdigit():
        await query.answer("Ошибка: ID роли для удаления не указан или некорректен.", show_alert=True); return
    
    role_id_to_delete = int(str(role_id_to_delete))

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} подтвердил удаление роли ID: {role_id_to_delete}.")
    
    default_fail_text = ADMIN_COMMON_TEXTS.get('role_delete_failed','Не удалось удалить роль "{role_name}".')
    alert_text = default_fail_text.format(role_name="ID:"+str(role_id_to_delete)) 

    async with services_provider.db.get_session() as session:
        if not services_provider.config.core.super_admins or admin_user_id not in services_provider.config.core.super_admins:
            if not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_DELETE):
                await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return

        role_to_delete = await session.get(DBRole, role_id_to_delete) 
        if not role_to_delete:
            alert_text = ADMIN_COMMON_TEXTS["not_found_generic"]
        elif role_to_delete.name in DEFAULT_ROLES_DEFINITIONS:
            alert_text = ADMIN_COMMON_TEXTS.get('role_is_standard_cant_delete','Стандартную роль "{role_name}" удалять нельзя.').format(role_name=hcode(role_to_delete.name))
        else:
            user_role_count_stmt = select(sql_func.count(UserRole.id)).where(UserRole.role_id == role_id_to_delete)
            user_role_count_res = await session.execute(user_role_count_stmt)
            if user_role_count_res.scalar_one() > 0:
                alert_text = "Невозможно удалить роль, так как она все еще назначена пользователям."
            else:
                role_name_deleted = role_to_delete.name
                if await services_provider.rbac.delete_role(session, role_id_to_delete): 
                    try:
                        await session.commit()
                        alert_text = ADMIN_COMMON_TEXTS.get('role_deleted_successfully','Роль "{role_name}" успешно удалена.').format(role_name=hcode(role_name_deleted))
                        logger.info(f"[{MODULE_NAME_FOR_LOG}] {alert_text}")
                    except Exception as e_commit:
                        await session.rollback()
                        logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка commit при удалении роли: {e_commit}", exc_info=True)
                        alert_text = "Ошибка сохранения удаления роли."
                else: 
                    alert_text = default_fail_text.format(role_name=hcode(role_name_deleted))
        
        from .handlers_list import cq_admin_roles_list_entry 
        if query.message: 
            try: await query.message.delete() 
            except Exception: pass 
        
        from_user_obj = query.from_user if query.from_user else types.User(id=0, is_bot=False, first_name="Unknown")
        chat_id_for_reply = query.message.chat.id if query.message else from_user_obj.id 
        chat_instance_str = query.chat_instance or str(chat_id_for_reply) 
        
        dummy_cb_for_list = types.CallbackQuery(
            id="dummy_after_delete_cb", 
            from_user=from_user_obj, 
            chat_instance=chat_instance_str, 
            data="dummy", 
            message=None 
        )
        await cq_admin_roles_list_entry(dummy_cb_for_list, AdminRolesPanelNavigate(action="list"), services_provider, bot)

    await query.answer(alert_text, show_alert=True)


======================================================================

------------------------------ FILE: core/admin/roles/keyboards_roles.py ------------------------------
# core/admin/roles/keyboards_roles.py
from typing import TYPE_CHECKING, List, Optional, Set, Dict
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton # Убедимся что types импортирован
from aiogram.utils.keyboard import InlineKeyboardBuilder
from loguru import logger 

from core.ui.callback_data_factories import AdminRolesPanelNavigate
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS, get_back_to_admin_main_menu_button
from core.rbac.service import (
    PERMISSION_CORE_ROLES_CREATE, 
    PERMISSION_CORE_ROLES_EDIT, 
    PERMISSION_CORE_ROLES_DELETE, 
    PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS,
    DEFAULT_ROLES_DEFINITIONS 
)

if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession
    from core.database.core_models import Role as DBRole, Permission as DBPermission
    from aiogram import types as AiogramTypes # Используем псевдоним, чтобы не путать с types в аннотациях

ROLES_MGMT_TEXTS = {
    "role_list_title": "🛡️ Управление ролями",
    "role_list_select_action": "Выберите роль для просмотра или управления:",
    "role_list_no_roles": "Нет ролей для отображения",
    "role_details_title": "🛡️ Детали роли",
    "role_action_edit_permissions": "Изменить разрешения",
    "role_action_edit_role": "✏️ Редактировать роль", 
    "role_action_delete_role": "🗑️ Удалить роль",    
    "back_to_roles_list": "⬅️ К списку ролей",
    "edit_permissions_for_role": "Разрешения для роли: {role_name}", 
    "role_action_create_role": "➕ Создать роль",
}


async def get_admin_roles_list_keyboard_local( 
    all_roles: List['DBRole'],
    services: Optional['BotServicesProvider'] = None, 
    user_tg_id: Optional[int] = None,          
    session: Optional['AsyncSession'] = None    
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = ROLES_MGMT_TEXTS

    logger.debug(f"[AdminRolesKeyboards] Генерация списка ролей. Всего ролей: {len(all_roles)}")
    if not all_roles:
        cb_dummy_data = AdminRolesPanelNavigate(action="dummy_no_roles").pack()
        builder.button(
            text=texts["role_list_no_roles"],
            callback_data=cb_dummy_data
        )
        logger.debug(f"[AdminRolesKeyboards] Добавлена кнопка 'нет ролей', callback: {cb_dummy_data}")
    else:
        for role in sorted(all_roles, key=lambda r: r.name):
            cb_data = AdminRolesPanelNavigate(action="view", item_id=role.id).pack()
            builder.button(
                text=f"🛡️ {role.name}",
                callback_data=cb_data
            )
            logger.debug(f"[AdminRolesKeyboards] Добавлена кнопка для роли '{role.name}' (ID: {role.id}), callback: {cb_data}")
        builder.adjust(1)
    
    if services and user_tg_id and session:
        is_owner_from_config = user_tg_id in services.config.core.super_admins
        can_create_roles = False
        try: 
            can_create_roles = is_owner_from_config or await services.rbac.user_has_permission(session, user_tg_id, PERMISSION_CORE_ROLES_CREATE)
        except Exception as e_perm_check:
            logger.error(f"[AdminRolesKeyboards] Ошибка проверки права PERMISSION_CORE_ROLES_CREATE для user {user_tg_id}: {e_perm_check}")

        if can_create_roles:
            cb_create_data = AdminRolesPanelNavigate(action="create_start").pack()
            builder.row( 
                InlineKeyboardButton(
                    text=texts["role_action_create_role"],
                    callback_data=cb_create_data
                )
            )
            logger.debug(f"[AdminRolesKeyboards] Добавлена кнопка 'создать роль', callback: {cb_create_data}")

    builder.row(get_back_to_admin_main_menu_button())
    return builder.as_markup()


async def get_admin_role_details_keyboard_local( 
    target_role: 'DBRole',
    services: 'BotServicesProvider',
    current_admin_tg_id: int,
    session: 'AsyncSession'
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = ROLES_MGMT_TEXTS
    rbac = services.rbac
    current_admin_is_owner = current_admin_tg_id in services.config.core.super_admins
    logger.debug(f"[AdminRolesKeyboards] Генерация деталей для роли '{target_role.name}' (ID: {target_role.id}). Админ: {current_admin_tg_id}, владелец: {current_admin_is_owner}")

    can_edit_role = False
    can_assign_perms = False
    can_delete_role = False

    try: 
        can_edit_role = current_admin_is_owner or await rbac.user_has_permission(session, current_admin_tg_id, PERMISSION_CORE_ROLES_EDIT)
        can_assign_perms = current_admin_is_owner or await rbac.user_has_permission(session, current_admin_tg_id, PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS)
        can_delete_role = current_admin_is_owner or await rbac.user_has_permission(session, current_admin_tg_id, PERMISSION_CORE_ROLES_DELETE)
    except Exception as e_perm_check_details:
        logger.error(f"[AdminRolesKeyboards] Ошибка проверки прав для деталей роли {target_role.id} админом {current_admin_tg_id}: {e_perm_check_details}")


    if can_edit_role:
        cb_edit_data = AdminRolesPanelNavigate(action="edit_start", item_id=target_role.id).pack()
        builder.button(
            text=texts["role_action_edit_role"],
            callback_data=cb_edit_data
        )
        logger.debug(f"[AdminRolesKeyboards] Добавлена кнопка 'редактировать роль', callback: {cb_edit_data}")
        
    if can_assign_perms:
        cb_edit_perms_data = AdminRolesPanelNavigate(action="edit_perms_start", item_id=target_role.id, page=1).pack()
        builder.button(
            text=texts["role_action_edit_permissions"],
            callback_data=cb_edit_perms_data
        )
        logger.debug(f"[AdminRolesKeyboards] Добавлена кнопка 'изменить разрешения', callback: {cb_edit_perms_data}")
    
    if target_role.name not in DEFAULT_ROLES_DEFINITIONS: 
        if can_delete_role:
            cb_delete_data = AdminRolesPanelNavigate(action="delete_confirm", item_id=target_role.id).pack()
            builder.button(
                text=texts["role_action_delete_role"],
                callback_data=cb_delete_data
            )
            logger.debug(f"[AdminRolesKeyboards] Добавлена кнопка 'удалить роль', callback: {cb_delete_data}")

    if builder.export(): 
        builder.adjust(1)
    
    builder.row(InlineKeyboardButton(
        text=texts["back_to_roles_list"],
        callback_data=AdminRolesPanelNavigate(action="list").pack()
    ))
    builder.row(get_back_to_admin_main_menu_button())
    return builder.as_markup()

async def get_admin_role_edit_permissions_keyboard_local( 
    target_role: 'DBRole',
    services: 'BotServicesProvider',
    current_admin_tg_id: int,
    session: 'AsyncSession',
    all_system_permissions: Optional[List['DBPermission']] = None,
    category_key: Optional[str] = None,
    entity_name: Optional[str] = None,
    page: int = 1,
    perms_per_page: int = 7 
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    texts = ADMIN_COMMON_TEXTS 
    rbac = services.rbac
    
    role_permission_ids: Set[int] = {perm.id for perm in target_role.permissions if perm.id is not None}

    builder.row(InlineKeyboardButton(
        text=ROLES_MGMT_TEXTS.get("back_to_role_details", "⬅️ К деталям роли"),
        callback_data=AdminRolesPanelNavigate(action="view", item_id=target_role.id).pack()
    ))

    if not category_key:
        builder.button(
            text=texts["perm_category_core"], 
            callback_data=AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key="core", page=1).pack()
        )
        module_perms_exist = False
        if services.modules:
            declared_module_perms = services.modules.get_all_declared_permissions_from_active_modules()
            if declared_module_perms: module_perms_exist = True
        if module_perms_exist:
            builder.button(
                text=texts["perm_category_modules"],
                callback_data=AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key="module", page=1).pack()
            )
        builder.adjust(1)
        # Не забываем добавить кнопку "Назад в Админ-панель" и здесь, если это верхний уровень выбора категорий
        builder.row(get_back_to_admin_main_menu_button())
        return builder.as_markup()

    permissions_to_display_final: List['DBPermission'] = []
    if all_system_permissions is None: 
        all_system_permissions = await rbac.get_all_permissions(session)

    back_to_category_selection_button = InlineKeyboardButton(
        text=texts["back_to_perm_categories"], 
        callback_data=AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key=None, entity_name=None, page=1).pack()
    )

    if category_key == "core":
        CORE_PERM_GROUPS_MAP_ROLES: Dict[str, str] = { 
            k: texts[f"perm_core_group_{k}"] for k in ["users", "roles", "modules_core", "system", "settings_core", "other"]
        }
        CORE_PERM_PREFIXES_MAP_ROLES: Dict[str, str] = {
            "users": "core.users.", "roles": "core.roles.", "modules_core": "core.modules.",
            "system": "core.system.", "settings_core": "core.settings."
        }
        if not entity_name: 
            for group_key, group_display_name in CORE_PERM_GROUPS_MAP_ROLES.items():
                prefix_to_check = CORE_PERM_PREFIXES_MAP_ROLES.get(group_key)
                has_perms_in_group = False
                if prefix_to_check:
                    if any(p.name.startswith(prefix_to_check) for p in all_system_permissions): has_perms_in_group = True
                elif group_key == "other": 
                    known_prefixes = list(CORE_PERM_PREFIXES_MAP_ROLES.values())
                    if any(p.name.startswith("core.") and not any(p.name.startswith(kp) for kp in known_prefixes) for p in all_system_permissions): has_perms_in_group = True
                if has_perms_in_group:
                    builder.button(text=group_display_name, callback_data=AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key="core", entity_name=group_key, page=1).pack())
            builder.adjust(1)
            builder.row(back_to_category_selection_button)
        else: 
            if entity_name == "other":
                known_prefixes = list(CORE_PERM_PREFIXES_MAP_ROLES.values())
                permissions_to_display_final = [p for p in all_system_permissions if p.name.startswith("core.") and not any(p.name.startswith(kp) for kp in known_prefixes)]
            elif entity_name in CORE_PERM_PREFIXES_MAP_ROLES:
                prefix = CORE_PERM_PREFIXES_MAP_ROLES[entity_name]
                permissions_to_display_final = [p for p in all_system_permissions if p.name.startswith(prefix)]
            builder.row(InlineKeyboardButton(text=texts["back_to_core_perm_groups"], callback_data=AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key="core", entity_name=None, page=1).pack()))
    elif category_key == "module":
        if not services.modules: 
            builder.button(text="Ошибка: Загрузчик модулей недоступен.", callback_data="dummy_error_no_module_loader_perms"); return builder.as_markup() # Изменена dummy_data
        module_permissions_map: Dict[str, List['DBPermission']] = {}
        module_display_names: Dict[str, str] = {}
        for p in all_system_permissions:
            if not p.name.startswith("core."):
                module_name_candidate = p.name.split('.')[0]
                if module_name_candidate not in module_permissions_map:
                    module_permissions_map[module_name_candidate] = []
                    mod_info = services.modules.get_module_info(module_name_candidate)
                    module_display_names[module_name_candidate] = mod_info.manifest.display_name if mod_info and mod_info.manifest else module_name_candidate
                module_permissions_map[module_name_candidate].append(p)
        if not entity_name: 
            sorted_module_names = sorted(module_permissions_map.keys())
            if not sorted_module_names: builder.button(text=texts["no_modules_with_perms"], callback_data="dummy_no_mod_perms_for_role") # Изменена dummy_data
            else:
                for mod_name in sorted_module_names:
                    builder.button(text=f"🧩 {module_display_names.get(mod_name, mod_name)}", callback_data=AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key="module", entity_name=mod_name, page=1).pack())
            builder.adjust(1)
            builder.row(back_to_category_selection_button)
        else: 
            permissions_to_display_final = module_permissions_map.get(entity_name, [])
            builder.row(InlineKeyboardButton(text=texts["back_to_module_list_for_perms"], callback_data=AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key="module", entity_name=None, page=1).pack()))
    
    if permissions_to_display_final:
        permissions_to_display_final.sort(key=lambda p: p.name)
        total_perms_in_list = len(permissions_to_display_final)
        total_perm_pages = (total_perms_in_list + perms_per_page - 1) // perms_per_page
        total_perm_pages = max(1, total_perm_pages)
        current_perm_page = max(1, min(page, total_perm_pages))
        start_idx = (current_perm_page - 1) * perms_per_page
        end_idx = start_idx + perms_per_page
        paginated_perms = permissions_to_display_final[start_idx:end_idx]
        if not paginated_perms and current_perm_page == 1: builder.button(text=texts["no_permissions_in_group"], callback_data="dummy_no_perms_in_group_for_role") # Изменена dummy_data
        else:
            for perm in paginated_perms:
                is_assigned = perm.id in role_permission_ids
                prefix = "✅ " if is_assigned else "⬜ "
                button_text = f"{prefix}{perm.name}"
                if perm.id is None: continue 
                builder.button(text=button_text, callback_data=AdminRolesPanelNavigate(action="toggle_perm", item_id=target_role.id, permission_id=perm.id, category_key=category_key, entity_name=entity_name, page=current_perm_page).pack())
            builder.adjust(1)
            if total_perm_pages > 1:
                pagination_row_perms = []
                nav_cb_data_base = AdminRolesPanelNavigate(action="edit_perms_nav", item_id=target_role.id, category_key=category_key, entity_name=entity_name) 
                if current_perm_page > 1: pagination_row_perms.append(InlineKeyboardButton(text=texts["pagination_prev"], callback_data=nav_cb_data_base.model_copy(update={"page": current_perm_page - 1}).pack()))
                pagination_row_perms.append(InlineKeyboardButton(text=f"{current_perm_page}/{total_perm_pages}", callback_data="dummy_role_perm_page")) # Изменена dummy_data
                if current_perm_page < total_perm_pages: pagination_row_perms.append(InlineKeyboardButton(text=texts["pagination_next"], callback_data=nav_cb_data_base.model_copy(update={"page": current_perm_page + 1}).pack()))
                if pagination_row_perms: builder.row(*pagination_row_perms)
    elif entity_name: 
        builder.button(text=texts["no_permissions_in_group"], callback_data="dummy_no_perms_in_group_for_role_entity") # Изменена dummy_data

    builder.row(get_back_to_admin_main_menu_button())
    return builder.as_markup()


======================================================================

------------------------------ FILE: core/admin/roles/handlers_role_perms.py ------------------------------
# core/admin/roles/handlers_role_perms.py
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.utils.markdown import hbold
from loguru import logger
from sqlalchemy.orm import selectinload
from aiogram.filters import StateFilter # <--- ДОБАВЛЕН ИМПОРТ

# Исправленные импорты
from core.ui.callback_data_factories import AdminRolesPanelNavigate 
from .keyboards_roles import get_admin_role_edit_permissions_keyboard_local, ROLES_MGMT_TEXTS
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS
from core.admin.filters_admin import can_view_admin_panel_filter
from core.rbac.service import PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS
from core.database.core_models import Role as DBRole, Permission as DBPermission

from typing import TYPE_CHECKING, Optional, List
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession

role_permissions_router = Router(name="sdb_admin_role_permissions_handlers")
MODULE_NAME_FOR_LOG = "AdminRolePermissions"

#role_permissions_router.callback_query.filter(can_view_admin_panel_filter)

# --- FSM для навигации по разрешениям роли ---
class FSMEditRolePermissions(StatesGroup):
    navigating_role_permissions = State()

# --- Вход в FSM для управления разрешениями роли ---
@role_permissions_router.callback_query(AdminRolesPanelNavigate.filter(F.action == "edit_perms_start"))
async def cq_admin_role_edit_permissions_entry(
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate,
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    admin_user_id = query.from_user.id
    target_role_db_id = callback_data.item_id
    page = callback_data.page or 1 

    if target_role_db_id is None:
        await query.answer("Ошибка: ID роли не указан.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} входит в FSM управления правами для Role ID: {target_role_db_id}, page: {page}")

    async with services_provider.db.get_session() as session:
        current_admin_is_owner = admin_user_id in services_provider.config.core.super_admins
        if not current_admin_is_owner and \
           not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS):
            await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True)
            return
        
        target_role = await session.get(DBRole, target_role_db_id, options=[selectinload(DBRole.permissions)])
        if not target_role:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return

    await state.clear()
    await state.set_state(FSMEditRolePermissions.navigating_role_permissions)
    await state.update_data(
        target_role_id_for_perms=target_role_db_id,
        current_page=page, 
        # category_key и entity_name будут установлены при навигации
    )
    
    await _show_role_permissions_menu(query, services_provider, state)

# --- Навигация по категориям/сущностям/страницам разрешений роли ---
@role_permissions_router.callback_query(
    AdminRolesPanelNavigate.filter(F.action == "edit_perms_nav"),
    StateFilter(FSMEditRolePermissions.navigating_role_permissions)
)
async def cq_admin_role_permissions_navigate(
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate,
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    fsm_data = await state.get_data()
    target_role_db_id = fsm_data.get("target_role_id_for_perms")
    if target_role_db_id is None:
        await query.answer("Ошибка состояния FSM. Попробуйте выйти и войти снова.", show_alert=True)
        await state.clear(); return

    new_fsm_context_data = {
        "category_key": callback_data.category_key,
        "entity_name": callback_data.entity_name,
        "current_page": callback_data.page or 1
    }
    await state.update_data(**new_fsm_context_data)
    
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {query.from_user.id} навигация по правам роли (Role ID: {target_role_db_id}). "
                f"Новый FSM контекст навигации: {new_fsm_context_data}")
    
    await _show_role_permissions_menu(query, services_provider, state)

# --- Переключение разрешения для роли ---
@role_permissions_router.callback_query(
    AdminRolesPanelNavigate.filter(F.action == "toggle_perm"),
    StateFilter(FSMEditRolePermissions.navigating_role_permissions)
)
async def cq_admin_role_toggle_permission(
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate,
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    admin_user_id = query.from_user.id
    fsm_data = await state.get_data()
    target_role_db_id: Optional[int] = fsm_data.get("target_role_id_for_perms")
    permission_to_toggle_id: Optional[int] = callback_data.permission_id

    if target_role_db_id is None or permission_to_toggle_id is None:
        await query.answer("Ошибка: неверные данные для изменения разрешения.", show_alert=True); return

    logger.info(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} изменяет разрешение "
                f"PermID:'{permission_to_toggle_id}' для Role DBID:{target_role_db_id}")

    async with services_provider.db.get_session() as session:
        current_admin_is_owner = admin_user_id in services_provider.config.core.super_admins
        if not current_admin_is_owner and \
           not await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_ASSIGN_PERMISSIONS):
            await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True); return
        
        target_role = await session.get(DBRole, target_role_db_id, options=[selectinload(DBRole.permissions)])
        permission_to_modify = await session.get(DBPermission, permission_to_toggle_id)

        if not target_role or not permission_to_modify:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); return

        role_has_this_perm = permission_to_modify in target_role.permissions
        alert_text, action_performed = "", False

        if role_has_this_perm:
            if await services_provider.rbac.remove_permission_from_role(session, target_role, permission_to_modify.name):
                action_performed = True
                alert_text = f"Разрешение '{permission_to_modify.name}' снято с роли."
            else: alert_text = f"Не удалось снять разрешение '{permission_to_modify.name}'."
        else:
            if await services_provider.rbac.assign_permission_to_role(session, target_role, permission_to_modify.name, auto_create_perm=False):
                action_performed = True
                alert_text = f"Разрешение '{permission_to_modify.name}' назначено роли."
            else: alert_text = f"Не удалось назначить разрешение '{permission_to_modify.name}'."
        
        if action_performed:
            try: await session.commit(); logger.info(f"[{MODULE_NAME_FOR_LOG}] {alert_text} для Role ID: {target_role.id}"); await session.refresh(target_role, attribute_names=['permissions'])
            except Exception as e: await session.rollback(); logger.error(f"Ошибка commit: {e}"); alert_text = "Ошибка сохранения."
        
        await query.answer(alert_text, show_alert=action_performed and "Не удалось" not in alert_text)
        await _show_role_permissions_menu(query, services_provider, state)

# --- Вспомогательная функция для отображения меню разрешений роли ---
async def _show_role_permissions_menu(
    query: types.CallbackQuery, 
    services_provider: 'BotServicesProvider', 
    state: FSMContext
):
    admin_user_id = query.from_user.id
    fsm_data = await state.get_data()
    
    target_role_db_id = fsm_data.get("target_role_id_for_perms")
    category_key = fsm_data.get("category_key")
    entity_name = fsm_data.get("entity_name")
    page = fsm_data.get("current_page", 1)

    if target_role_db_id is None:
        await query.answer("Ошибка состояния FSM (ID роли).", show_alert=True); await state.clear(); return

    async with services_provider.db.get_session() as session:
        target_role = await session.get(DBRole, target_role_db_id, options=[selectinload(DBRole.permissions)])
        if not target_role:
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True); await state.clear(); return

        all_system_permissions = await services_provider.rbac.get_all_permissions(session)
        
        base_text = ROLES_MGMT_TEXTS["edit_permissions_for_role"].format(role_name=hbold(target_role.name))
        current_level_text = ""
        if category_key == "core":
            current_level_text = f" / Ядро"
            if entity_name: current_level_text += f" / {ADMIN_COMMON_TEXTS.get(f'perm_core_group_{entity_name}', entity_name.capitalize())}"
        elif category_key == "module":
            current_level_text = f" / Модули"
            if entity_name:
                mod_info = services_provider.modules.get_module_info(entity_name)
                current_level_text += f" / {mod_info.manifest.display_name if mod_info and mod_info.manifest else entity_name}"
        
        text = f"{base_text}{current_level_text}\nОтметьте разрешения для назначения/снятия:"
        
        keyboard = await get_admin_role_edit_permissions_keyboard_local(
            target_role=target_role, 
            all_system_permissions=all_system_permissions, 
            services=services_provider, 
            current_admin_tg_id=admin_user_id, 
            session=session,
            category_key=category_key, entity_name=entity_name, page=page
        )

        if query.message:
            try:
                if query.message.text != text or query.message.reply_markup != keyboard:
                    await query.message.edit_text(text, reply_markup=keyboard)
            except types.TelegramBadRequest as e:
                if "message is not modified" not in str(e).lower(): 
                    logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка edit_text (_show_role_permissions_menu): {e}")
            except Exception as e_edit:
                logger.error(f"Непредвиденная ошибка в _show_role_permissions_menu: {e_edit}", exc_info=True)
                if query.message: await query.answer("Ошибка отображения.", show_alert=True)

# Выход из FSM управления разрешениями роли (если пользователь нажимает "К деталям роли")
@role_permissions_router.callback_query(
    AdminRolesPanelNavigate.filter(F.action == "view"), 
    StateFilter(FSMEditRolePermissions.navigating_role_permissions) 
)
async def cq_back_to_role_details_from_perms_fsm(
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate, 
    services_provider: 'BotServicesProvider',
    state: FSMContext
):
    await state.clear() 
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {query.from_user.id} вышел из FSM управления разрешениями роли.")
    from .handlers_details import cq_admin_role_view_details_entry
    await cq_admin_role_view_details_entry(query, callback_data, services_provider)


======================================================================

------------------------------ FILE: core/admin/roles/handlers_details.py ------------------------------
# core/admin/roles/handlers_details.py
from aiogram import Router, types, F, Bot
from aiogram.utils.markdown import hbold, hcode, hitalic
from loguru import logger
from sqlalchemy.orm import selectinload
from sqlalchemy import select, func as sql_func 
from aiogram.exceptions import TelegramBadRequest 

from core.ui.callback_data_factories import AdminRolesPanelNavigate
from .keyboards_roles import get_admin_role_details_keyboard_local, ROLES_MGMT_TEXTS
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS
from core.admin.filters_admin import can_view_admin_panel_filter
from core.rbac.service import PERMISSION_CORE_ROLES_VIEW, DEFAULT_ROLES_DEFINITIONS
from core.database.core_models import Role as DBRole

from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession 

role_details_router = Router(name="sdb_admin_role_details_handlers")
MODULE_NAME_FOR_LOG = "AdminRoleMgmtDetails"

#role_details_router.callback_query.filter(can_view_admin_panel_filter)

@role_details_router.callback_query(AdminRolesPanelNavigate.filter(F.action == "view"))
async def cq_admin_role_view_details_entry( 
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate, 
    services_provider: 'BotServicesProvider'
):
    # logger.critical(f"!!! [{MODULE_NAME_FOR_LOG}] ХЭНДЛЕР cq_admin_role_view_details_entry ВЫЗВАН! Callback: {callback_data.model_dump_json(exclude_none=True)}") # <--- УБРАНО
    
    admin_user_id = query.from_user.id
    target_role_db_id: Optional[int] = None 
    
    logger.debug(f"[{MODULE_NAME_FOR_LOG}] Получен callback для просмотра деталей роли: {callback_data.model_dump_json(exclude_none=True)}")

    if callback_data.item_id is None or not str(callback_data.item_id).isdigit():
        logger.warning(f"[{MODULE_NAME_FOR_LOG}] Отсутствует или некорректный item_id (ID роли: {callback_data.item_id}) для просмотра деталей.")
        await query.answer("Ошибка: ID роли не указан или некорректен.", show_alert=True)
        return
    
    target_role_db_id = int(str(callback_data.item_id))
        
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} запросил детали роли с DB ID: {target_role_db_id}")

    async with services_provider.db.get_session() as session: # type: AsyncSession
        has_perm_to_view = False
        is_owner_from_config = admin_user_id in services_provider.config.core.super_admins
        if is_owner_from_config:
            has_perm_to_view = True
            logger.trace(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} является Владельцем, доступ к деталям роли разрешен.")
        else:
            try:
                has_perm_to_view = await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_VIEW)
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} имеет право '{PERMISSION_CORE_ROLES_VIEW}': {has_perm_to_view}")
            except Exception as e_perm:
                 logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка проверки права PERMISSION_CORE_ROLES_VIEW для {admin_user_id}: {e_perm}")
                 await query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)
                 return

        if not has_perm_to_view:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Админ {admin_user_id} не имеет прав для просмотра деталей роли.")
            await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True)
            return

        role = await session.get(DBRole, target_role_db_id, options=[selectinload(DBRole.permissions)])
        
        if not role:
            logger.warning(f"[{MODULE_NAME_FOR_LOG}] Роль с DB ID: {target_role_db_id} не найдена.")
            await query.answer(ADMIN_COMMON_TEXTS["not_found_generic"], show_alert=True)
            return
        
        logger.debug(f"[{MODULE_NAME_FOR_LOG}] Роль '{role.name}' найдена, генерация текста и клавиатуры...")
        permissions_list_str = "\n".join(
            [f"  ▫️ {hcode(p.name)} ({hitalic(p.description or 'без описания')})" for p in sorted(role.permissions, key=lambda x: x.name)]
        ) if role.permissions else "  (нет назначенных разрешений)"

        text_parts = [
            f"{ROLES_MGMT_TEXTS['role_details_title']}: {hcode(role.name)}",
            f"   DB ID: {hcode(str(role.id))}",
            f"   Описание: {hitalic(role.description or 'отсутствует')}",
            f"\n{hbold('Разрешения этой роли:')}",
            permissions_list_str
        ]
        text = "\n".join(text_parts)
        
        keyboard = await get_admin_role_details_keyboard_local(role, services_provider, admin_user_id, session)
        logger.debug(f"[{MODULE_NAME_FOR_LOG}] Клавиатура для деталей роли '{role.name}' сгенерирована.")

        if query.message:
            try:
                if query.message.text != text or query.message.reply_markup != keyboard:
                    await query.message.edit_text(text, reply_markup=keyboard)
                    logger.debug(f"[{MODULE_NAME_FOR_LOG}] Сообщение с деталями роли '{role.name}' отредактировано.")
                else:
                    logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение деталей роли ({role.id}) не было изменено.")
                await query.answer()
            except TelegramBadRequest as e_tbr:
                if "message is not modified" in str(e_tbr).lower():
                    logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение деталей роли ({role.id}) не было изменено (поймано исключение).")
                    await query.answer()
                else:
                    logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка редактирования деталей роли ({role.id}): {e_tbr}")
            except Exception as e_edit:
                logger.error(f"[{MODULE_NAME_FOR_LOG}] Непредвиденная ошибка в cq_admin_role_view_details_entry для роли {role.id}: {e_edit}", exc_info=True)
                await query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)
        else: 
             logger.warning(f"[{MODULE_NAME_FOR_LOG}] query.message is None в cq_admin_role_view_details_entry для роли {role.id}.")
             await query.answer()


======================================================================

------------------------------ FILE: core/admin/roles/handlers_list.py ------------------------------
# core/admin/roles/handlers_list.py
from aiogram import Router, types, F, Bot 
from aiogram.utils.markdown import hbold
from loguru import logger
from sqlalchemy import select, func as sql_func
from aiogram.exceptions import TelegramBadRequest # <--- ИСПРАВЛЕН ИМПОРТ

from core.ui.callback_data_factories import AdminRolesPanelNavigate
from .keyboards_roles import get_admin_roles_list_keyboard_local, ROLES_MGMT_TEXTS
from core.admin.filters_admin import can_view_admin_panel_filter 
from core.rbac.service import PERMISSION_CORE_ROLES_VIEW
from core.database.core_models import Role as DBRole

from typing import TYPE_CHECKING, List
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider
    from sqlalchemy.ext.asyncio import AsyncSession 

roles_list_router = Router(name="sdb_admin_roles_list_handlers")
MODULE_NAME_FOR_LOG = "AdminRoleMgmtList"

#roles_list_router.callback_query.filter(can_view_admin_panel_filter) 

@roles_list_router.callback_query(AdminRolesPanelNavigate.filter(F.action == "list"))
async def cq_admin_roles_list_entry( 
    query: types.CallbackQuery,
    callback_data: AdminRolesPanelNavigate, 
    services_provider: 'BotServicesProvider',
    bot: Bot 
):
    admin_user_id = query.from_user.id
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Администратор {admin_user_id} запросил список ролей.")

    async with services_provider.db.get_session() as session: # type: AsyncSession
        has_perm_to_view_list = False
        is_owner_from_config = admin_user_id in services_provider.config.core.super_admins
        if is_owner_from_config:
            has_perm_to_view_list = True
        else:
            try:
                has_perm_to_view_list = await services_provider.rbac.user_has_permission(session, admin_user_id, PERMISSION_CORE_ROLES_VIEW)
            except Exception as e_perm_check_list:
                logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка проверки права PERMISSION_CORE_ROLES_VIEW для user {admin_user_id}: {e_perm_check_list}")
                await query.answer("Ошибка проверки прав.", show_alert=True) 
                return

        if not has_perm_to_view_list:
            await query.answer("У вас нет прав для просмотра списка ролей.", show_alert=True) 
            return
        
        all_roles: List[DBRole] = await services_provider.rbac.get_all_roles(session)
        
        text = f"{ROLES_MGMT_TEXTS['role_list_title']}\n{ROLES_MGMT_TEXTS['role_list_select_action']}"
        keyboard = await get_admin_roles_list_keyboard_local(all_roles, services_provider, admin_user_id, session)

        target_chat_id = query.message.chat.id if query.message else admin_user_id

        try:
            if query.message and (query.message.text != text or query.message.reply_markup != keyboard):
                await query.message.edit_text(text, reply_markup=keyboard)
                logger.debug(f"[{MODULE_NAME_FOR_LOG}] Сообщение со списком ролей отредактировано.")
            elif not query.message: 
                 await bot.send_message(target_chat_id, text, reply_markup=keyboard)
                 logger.debug(f"[{MODULE_NAME_FOR_LOG}] Сообщение со списком ролей отправлено (т.к. query.message был None).")
            else:
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение списка ролей не изменено.")
            await query.answer()
        except TelegramBadRequest as e_tbr: # Используем импортированный TelegramBadRequest
            if query.message and "message to edit not found" in str(e_tbr).lower(): 
                logger.warning(f"[{MODULE_NAME_FOR_LOG}] Сообщение для редактирования не найдено, отправка нового: {e_tbr}")
                await bot.send_message(target_chat_id, text, reply_markup=keyboard)
                await query.answer()
            elif "message is not modified" in str(e_tbr).lower():
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение списка ролей не изменено (поймано исключение).")
                await query.answer()
            else:
                logger.warning(f"[{MODULE_NAME_FOR_LOG}] Ошибка Telegram BadRequest при редактировании/отправке списка ролей: {e_tbr}")
                await query.answer("Ошибка отображения списка.", show_alert=True)
        except Exception as e_edit:
            logger.error(f"[{MODULE_NAME_FOR_LOG}] Непредвиденная ошибка в cq_admin_roles_list_entry: {e_edit}", exc_info=True)
            await query.answer("Ошибка отображения списка ролей.", show_alert=True)


======================================================================

------------------------------ FILE: core/admin/roles/__init__.py ------------------------------
# core/admin/roles/__init__.py
from aiogram import Router

# Импортируем "конечные" роутеры из этого раздела
from .handlers_list import roles_list_router
from .handlers_details import role_details_router
from .handlers_role_perms import role_permissions_router
from .handlers_crud_fsm import role_crud_fsm_router

# Создаем один "собирающий" роутер для всего раздела "roles"
section_roles_router = Router(name="sdb_admin_section_roles_router")

section_roles_router.include_router(roles_list_router)
section_roles_router.include_router(role_details_router)
section_roles_router.include_router(role_permissions_router)
section_roles_router.include_router(role_crud_fsm_router)

# Экспортируем только собирающий роутер с правильным именем
__all__ = ["section_roles_router"]


======================================================================

------------------------------ FILE: core/admin/sys_info/keyboards_sys_info.py ------------------------------
# core/admin/sys_info/keyboards_sys_info.py
from aiogram import types # <--- ДОБАВЛЕН ЭТОТ ИМПОРТ
from aiogram.utils.keyboard import InlineKeyboardBuilder
from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS, get_back_to_admin_main_menu_button

def get_sys_info_keyboard() -> types.InlineKeyboardMarkup: # Используем types.InlineKeyboardMarkup
    builder = InlineKeyboardBuilder()
    builder.row(get_back_to_admin_main_menu_button())
    return builder.as_markup()

# Если для sys_info потребуются свои тексты, их можно добавить сюда:
SYS_INFO_TEXTS = {
    "system_info_title": "🖥️ Системная информация SwiftDevBot",
    # ... другие тексты ...
}


======================================================================

------------------------------ FILE: core/admin/sys_info/handlers_sys_info.py ------------------------------
# SwiftDevBot/core/admin/sys_info/handlers_sys_info.py
import sys
import platform
from datetime import datetime, timezone 
import psutil 
import aiogram 
import asyncio 
import os 
from pathlib import Path

from aiogram import Router, types, F, Bot
from aiogram.utils.markdown import hbold, hcode 
from loguru import logger
from sqlalchemy import select, func as sql_func 
from aiogram.exceptions import TelegramBadRequest

from core.admin.keyboards_admin_common import ADMIN_COMMON_TEXTS
from .keyboards_sys_info import get_sys_info_keyboard
from core.ui.callback_data_factories import AdminSysInfoPanelNavigate
from core.admin.filters_admin import can_view_admin_panel_filter 
from core.rbac.service import PERMISSION_CORE_SYSTEM_VIEW_INFO_FULL, PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC
from core.database.core_models import User as DBUserModel 
from core.bot_entrypoint import PID_FILENAME

from typing import TYPE_CHECKING, List, Optional
if TYPE_CHECKING:
    from core.services_provider import BotServicesProvider

sys_info_router = Router(name="sdb_admin_sys_info_handlers")
MODULE_NAME_FOR_LOG = "AdminSysInfo"

async def _get_local_total_users_count(services_provider: 'BotServicesProvider') -> Optional[int]:
    try:
        async with services_provider.db.get_session() as session:
            count_stmt = select(sql_func.count(DBUserModel.id))
            total_users_result = await session.execute(count_stmt)
            return total_users_result.scalar_one_or_none() or 0
    except Exception as e: 
        logger.error(f"[{MODULE_NAME_FOR_LOG}] Ошибка при подсчете пользователей для SysInfo: {e}")
        return None

def format_uptime(start_time: Optional[datetime]) -> str:
    if not start_time:
        return "Н/Д"
    if start_time.tzinfo is None:
        start_time = start_time.replace(tzinfo=timezone.utc)
    uptime_delta = datetime.now(timezone.utc) - start_time
    days = uptime_delta.days
    hours, remainder = divmod(uptime_delta.seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    parts = []
    if days > 0: parts.append(f"{int(days)}д")
    if hours > 0: parts.append(f"{int(hours)}ч")
    if minutes > 0: parts.append(f"{int(minutes)}м")
    parts.append(f"{int(seconds)}с")
    return " ".join(parts) or "~0с"

@sys_info_router.callback_query(AdminSysInfoPanelNavigate.filter(F.action == "show"))
async def cq_admin_show_system_info_entry( 
    query: types.CallbackQuery, 
    callback_data: AdminSysInfoPanelNavigate, 
    services_provider: 'BotServicesProvider',
    bot: Bot 
):
    user_id = query.from_user.id 
    logger.info(f"[{MODULE_NAME_FOR_LOG}] Пользователь {user_id} запросил системную информацию.")

    can_view_full = False
    can_view_basic = False
    is_owner_from_config = user_id in services_provider.config.core.super_admins
    async with services_provider.db.get_session() as session:
        if not is_owner_from_config: 
            can_view_full = await services_provider.rbac.user_has_permission(session, user_id, PERMISSION_CORE_SYSTEM_VIEW_INFO_FULL)
            if not can_view_full: 
                can_view_basic = await services_provider.rbac.user_has_permission(session, user_id, PERMISSION_CORE_SYSTEM_VIEW_INFO_BASIC)
        
    if not (is_owner_from_config or can_view_full or can_view_basic):
        await query.answer(ADMIN_COMMON_TEXTS["access_denied"], show_alert=True)
        return

    s = services_provider.config 
    
    text_parts: List[str] = [f"🖥️ {hbold('Системная информация SwiftDevBot')}\n"]

    # Общая информация
    text_parts.append(f"ℹ️ {hbold('Общая информация')} ───")
    text_parts.append(f"  ▸ {hbold('SDB Core')}: {hcode(f'v{s.core.sdb_version}')}")
    text_parts.append(f"  ▸ {hbold('Python')}: {hcode(f'v{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')}")
    text_parts.append(f"  ▸ {hbold('Aiogram')}: {hcode(f'v{aiogram.__version__}')}")
    text_parts.append(f"  ▸ {hbold('ОС')}: {platform.system()} {platform.release()} ({platform.machine()})")
    
    # Процесс бота
    text_parts.append(f"\n🤖 {hbold('Процесс бота')} ───")
    current_pid_handler = os.getpid() 
    pid_file_path = s.core.project_data_path / PID_FILENAME
    
    pid_for_psutil_stats = current_pid_handler
    pid_display_str = hcode(str(current_pid_handler))

    if pid_file_path.is_file():
        try:
            pid_from_file = int(pid_file_path.read_text().strip())
            pid_display_str = hcode(str(pid_from_file))
            if psutil and psutil.pid_exists(pid_from_file):
                process = psutil.Process(pid_from_file)
                create_time = datetime.fromtimestamp(process.create_time(), tz=timezone.utc)
                uptime_val = format_uptime(create_time)
                start_time_str = create_time.strftime('%d.%m.%Y %H:%M')
                text_parts.append(f"  ▸ {hbold('Запущен')}: {start_time_str}")
                text_parts.append(f"  ▸ {hbold('PID')}: {pid_display_str}")
                text_parts.append(f"  ▸ {hbold('Время работы')}: {hbold(uptime_val)}")
                pid_for_psutil_stats = pid_from_file 
            else:
                status_msg = "Процесс не найден"
                if not psutil: status_msg += " (psutil недоступен)"
                text_parts.append(f"  ▸ {hbold('Статус (PID из файла)')}: {hcode(status_msg)} (PID: {pid_display_str})")
                text_parts.append(f"  ▸ {hbold('PID (хэндлера)')}: {hcode(str(current_pid_handler))}")
        except Exception as e_pid:
            logger.warning(f"Ошибка обработки PID-файла: {e_pid}")
            text_parts.append(f"  ▸ {hbold('PID (из файла)')}: {hcode('Ошибка чтения')}")
            text_parts.append(f"  ▸ {hbold('PID (хэндлера)')}: {hcode(str(current_pid_handler))}")
    elif psutil:
        try:
            process = psutil.Process(current_pid_handler)
            create_time = datetime.fromtimestamp(process.create_time(), tz=timezone.utc)
            uptime_val = format_uptime(create_time)
            start_time_str = create_time.strftime('%d.%m.%Y %H:%M')
            text_parts.append(f"  ▸ {hbold('Запущен (тек. процесс)')}: {start_time_str} (PID: {pid_display_str})")
            text_parts.append(f"  ▸ {hbold('Время работы (тек.)')}: {hbold(uptime_val)}")
        except Exception: 
             text_parts.append(f"  ▸ {hbold('Время работы')}: Н/Д (ошибка psutil для PID: {pid_display_str})")
    else:
        text_parts.append(f"  ▸ {hbold('PID')}: {pid_display_str}")
        text_parts.append(f"  ▸ {hbold('Время работы')}: Н/Д (PID-файл не найден / psutil недоступен)")

    if psutil:
        try:
            target_ps_proc = psutil.Process(pid_for_psutil_stats)
            mem_rss_mb = target_ps_proc.memory_info().rss / (1024 * 1024)
            cpu_perc = target_ps_proc.cpu_percent(interval=0.05)
            text_parts.append(f"  ▸ {hbold('Память (RSS)')}: {hbold(f'{mem_rss_mb:.2f} MB')}")
            text_parts.append(f"  ▸ {hbold('CPU (мгновен.)')}: {hbold(f'{cpu_perc:.1f}%')}")
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
             text_parts.append(f"  ▸ {hbold('Память/CPU')}: {hcode(f'Н/Д (процесс {pid_for_psutil_stats} недоступен)')}")
        except Exception as e_ps_stats:
             logger.warning(f"Ошибка psutil для статистики PID {pid_for_psutil_stats}: {e_ps_stats}")
             text_parts.append(f"  ▸ {hbold('Память/CPU')}: {hcode('Н/Д (ошибка psutil)')}")
    else:
        text_parts.append(f"  ▸ {hbold('Память/CPU')}: {hcode('psutil не установлен')}")

    # База данных
    text_parts.append(f"\n🗃️ {hbold('База данных')} ───")
    text_parts.append(f"  ▸ Тип: {hbold(s.db.type.upper())}")
    if s.db.type == "sqlite":
        text_parts.append(f"  ▸ Путь: {hcode(s.db.sqlite_path)}")
    
    # Кэш
    text_parts.append(f"\n💾 {hbold('Кэш')} ───")
    text_parts.append(f"  ▸ Тип: {hbold(s.cache.type.capitalize())}")
    if s.cache.type == "redis" and s.cache.redis_url:
        text_parts.append(f"  ▸ URL: {hcode(str(s.cache.redis_url))}") 
    text_parts.append(f"  ▸ Доступен: {'✅ Да' if services_provider.cache.is_available() else '❌ Нет'}")

    # Модули
    try:
        total_modules = len(services_provider.modules.get_all_modules_info())
        loaded_modules = len(services_provider.modules.get_loaded_modules_info(True, True))
        enabled_plugins = len(services_provider.modules.enabled_plugin_names)
        text_parts.append(f"\n🧩 {hbold('Модули')} ───")
        text_parts.append(f"  ▸ Всего найдено: {hbold(str(total_modules))}")
        text_parts.append(f"  ▸ Активных плагинов: {hbold(str(enabled_plugins))}")
        text_parts.append(f"  ▸ Успешно загружено: {hbold(str(loaded_modules))}")
    except Exception as e_mod_info:
        logger.warning(f"Не удалось получить информацию о модулях: {e_mod_info}")
        text_parts.append(f"\n🧩 {hbold('Модули')} ───")
        text_parts.append(f"  ▸ Ошибка получения информации")

    # Пользователи
    total_users_count = await _get_local_total_users_count(services_provider)
    total_users_str = hbold(str(total_users_count)) if total_users_count is not None else f"{hcode('[Ошибка]')}"
    text_parts.append(f"\n👥 {hbold('Пользователи')} ───")
    text_parts.append(f"  ▸ Всего в БД: {total_users_str}")

    text_response = "\n".join(text_parts)
    keyboard_sysinfo = get_sys_info_keyboard()

    if query.message:
        try:
            if query.message.text != text_response or query.message.reply_markup != keyboard_sysinfo:
                await query.message.edit_text(text_response, reply_markup=keyboard_sysinfo)
            else:
                logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение системной информации не было изменено.")
            await query.answer()
        except TelegramBadRequest as e_tbr: 
            if "message is not modified" in str(e_tbr).lower():
                 logger.trace(f"[{MODULE_NAME_FOR_LOG}] Сообщение системной информации не было изменено (поймано исключение).")
                 await query.answer()
            else:
                logger.error(f"[{MODULE_NAME_FOR_LOG}] TelegramBadRequest при отображении системной информации: {e_tbr}", exc_info=True)
                await query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)
        except Exception as e_edit:
            logger.error(f"[{MODULE_NAME_FOR_LOG}] Непредвиденная ошибка при отображении системной информации: {e_edit}", exc_info=True)
            await query.answer(ADMIN_COMMON_TEXTS["error_general"], show_alert=True)
    else:
        await query.answer()


======================================================================

------------------------------ FILE: core/admin/sys_info/__init__.py ------------------------------
# core/admin/sys_info/__init__.py
from aiogram import Router

# Импортируем "конечный" роутер
from .handlers_sys_info import sys_info_router

# Создаем "собирающий" роутер для раздела (хотя здесь он включает только один)
section_sys_info_router = Router(name="sdb_admin_section_sys_info_router")
section_sys_info_router.include_router(sys_info_router)

__all__ = ["section_sys_info_router"]


======================================================================

------------------------------ FILE: alembic_migrations/versions/d10040ec2cb7_initial_migration_for_core_tables.py ------------------------------
# alembic_migrations/script.py.mako
"""Initial migration for core tables

Revision ID: d10040ec2cb7
Revises: 
Create Date: 2025-06-14 08:36:19.434958

"""
from typing import Sequence, Union

from alembic import op # type: ignore
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'd10040ec2cb7'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('mod_example_table_one',
    sa.Column('name', sa.String(length=100), nullable=False, comment='Пример текстового поля'),
    sa.Column('description', sa.String(length=255), nullable=True, comment='Описание для примера'),
    sa.Column('is_active', sa.Boolean(), server_default='1', nullable=False),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_mod_example_table_one'))
    )
    op.create_index(op.f('ix_mod_example_table_one_id'), 'mod_example_table_one', ['id'], unique=False)
    op.create_table('mod_example_user_notes',
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False, comment='Telegram ID пользователя-владельца заметки'),
    sa.Column('note_text', sa.Text(), nullable=False, comment='Текст заметки'),
    sa.Column('is_done', sa.Boolean(), nullable=False, comment='Отмечена ли заметка как выполненная'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_mod_example_user_notes'))
    )
    op.create_index(op.f('ix_mod_example_user_notes_id'), 'mod_example_user_notes', ['id'], unique=False)
    op.create_index(op.f('ix_mod_example_user_notes_user_telegram_id'), 'mod_example_user_notes', ['user_telegram_id'], unique=False)
    op.create_table('sdb_permissions',
    sa.Column('name', sa.String(length=100), nullable=False, comment="Уникальное имя разрешения (например, 'view_users', 'manage_modules')"),
    sa.Column('description', sa.Text(), nullable=True, comment='Описание разрешения'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_sdb_permissions'))
    )
    op.create_index(op.f('ix_sdb_permissions_id'), 'sdb_permissions', ['id'], unique=False)
    op.create_index(op.f('ix_sdb_permissions_name'), 'sdb_permissions', ['name'], unique=True)
    op.create_table('sdb_roles',
    sa.Column('name', sa.String(length=50), nullable=False, comment='Уникальное имя роли'),
    sa.Column('description', sa.Text(), nullable=True, comment='Описание роли'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_sdb_roles'))
    )
    op.create_index(op.f('ix_sdb_roles_id'), 'sdb_roles', ['id'], unique=False)
    op.create_index(op.f('ix_sdb_roles_name'), 'sdb_roles', ['name'], unique=True)
    op.create_table('sdb_users',
    sa.Column('username_lower', sa.String(length=32), nullable=True, comment='Telegram username в нижнем регистре для поиска'),
    sa.Column('telegram_id', sa.BigInteger(), nullable=False, comment='Уникальный Telegram ID пользователя'),
    sa.Column('username', sa.String(length=32), nullable=True, comment='Telegram username (оригинальный регистр)'),
    sa.Column('first_name', sa.String(length=255), nullable=True, comment='Имя пользователя'),
    sa.Column('last_name', sa.String(length=255), nullable=True, comment='Фамилия пользователя'),
    sa.Column('preferred_language_code', sa.String(length=10), nullable=True, comment='Код языка бота'),
    sa.Column('is_active', sa.Boolean(), nullable=False, comment='Активен ли пользователь'),
    sa.Column('is_bot_blocked', sa.Boolean(), nullable=False, comment='Заблокировал ли пользователь бота'),
    sa.Column('last_activity_at', sa.DateTime(), nullable=True, comment='Время последней активности'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_sdb_users'))
    )
    op.create_index(op.f('ix_sdb_users_id'), 'sdb_users', ['id'], unique=False)
    op.create_index(op.f('ix_sdb_users_telegram_id'), 'sdb_users', ['telegram_id'], unique=True)
    op.create_index(op.f('ix_sdb_users_username'), 'sdb_users', ['username'], unique=False)
    op.create_index(op.f('ix_sdb_users_username_lower'), 'sdb_users', ['username_lower'], unique=False)
    op.create_table('mod_another_example_table',
    sa.Column('example_one_id', sa.Integer(), nullable=True),
    sa.Column('value', sa.String(length=200), nullable=False, comment='Пример строкового значения'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.ForeignKeyConstraint(['example_one_id'], ['mod_example_table_one.id'], name=op.f('fk_mod_another_example_table_example_one_id_mod_example_table_one'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_mod_another_example_table'))
    )
    op.create_index(op.f('ix_mod_another_example_table_id'), 'mod_another_example_table', ['id'], unique=False)
    op.create_table('sdb_role_permissions',
    sa.Column('role_id', sa.Integer(), nullable=False, comment='ID роли'),
    sa.Column('permission_id', sa.Integer(), nullable=False, comment='ID разрешения'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.ForeignKeyConstraint(['permission_id'], ['sdb_permissions.id'], name=op.f('fk_sdb_role_permissions_permission_id_sdb_permissions'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['role_id'], ['sdb_roles.id'], name=op.f('fk_sdb_role_permissions_role_id_sdb_roles'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_sdb_role_permissions')),
    sa.UniqueConstraint('role_id', 'permission_id', name='uq_sdb_role_permissions_role_id_permission_id')
    )
    op.create_index(op.f('ix_sdb_role_permissions_id'), 'sdb_role_permissions', ['id'], unique=False)
    op.create_index(op.f('ix_sdb_role_permissions_permission_id'), 'sdb_role_permissions', ['permission_id'], unique=False)
    op.create_index(op.f('ix_sdb_role_permissions_role_id'), 'sdb_role_permissions', ['role_id'], unique=False)
    op.create_table('sdb_user_permissions',
    sa.Column('user_id', sa.Integer(), nullable=False, comment='ID пользователя'),
    sa.Column('permission_id', sa.Integer(), nullable=False, comment='ID разрешения'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.ForeignKeyConstraint(['permission_id'], ['sdb_permissions.id'], name=op.f('fk_sdb_user_permissions_permission_id_sdb_permissions'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['sdb_users.id'], name=op.f('fk_sdb_user_permissions_user_id_sdb_users'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_sdb_user_permissions')),
    sa.UniqueConstraint('user_id', 'permission_id', name='uq_sdb_user_permissions_user_id_permission_id')
    )
    op.create_index(op.f('ix_sdb_user_permissions_id'), 'sdb_user_permissions', ['id'], unique=False)
    op.create_index(op.f('ix_sdb_user_permissions_permission_id'), 'sdb_user_permissions', ['permission_id'], unique=False)
    op.create_index(op.f('ix_sdb_user_permissions_user_id'), 'sdb_user_permissions', ['user_id'], unique=False)
    op.create_table('sdb_user_roles',
    sa.Column('user_id', sa.Integer(), nullable=False, comment='ID пользователя'),
    sa.Column('role_id', sa.Integer(), nullable=False, comment='ID роли'),
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
    sa.ForeignKeyConstraint(['role_id'], ['sdb_roles.id'], name=op.f('fk_sdb_user_roles_role_id_sdb_roles'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['sdb_users.id'], name=op.f('fk_sdb_user_roles_user_id_sdb_users'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_sdb_user_roles')),
    sa.UniqueConstraint('user_id', 'role_id', name='uq_sdb_user_roles_user_id_role_id')
    )
    op.create_index(op.f('ix_sdb_user_roles_id'), 'sdb_user_roles', ['id'], unique=False)
    op.create_index(op.f('ix_sdb_user_roles_role_id'), 'sdb_user_roles', ['role_id'], unique=False)
    op.create_index(op.f('ix_sdb_user_roles_user_id'), 'sdb_user_roles', ['user_id'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_sdb_user_roles_user_id'), table_name='sdb_user_roles')
    op.drop_index(op.f('ix_sdb_user_roles_role_id'), table_name='sdb_user_roles')
    op.drop_index(op.f('ix_sdb_user_roles_id'), table_name='sdb_user_roles')
    op.drop_table('sdb_user_roles')
    op.drop_index(op.f('ix_sdb_user_permissions_user_id'), table_name='sdb_user_permissions')
    op.drop_index(op.f('ix_sdb_user_permissions_permission_id'), table_name='sdb_user_permissions')
    op.drop_index(op.f('ix_sdb_user_permissions_id'), table_name='sdb_user_permissions')
    op.drop_table('sdb_user_permissions')
    op.drop_index(op.f('ix_sdb_role_permissions_role_id'), table_name='sdb_role_permissions')
    op.drop_index(op.f('ix_sdb_role_permissions_permission_id'), table_name='sdb_role_permissions')
    op.drop_index(op.f('ix_sdb_role_permissions_id'), table_name='sdb_role_permissions')
    op.drop_table('sdb_role_permissions')
    op.drop_index(op.f('ix_mod_another_example_table_id'), table_name='mod_another_example_table')
    op.drop_table('mod_another_example_table')
    op.drop_index(op.f('ix_sdb_users_username_lower'), table_name='sdb_users')
    op.drop_index(op.f('ix_sdb_users_username'), table_name='sdb_users')
    op.drop_index(op.f('ix_sdb_users_telegram_id'), table_name='sdb_users')
    op.drop_index(op.f('ix_sdb_users_id'), table_name='sdb_users')
    op.drop_table('sdb_users')
    op.drop_index(op.f('ix_sdb_roles_name'), table_name='sdb_roles')
    op.drop_index(op.f('ix_sdb_roles_id'), table_name='sdb_roles')
    op.drop_table('sdb_roles')
    op.drop_index(op.f('ix_sdb_permissions_name'), table_name='sdb_permissions')
    op.drop_index(op.f('ix_sdb_permissions_id'), table_name='sdb_permissions')
    op.drop_table('sdb_permissions')
    op.drop_index(op.f('ix_mod_example_user_notes_user_telegram_id'), table_name='mod_example_user_notes')
    op.drop_index(op.f('ix_mod_example_user_notes_id'), table_name='mod_example_user_notes')
    op.drop_table('mod_example_user_notes')
    op.drop_index(op.f('ix_mod_example_table_one_id'), table_name='mod_example_table_one')
    op.drop_table('mod_example_table_one')
    # ### end Alembic commands ###


======================================================================

------------------------------ FILE: alembic_migrations/versions/.gitkeep ------------------------------



======================================================================
